{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/high-level-opt.js"],"sourcesContent":["'use strict'\n\n// turn tar(1) style args like `C` into the more verbose things like `cwd`\n\nconst argmap = new Map([\n  ['C', 'cwd'],\n  ['f', 'file'],\n  ['z', 'gzip'],\n  ['P', 'preservePaths'],\n  ['U', 'unlink'],\n  ['strip-components', 'strip'],\n  ['stripComponents', 'strip'],\n  ['keep-newer', 'newer'],\n  ['keepNewer', 'newer'],\n  ['keep-newer-files', 'newer'],\n  ['keepNewerFiles', 'newer'],\n  ['k', 'keep'],\n  ['keep-existing', 'keep'],\n  ['keepExisting', 'keep'],\n  ['m', 'noMtime'],\n  ['no-mtime', 'noMtime'],\n  ['p', 'preserveOwner'],\n  ['L', 'follow'],\n  ['h', 'follow'],\n])\n\nmodule.exports = opt => opt ? Object.keys(opt).map(k => [\n  argmap.has(k) ? argmap.get(k) : k, opt[k],\n]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {}\n"],"names":[],"mappings":"AAAA;AAEA,0EAA0E;AAE1E,MAAM,SAAS,IAAI,IAAI;IACrB;QAAC;QAAK;KAAM;IACZ;QAAC;QAAK;KAAO;IACb;QAAC;QAAK;KAAO;IACb;QAAC;QAAK;KAAgB;IACtB;QAAC;QAAK;KAAS;IACf;QAAC;QAAoB;KAAQ;IAC7B;QAAC;QAAmB;KAAQ;IAC5B;QAAC;QAAc;KAAQ;IACvB;QAAC;QAAa;KAAQ;IACtB;QAAC;QAAoB;KAAQ;IAC7B;QAAC;QAAkB;KAAQ;IAC3B;QAAC;QAAK;KAAO;IACb;QAAC;QAAiB;KAAO;IACzB;QAAC;QAAgB;KAAO;IACxB;QAAC;QAAK;KAAU;IAChB;QAAC;QAAY;KAAU;IACvB;QAAC;QAAK;KAAgB;IACtB;QAAC;QAAK;KAAS;IACf;QAAC;QAAK;KAAS;CAChB;AAED,OAAO,OAAO,GAAG,CAAA,MAAO,MAAM,OAAO,IAAI,CAAC,KAAK,GAAG,CAAC,CAAA,IAAK;YACtD,OAAO,GAAG,CAAC,KAAK,OAAO,GAAG,CAAC,KAAK;YAAG,GAAG,CAAC,EAAE;SAC1C,EAAE,MAAM,CAAC,CAAC,KAAK,KAAO,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,EAAE,EAAE,GAAG,GAAG,OAAO,MAAM,CAAC,SAAS,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 95, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/normalize-windows-path.js"],"sourcesContent":["// on windows, either \\ or / are valid directory separators.\n// on unix, \\ is a valid character in filenames.\n// so, on windows, and only on windows, we replace all \\ chars with /,\n// so that we can use / as our one and only directory separator char.\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nmodule.exports = platform !== 'win32' ? p => p\n  : p => p && p.replace(/\\\\/g, '/')\n"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,gDAAgD;AAChD,sEAAsE;AACtE,qEAAqE;AAEpD;AAAjB,MAAM,WAAW,gKAAA,CAAA,UAAO,CAAC,GAAG,CAAC,yBAAyB,IAAI,gKAAA,CAAA,UAAO,CAAC,QAAQ;AAC1E,OAAO,OAAO,GAAG,aAAa,UAAU,CAAA,IAAK,IACzC,CAAA,IAAK,KAAK,EAAE,OAAO,CAAC,OAAO","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 107, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/read-entry.js"],"sourcesContent":["'use strict'\nconst { Minipass } = require('minipass')\nconst normPath = require('./normalize-windows-path.js')\n\nconst SLURP = Symbol('slurp')\nmodule.exports = class ReadEntry extends Minipass {\n  constructor (header, ex, gex) {\n    super()\n    // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n    this.pause()\n    this.extended = ex\n    this.globalExtended = gex\n    this.header = header\n    this.startBlockSize = 512 * Math.ceil(header.size / 512)\n    this.blockRemain = this.startBlockSize\n    this.remain = header.size\n    this.type = header.type\n    this.meta = false\n    this.ignore = false\n    switch (this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break\n\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this.meta = true\n        break\n\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n      default:\n        this.ignore = true\n    }\n\n    this.path = normPath(header.path)\n    this.mode = header.mode\n    if (this.mode) {\n      this.mode = this.mode & 0o7777\n    }\n    this.uid = header.uid\n    this.gid = header.gid\n    this.uname = header.uname\n    this.gname = header.gname\n    this.size = header.size\n    this.mtime = header.mtime\n    this.atime = header.atime\n    this.ctime = header.ctime\n    this.linkpath = normPath(header.linkpath)\n    this.uname = header.uname\n    this.gname = header.gname\n\n    if (ex) {\n      this[SLURP](ex)\n    }\n    if (gex) {\n      this[SLURP](gex, true)\n    }\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate')\n    }\n\n    const r = this.remain\n    const br = this.blockRemain\n    this.remain = Math.max(0, r - writeLen)\n    this.blockRemain = Math.max(0, br - writeLen)\n    if (this.ignore) {\n      return true\n    }\n\n    if (r >= writeLen) {\n      return super.write(data)\n    }\n\n    // r < writeLen\n    return super.write(data.slice(0, r))\n  }\n\n  [SLURP] (ex, global) {\n    for (const k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path')) {\n        this[k] = k === 'path' || k === 'linkpath' ? normPath(ex[k]) : ex[k]\n      }\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 208, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/types.js"],"sourcesContent":["'use strict'\n// map types from key to human-friendly name\nexports.name = new Map([\n  ['0', 'File'],\n  // same as File\n  ['', 'OldFile'],\n  ['1', 'Link'],\n  ['2', 'SymbolicLink'],\n  // Devices and FIFOs aren't fully supported\n  // they are parsed, but skipped when unpacking\n  ['3', 'CharacterDevice'],\n  ['4', 'BlockDevice'],\n  ['5', 'Directory'],\n  ['6', 'FIFO'],\n  // same as File\n  ['7', 'ContiguousFile'],\n  // pax headers\n  ['g', 'GlobalExtendedHeader'],\n  ['x', 'ExtendedHeader'],\n  // vendor-specific stuff\n  // skip\n  ['A', 'SolarisACL'],\n  // like 5, but with data, which should be skipped\n  ['D', 'GNUDumpDir'],\n  // metadata only, skip\n  ['I', 'Inode'],\n  // data = link path of next file\n  ['K', 'NextFileHasLongLinkpath'],\n  // data = path of next file\n  ['L', 'NextFileHasLongPath'],\n  // skip\n  ['M', 'ContinuationFile'],\n  // like L\n  ['N', 'OldGnuLongPath'],\n  // skip\n  ['S', 'SparseFile'],\n  // skip\n  ['V', 'TapeVolumeHeader'],\n  // like x\n  ['X', 'OldExtendedHeader'],\n])\n\n// map the other direction\nexports.code = new Map(Array.from(exports.name).map(kv => [kv[1], kv[0]]))\n"],"names":[],"mappings":"AAAA;AACA,4CAA4C;AAC5C,QAAQ,IAAI,GAAG,IAAI,IAAI;IACrB;QAAC;QAAK;KAAO;IACb,eAAe;IACf;QAAC;QAAI;KAAU;IACf;QAAC;QAAK;KAAO;IACb;QAAC;QAAK;KAAe;IACrB,2CAA2C;IAC3C,8CAA8C;IAC9C;QAAC;QAAK;KAAkB;IACxB;QAAC;QAAK;KAAc;IACpB;QAAC;QAAK;KAAY;IAClB;QAAC;QAAK;KAAO;IACb,eAAe;IACf;QAAC;QAAK;KAAiB;IACvB,cAAc;IACd;QAAC;QAAK;KAAuB;IAC7B;QAAC;QAAK;KAAiB;IACvB,wBAAwB;IACxB,OAAO;IACP;QAAC;QAAK;KAAa;IACnB,iDAAiD;IACjD;QAAC;QAAK;KAAa;IACnB,sBAAsB;IACtB;QAAC;QAAK;KAAQ;IACd,gCAAgC;IAChC;QAAC;QAAK;KAA0B;IAChC,2BAA2B;IAC3B;QAAC;QAAK;KAAsB;IAC5B,OAAO;IACP;QAAC;QAAK;KAAmB;IACzB,SAAS;IACT;QAAC;QAAK;KAAiB;IACvB,OAAO;IACP;QAAC;QAAK;KAAa;IACnB,OAAO;IACP;QAAC;QAAK;KAAmB;IACzB,SAAS;IACT;QAAC;QAAK;KAAoB;CAC3B;AAED,0BAA0B;AAC1B,QAAQ,IAAI,GAAG,IAAI,IAAI,MAAM,IAAI,CAAC,QAAQ,IAAI,EAAE,GAAG,CAAC,CAAA,KAAM;QAAC,EAAE,CAAC,EAAE;QAAE,EAAE,CAAC,EAAE;KAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 322, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/large-numbers.js"],"sourcesContent":["'use strict'\n// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\n\nconst encode = (num, buf) => {\n  if (!Number.isSafeInteger(num)) {\n  // The number is so large that javascript cannot represent it with integer\n  // precision.\n    throw Error('cannot encode number outside of javascript safe integer range')\n  } else if (num < 0) {\n    encodeNegative(num, buf)\n  } else {\n    encodePositive(num, buf)\n  }\n  return buf\n}\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80\n\n  for (var i = buf.length; i > 1; i--) {\n    buf[i - 1] = num & 0xff\n    num = Math.floor(num / 0x100)\n  }\n}\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff\n  var flipped = false\n  num = num * -1\n  for (var i = buf.length; i > 1; i--) {\n    var byte = num & 0xff\n    num = Math.floor(num / 0x100)\n    if (flipped) {\n      buf[i - 1] = onesComp(byte)\n    } else if (byte === 0) {\n      buf[i - 1] = 0\n    } else {\n      flipped = true\n      buf[i - 1] = twosComp(byte)\n    }\n  }\n}\n\nconst parse = (buf) => {\n  const pre = buf[0]\n  const value = pre === 0x80 ? pos(buf.slice(1, buf.length))\n    : pre === 0xff ? twos(buf)\n    : null\n  if (value === null) {\n    throw Error('invalid base256 encoding')\n  }\n\n  if (!Number.isSafeInteger(value)) {\n  // The number is so large that javascript cannot represent it with integer\n  // precision.\n    throw Error('parsed number outside of javascript safe integer range')\n  }\n\n  return value\n}\n\nconst twos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  var flipped = false\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    var f\n    if (flipped) {\n      f = onesComp(byte)\n    } else if (byte === 0) {\n      f = byte\n    } else {\n      flipped = true\n      f = twosComp(byte)\n    }\n    if (f !== 0) {\n      sum -= f * Math.pow(256, len - i - 1)\n    }\n  }\n  return sum\n}\n\nconst pos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    if (byte !== 0) {\n      sum += byte * Math.pow(256, len - i - 1)\n    }\n  }\n  return sum\n}\n\nconst onesComp = byte => (0xff ^ byte) & 0xff\n\nconst twosComp = byte => ((0xff ^ byte) + 1) & 0xff\n\nmodule.exports = {\n  encode,\n  parse,\n}\n"],"names":[],"mappings":"AAAA;AACA,oEAAoE;AACpE,4CAA4C;AAE5C,MAAM,SAAS,CAAC,KAAK;IACnB,IAAI,CAAC,OAAO,aAAa,CAAC,MAAM;QAChC,0EAA0E;QAC1E,aAAa;QACX,MAAM,MAAM;IACd,OAAO,IAAI,MAAM,GAAG;QAClB,eAAe,KAAK;IACtB,OAAO;QACL,eAAe,KAAK;IACtB;IACA,OAAO;AACT;AAEA,MAAM,iBAAiB,CAAC,KAAK;IAC3B,GAAG,CAAC,EAAE,GAAG;IAET,IAAK,IAAI,IAAI,IAAI,MAAM,EAAE,IAAI,GAAG,IAAK;QACnC,GAAG,CAAC,IAAI,EAAE,GAAG,MAAM;QACnB,MAAM,KAAK,KAAK,CAAC,MAAM;IACzB;AACF;AAEA,MAAM,iBAAiB,CAAC,KAAK;IAC3B,GAAG,CAAC,EAAE,GAAG;IACT,IAAI,UAAU;IACd,MAAM,MAAM,CAAC;IACb,IAAK,IAAI,IAAI,IAAI,MAAM,EAAE,IAAI,GAAG,IAAK;QACnC,IAAI,OAAO,MAAM;QACjB,MAAM,KAAK,KAAK,CAAC,MAAM;QACvB,IAAI,SAAS;YACX,GAAG,CAAC,IAAI,EAAE,GAAG,SAAS;QACxB,OAAO,IAAI,SAAS,GAAG;YACrB,GAAG,CAAC,IAAI,EAAE,GAAG;QACf,OAAO;YACL,UAAU;YACV,GAAG,CAAC,IAAI,EAAE,GAAG,SAAS;QACxB;IACF;AACF;AAEA,MAAM,QAAQ,CAAC;IACb,MAAM,MAAM,GAAG,CAAC,EAAE;IAClB,MAAM,QAAQ,QAAQ,OAAO,IAAI,IAAI,KAAK,CAAC,GAAG,IAAI,MAAM,KACpD,QAAQ,OAAO,KAAK,OACpB;IACJ,IAAI,UAAU,MAAM;QAClB,MAAM,MAAM;IACd;IAEA,IAAI,CAAC,OAAO,aAAa,CAAC,QAAQ;QAClC,0EAA0E;QAC1E,aAAa;QACX,MAAM,MAAM;IACd;IAEA,OAAO;AACT;AAEA,MAAM,OAAO,CAAC;IACZ,IAAI,MAAM,IAAI,MAAM;IACpB,IAAI,MAAM;IACV,IAAI,UAAU;IACd,IAAK,IAAI,IAAI,MAAM,GAAG,IAAI,CAAC,GAAG,IAAK;QACjC,IAAI,OAAO,GAAG,CAAC,EAAE;QACjB,IAAI;QACJ,IAAI,SAAS;YACX,IAAI,SAAS;QACf,OAAO,IAAI,SAAS,GAAG;YACrB,IAAI;QACN,OAAO;YACL,UAAU;YACV,IAAI,SAAS;QACf;QACA,IAAI,MAAM,GAAG;YACX,OAAO,IAAI,KAAK,GAAG,CAAC,KAAK,MAAM,IAAI;QACrC;IACF;IACA,OAAO;AACT;AAEA,MAAM,MAAM,CAAC;IACX,IAAI,MAAM,IAAI,MAAM;IACpB,IAAI,MAAM;IACV,IAAK,IAAI,IAAI,MAAM,GAAG,IAAI,CAAC,GAAG,IAAK;QACjC,IAAI,OAAO,GAAG,CAAC,EAAE;QACjB,IAAI,SAAS,GAAG;YACd,OAAO,OAAO,KAAK,GAAG,CAAC,KAAK,MAAM,IAAI;QACxC;IACF;IACA,OAAO;AACT;AAEA,MAAM,WAAW,CAAA,OAAQ,CAAC,OAAO,IAAI,IAAI;AAEzC,MAAM,WAAW,CAAA,OAAQ,AAAC,CAAC,OAAO,IAAI,IAAI,IAAK;AAE/C,OAAO,OAAO,GAAG;IACf;IACA;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 417, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/header.js"],"sourcesContent":["'use strict'\n// parse a 512-byte header block to a data object, or vice-versa\n// encode returns `true` if a pax extended header is needed, because\n// the data could not be faithfully encoded in a simple header.\n// (Also, check header.needPax to see if it needs a pax header.)\n\nconst types = require('./types.js')\nconst pathModule = require('path').posix\nconst large = require('./large-numbers.js')\n\nconst SLURP = Symbol('slurp')\nconst TYPE = Symbol('type')\n\nclass Header {\n  constructor (data, off, ex, gex) {\n    this.cksumValid = false\n    this.needPax = false\n    this.nullBlock = false\n\n    this.block = null\n    this.path = null\n    this.mode = null\n    this.uid = null\n    this.gid = null\n    this.size = null\n    this.mtime = null\n    this.cksum = null\n    this[TYPE] = '0'\n    this.linkpath = null\n    this.uname = null\n    this.gname = null\n    this.devmaj = 0\n    this.devmin = 0\n    this.atime = null\n    this.ctime = null\n\n    if (Buffer.isBuffer(data)) {\n      this.decode(data, off || 0, ex, gex)\n    } else if (data) {\n      this.set(data)\n    }\n  }\n\n  decode (buf, off, ex, gex) {\n    if (!off) {\n      off = 0\n    }\n\n    if (!buf || !(buf.length >= off + 512)) {\n      throw new Error('need 512 bytes for header')\n    }\n\n    this.path = decString(buf, off, 100)\n    this.mode = decNumber(buf, off + 100, 8)\n    this.uid = decNumber(buf, off + 108, 8)\n    this.gid = decNumber(buf, off + 116, 8)\n    this.size = decNumber(buf, off + 124, 12)\n    this.mtime = decDate(buf, off + 136, 12)\n    this.cksum = decNumber(buf, off + 148, 12)\n\n    // if we have extended or global extended headers, apply them now\n    // See https://github.com/npm/node-tar/pull/187\n    this[SLURP](ex)\n    this[SLURP](gex, true)\n\n    // old tar versions marked dirs as a file with a trailing /\n    this[TYPE] = decString(buf, off + 156, 1)\n    if (this[TYPE] === '') {\n      this[TYPE] = '0'\n    }\n    if (this[TYPE] === '0' && this.path.slice(-1) === '/') {\n      this[TYPE] = '5'\n    }\n\n    // tar implementations sometimes incorrectly put the stat(dir).size\n    // as the size in the tarball, even though Directory entries are\n    // not able to have any body at all.  In the very rare chance that\n    // it actually DOES have a body, we weren't going to do anything with\n    // it anyway, and it'll just be a warning about an invalid header.\n    if (this[TYPE] === '5') {\n      this.size = 0\n    }\n\n    this.linkpath = decString(buf, off + 157, 100)\n    if (buf.slice(off + 257, off + 265).toString() === 'ustar\\u000000') {\n      this.uname = decString(buf, off + 265, 32)\n      this.gname = decString(buf, off + 297, 32)\n      this.devmaj = decNumber(buf, off + 329, 8)\n      this.devmin = decNumber(buf, off + 337, 8)\n      if (buf[off + 475] !== 0) {\n        // definitely a prefix, definitely >130 chars.\n        const prefix = decString(buf, off + 345, 155)\n        this.path = prefix + '/' + this.path\n      } else {\n        const prefix = decString(buf, off + 345, 130)\n        if (prefix) {\n          this.path = prefix + '/' + this.path\n        }\n        this.atime = decDate(buf, off + 476, 12)\n        this.ctime = decDate(buf, off + 488, 12)\n      }\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n\n    this.cksumValid = sum === this.cksum\n    if (this.cksum === null && sum === 8 * 0x20) {\n      this.nullBlock = true\n    }\n  }\n\n  [SLURP] (ex, global) {\n    for (const k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path')) {\n        this[k] = ex[k]\n      }\n    }\n  }\n\n  encode (buf, off) {\n    if (!buf) {\n      buf = this.block = Buffer.alloc(512)\n      off = 0\n    }\n\n    if (!off) {\n      off = 0\n    }\n\n    if (!(buf.length >= off + 512)) {\n      throw new Error('need 512 bytes for header')\n    }\n\n    const prefixSize = this.ctime || this.atime ? 130 : 155\n    const split = splitPrefix(this.path || '', prefixSize)\n    const path = split[0]\n    const prefix = split[1]\n    this.needPax = split[2]\n\n    this.needPax = encString(buf, off, 100, path) || this.needPax\n    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax\n    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax\n    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax\n    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax\n    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax\n    buf[off + 156] = this[TYPE].charCodeAt(0)\n    this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax\n    buf.write('ustar\\u000000', off + 257, 8)\n    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax\n    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax\n    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax\n    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax\n    this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax\n    if (buf[off + 475] !== 0) {\n      this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax\n    } else {\n      this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax\n      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax\n      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n\n    this.cksum = sum\n    encNumber(buf, off + 148, 8, this.cksum)\n    this.cksumValid = true\n\n    return this.needPax\n  }\n\n  set (data) {\n    for (const i in data) {\n      if (data[i] !== null && data[i] !== undefined) {\n        this[i] = data[i]\n      }\n    }\n  }\n\n  get type () {\n    return types.name.get(this[TYPE]) || this[TYPE]\n  }\n\n  get typeKey () {\n    return this[TYPE]\n  }\n\n  set type (type) {\n    if (types.code.has(type)) {\n      this[TYPE] = types.code.get(type)\n    } else {\n      this[TYPE] = type\n    }\n  }\n}\n\nconst splitPrefix = (p, prefixSize) => {\n  const pathSize = 100\n  let pp = p\n  let prefix = ''\n  let ret\n  const root = pathModule.parse(p).root || '.'\n\n  if (Buffer.byteLength(pp) < pathSize) {\n    ret = [pp, prefix, false]\n  } else {\n    // first set prefix to the dir, and path to the base\n    prefix = pathModule.dirname(pp)\n    pp = pathModule.basename(pp)\n\n    do {\n      if (Buffer.byteLength(pp) <= pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize) {\n        // both fit!\n        ret = [pp, prefix, false]\n      } else if (Buffer.byteLength(pp) > pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize) {\n        // prefix fits in prefix, but path doesn't fit in path\n        ret = [pp.slice(0, pathSize - 1), prefix, true]\n      } else {\n        // make path take a bit from prefix\n        pp = pathModule.join(pathModule.basename(prefix), pp)\n        prefix = pathModule.dirname(prefix)\n      }\n    } while (prefix !== root && !ret)\n\n    // at this point, found no resolution, just truncate\n    if (!ret) {\n      ret = [p.slice(0, pathSize - 1), '', true]\n    }\n  }\n  return ret\n}\n\nconst decString = (buf, off, size) =>\n  buf.slice(off, off + size).toString('utf8').replace(/\\0.*/, '')\n\nconst decDate = (buf, off, size) =>\n  numToDate(decNumber(buf, off, size))\n\nconst numToDate = num => num === null ? null : new Date(num * 1000)\n\nconst decNumber = (buf, off, size) =>\n  buf[off] & 0x80 ? large.parse(buf.slice(off, off + size))\n  : decSmallNumber(buf, off, size)\n\nconst nanNull = value => isNaN(value) ? null : value\n\nconst decSmallNumber = (buf, off, size) =>\n  nanNull(parseInt(\n    buf.slice(off, off + size)\n      .toString('utf8').replace(/\\0.*$/, '').trim(), 8))\n\n// the maximum encodable as a null-terminated octal, by field size\nconst MAXNUM = {\n  12: 0o77777777777,\n  8: 0o7777777,\n}\n\nconst encNumber = (buf, off, size, number) =>\n  number === null ? false :\n  number > MAXNUM[size] || number < 0\n    ? (large.encode(number, buf.slice(off, off + size)), true)\n    : (encSmallNumber(buf, off, size, number), false)\n\nconst encSmallNumber = (buf, off, size, number) =>\n  buf.write(octalString(number, size), off, size, 'ascii')\n\nconst octalString = (number, size) =>\n  padOctal(Math.floor(number).toString(8), size)\n\nconst padOctal = (string, size) =>\n  (string.length === size - 1 ? string\n  : new Array(size - string.length - 1).join('0') + string + ' ') + '\\0'\n\nconst encDate = (buf, off, size, date) =>\n  date === null ? false :\n  encNumber(buf, off, size, date.getTime() / 1000)\n\n// enough to fill the longest string we've got\nconst NULLS = new Array(156).join('\\0')\n// pad with nulls, return true if it's longer or non-ascii\nconst encString = (buf, off, size, string) =>\n  string === null ? false :\n  (buf.write(string + NULLS, off, size, 'utf8'),\n  string.length !== Buffer.byteLength(string) || string.length > size)\n\nmodule.exports = Header\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 673, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/pax.js"],"sourcesContent":["'use strict'\nconst Header = require('./header.js')\nconst path = require('path')\n\nclass Pax {\n  constructor (obj, global) {\n    this.atime = obj.atime || null\n    this.charset = obj.charset || null\n    this.comment = obj.comment || null\n    this.ctime = obj.ctime || null\n    this.gid = obj.gid || null\n    this.gname = obj.gname || null\n    this.linkpath = obj.linkpath || null\n    this.mtime = obj.mtime || null\n    this.path = obj.path || null\n    this.size = obj.size || null\n    this.uid = obj.uid || null\n    this.uname = obj.uname || null\n    this.dev = obj.dev || null\n    this.ino = obj.ino || null\n    this.nlink = obj.nlink || null\n    this.global = global || false\n  }\n\n  encode () {\n    const body = this.encodeBody()\n    if (body === '') {\n      return null\n    }\n\n    const bodyLen = Buffer.byteLength(body)\n    // round up to 512 bytes\n    // add 512 for header\n    const bufLen = 512 * Math.ceil(1 + bodyLen / 512)\n    const buf = Buffer.allocUnsafe(bufLen)\n\n    // 0-fill the header section, it might not hit every field\n    for (let i = 0; i < 512; i++) {\n      buf[i] = 0\n    }\n\n    new Header({\n      // XXX split the path\n      // then the path should be PaxHeader + basename, but less than 99,\n      // prepend with the dirname\n      path: ('PaxHeader/' + path.basename(this.path)).slice(0, 99),\n      mode: this.mode || 0o644,\n      uid: this.uid || null,\n      gid: this.gid || null,\n      size: bodyLen,\n      mtime: this.mtime || null,\n      type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',\n      linkpath: '',\n      uname: this.uname || '',\n      gname: this.gname || '',\n      devmaj: 0,\n      devmin: 0,\n      atime: this.atime || null,\n      ctime: this.ctime || null,\n    }).encode(buf)\n\n    buf.write(body, 512, bodyLen, 'utf8')\n\n    // null pad after the body\n    for (let i = bodyLen + 512; i < buf.length; i++) {\n      buf[i] = 0\n    }\n\n    return buf\n  }\n\n  encodeBody () {\n    return (\n      this.encodeField('path') +\n      this.encodeField('ctime') +\n      this.encodeField('atime') +\n      this.encodeField('dev') +\n      this.encodeField('ino') +\n      this.encodeField('nlink') +\n      this.encodeField('charset') +\n      this.encodeField('comment') +\n      this.encodeField('gid') +\n      this.encodeField('gname') +\n      this.encodeField('linkpath') +\n      this.encodeField('mtime') +\n      this.encodeField('size') +\n      this.encodeField('uid') +\n      this.encodeField('uname')\n    )\n  }\n\n  encodeField (field) {\n    if (this[field] === null || this[field] === undefined) {\n      return ''\n    }\n    const v = this[field] instanceof Date ? this[field].getTime() / 1000\n      : this[field]\n    const s = ' ' +\n      (field === 'dev' || field === 'ino' || field === 'nlink'\n        ? 'SCHILY.' : '') +\n      field + '=' + v + '\\n'\n    const byteLen = Buffer.byteLength(s)\n    // the digits includes the length of the digits in ascii base-10\n    // so if it's 9 characters, then adding 1 for the 9 makes it 10\n    // which makes it 11 chars.\n    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1\n    if (byteLen + digits >= Math.pow(10, digits)) {\n      digits += 1\n    }\n    const len = digits + byteLen\n    return len + s\n  }\n}\n\nPax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g)\n\nconst merge = (a, b) =>\n  b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a\n\nconst parseKV = string =>\n  string\n    .replace(/\\n$/, '')\n    .split('\\n')\n    .reduce(parseKVLine, Object.create(null))\n\nconst parseKVLine = (set, line) => {\n  const n = parseInt(line, 10)\n\n  // XXX Values with \\n in them will fail this.\n  // Refactor to not be a naive line-by-line parse.\n  if (n !== Buffer.byteLength(line) + 1) {\n    return set\n  }\n\n  line = line.slice((n + ' ').length)\n  const kv = line.split('=')\n  const k = kv.shift().replace(/^SCHILY\\.(dev|ino|nlink)/, '$1')\n  if (!k) {\n    return set\n  }\n\n  const v = kv.join('=')\n  set[k] = /^([A-Z]+\\.)?([mac]|birth|creation)time$/.test(k)\n    ? new Date(v * 1000)\n    : /^[0-9]+$/.test(v) ? +v\n    : v\n  return set\n}\n\nmodule.exports = Pax\n"],"names":[],"mappings":"AA8BoB;AA9BpB;AACA,MAAM;AACN,MAAM;AAEN,MAAM;IACJ,YAAa,GAAG,EAAE,MAAM,CAAE;QACxB,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,IAAI;QAC1B,IAAI,CAAC,OAAO,GAAG,IAAI,OAAO,IAAI;QAC9B,IAAI,CAAC,OAAO,GAAG,IAAI,OAAO,IAAI;QAC9B,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,IAAI;QAC1B,IAAI,CAAC,GAAG,GAAG,IAAI,GAAG,IAAI;QACtB,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,IAAI;QAC1B,IAAI,CAAC,QAAQ,GAAG,IAAI,QAAQ,IAAI;QAChC,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,IAAI;QAC1B,IAAI,CAAC,IAAI,GAAG,IAAI,IAAI,IAAI;QACxB,IAAI,CAAC,IAAI,GAAG,IAAI,IAAI,IAAI;QACxB,IAAI,CAAC,GAAG,GAAG,IAAI,GAAG,IAAI;QACtB,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,IAAI;QAC1B,IAAI,CAAC,GAAG,GAAG,IAAI,GAAG,IAAI;QACtB,IAAI,CAAC,GAAG,GAAG,IAAI,GAAG,IAAI;QACtB,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK,IAAI;QAC1B,IAAI,CAAC,MAAM,GAAG,UAAU;IAC1B;IAEA,SAAU;QACR,MAAM,OAAO,IAAI,CAAC,UAAU;QAC5B,IAAI,SAAS,IAAI;YACf,OAAO;QACT;QAEA,MAAM,UAAU,8JAAA,CAAA,SAAM,CAAC,UAAU,CAAC;QAClC,wBAAwB;QACxB,qBAAqB;QACrB,MAAM,SAAS,MAAM,KAAK,IAAI,CAAC,IAAI,UAAU;QAC7C,MAAM,MAAM,8JAAA,CAAA,SAAM,CAAC,WAAW,CAAC;QAE/B,0DAA0D;QAC1D,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,IAAK;YAC5B,GAAG,CAAC,EAAE,GAAG;QACX;QAEA,IAAI,OAAO;YACT,qBAAqB;YACrB,kEAAkE;YAClE,2BAA2B;YAC3B,MAAM,CAAC,eAAe,KAAK,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC,GAAG;YACzD,MAAM,IAAI,CAAC,IAAI,IAAI;YACnB,KAAK,IAAI,CAAC,GAAG,IAAI;YACjB,KAAK,IAAI,CAAC,GAAG,IAAI;YACjB,MAAM;YACN,OAAO,IAAI,CAAC,KAAK,IAAI;YACrB,MAAM,IAAI,CAAC,MAAM,GAAG,yBAAyB;YAC7C,UAAU;YACV,OAAO,IAAI,CAAC,KAAK,IAAI;YACrB,OAAO,IAAI,CAAC,KAAK,IAAI;YACrB,QAAQ;YACR,QAAQ;YACR,OAAO,IAAI,CAAC,KAAK,IAAI;YACrB,OAAO,IAAI,CAAC,KAAK,IAAI;QACvB,GAAG,MAAM,CAAC;QAEV,IAAI,KAAK,CAAC,MAAM,KAAK,SAAS;QAE9B,0BAA0B;QAC1B,IAAK,IAAI,IAAI,UAAU,KAAK,IAAI,IAAI,MAAM,EAAE,IAAK;YAC/C,GAAG,CAAC,EAAE,GAAG;QACX;QAEA,OAAO;IACT;IAEA,aAAc;QACZ,OACE,IAAI,CAAC,WAAW,CAAC,UACjB,IAAI,CAAC,WAAW,CAAC,WACjB,IAAI,CAAC,WAAW,CAAC,WACjB,IAAI,CAAC,WAAW,CAAC,SACjB,IAAI,CAAC,WAAW,CAAC,SACjB,IAAI,CAAC,WAAW,CAAC,WACjB,IAAI,CAAC,WAAW,CAAC,aACjB,IAAI,CAAC,WAAW,CAAC,aACjB,IAAI,CAAC,WAAW,CAAC,SACjB,IAAI,CAAC,WAAW,CAAC,WACjB,IAAI,CAAC,WAAW,CAAC,cACjB,IAAI,CAAC,WAAW,CAAC,WACjB,IAAI,CAAC,WAAW,CAAC,UACjB,IAAI,CAAC,WAAW,CAAC,SACjB,IAAI,CAAC,WAAW,CAAC;IAErB;IAEA,YAAa,KAAK,EAAE;QAClB,IAAI,IAAI,CAAC,MAAM,KAAK,QAAQ,IAAI,CAAC,MAAM,KAAK,WAAW;YACrD,OAAO;QACT;QACA,MAAM,IAAI,IAAI,CAAC,MAAM,YAAY,OAAO,IAAI,CAAC,MAAM,CAAC,OAAO,KAAK,OAC5D,IAAI,CAAC,MAAM;QACf,MAAM,IAAI,MACR,CAAC,UAAU,SAAS,UAAU,SAAS,UAAU,UAC7C,YAAY,EAAE,IAClB,QAAQ,MAAM,IAAI;QACpB,MAAM,UAAU,8JAAA,CAAA,SAAM,CAAC,UAAU,CAAC;QAClC,gEAAgE;QAChE,+DAA+D;QAC/D,2BAA2B;QAC3B,IAAI,SAAS,KAAK,KAAK,CAAC,KAAK,GAAG,CAAC,WAAW,KAAK,GAAG,CAAC,OAAO;QAC5D,IAAI,UAAU,UAAU,KAAK,GAAG,CAAC,IAAI,SAAS;YAC5C,UAAU;QACZ;QACA,MAAM,MAAM,SAAS;QACrB,OAAO,MAAM;IACf;AACF;AAEA,IAAI,KAAK,GAAG,CAAC,QAAQ,IAAI,IAAM,IAAI,IAAI,MAAM,QAAQ,SAAS,KAAK;AAEnE,MAAM,QAAQ,CAAC,GAAG,IAChB,IAAI,OAAO,IAAI,CAAC,GAAG,MAAM,CAAC,CAAC,GAAG,IAAM,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,KAAK;AAE7D,MAAM,UAAU,CAAA,SACd,OACG,OAAO,CAAC,OAAO,IACf,KAAK,CAAC,MACN,MAAM,CAAC,aAAa,OAAO,MAAM,CAAC;AAEvC,MAAM,cAAc,CAAC,KAAK;IACxB,MAAM,IAAI,SAAS,MAAM;IAEzB,6CAA6C;IAC7C,iDAAiD;IACjD,IAAI,MAAM,8JAAA,CAAA,SAAM,CAAC,UAAU,CAAC,QAAQ,GAAG;QACrC,OAAO;IACT;IAEA,OAAO,KAAK,KAAK,CAAC,CAAC,IAAI,GAAG,EAAE,MAAM;IAClC,MAAM,KAAK,KAAK,KAAK,CAAC;IACtB,MAAM,IAAI,GAAG,KAAK,GAAG,OAAO,CAAC,4BAA4B;IACzD,IAAI,CAAC,GAAG;QACN,OAAO;IACT;IAEA,MAAM,IAAI,GAAG,IAAI,CAAC;IAClB,GAAG,CAAC,EAAE,GAAG,0CAA0C,IAAI,CAAC,KACpD,IAAI,KAAK,IAAI,QACb,WAAW,IAAI,CAAC,KAAK,CAAC,IACtB;IACJ,OAAO;AACT;AAEA,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 783, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/strip-trailing-slashes.js"],"sourcesContent":["// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nmodule.exports = str => {\n  let i = str.length - 1\n  let slashesStart = -1\n  while (i > -1 && str.charAt(i) === '/') {\n    slashesStart = i\n    i--\n  }\n  return slashesStart === -1 ? str : str.slice(0, slashesStart)\n}\n"],"names":[],"mappings":"AAAA,oCAAoC;AACpC,+CAA+C;AAC/C,6CAA6C;AAC7C,4CAA4C;AAC5C,OAAO,OAAO,GAAG,CAAA;IACf,IAAI,IAAI,IAAI,MAAM,GAAG;IACrB,IAAI,eAAe,CAAC;IACpB,MAAO,IAAI,CAAC,KAAK,IAAI,MAAM,CAAC,OAAO,IAAK;QACtC,eAAe;QACf;IACF;IACA,OAAO,iBAAiB,CAAC,IAAI,MAAM,IAAI,KAAK,CAAC,GAAG;AAClD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 801, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/warn-mixin.js"],"sourcesContent":["'use strict'\nmodule.exports = Base => class extends Base {\n  warn (code, message, data = {}) {\n    if (this.file) {\n      data.file = this.file\n    }\n    if (this.cwd) {\n      data.cwd = this.cwd\n    }\n    data.code = message instanceof Error && message.code || code\n    data.tarCode = code\n    if (!this.strict && data.recoverable !== false) {\n      if (message instanceof Error) {\n        data = Object.assign(message, data)\n        message = message.message\n      }\n      this.emit('warn', data.tarCode, message, data)\n    } else if (message instanceof Error) {\n      this.emit('error', Object.assign(message, data))\n    } else {\n      this.emit('error', Object.assign(new Error(`${code}: ${message}`), data))\n    }\n  }\n}\n"],"names":[],"mappings":"AAAA;AACA,OAAO,OAAO,GAAG,CAAA,OAAQ,cAAc;QACrC,KAAM,IAAI,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC,EAAE;YAC9B,IAAI,IAAI,CAAC,IAAI,EAAE;gBACb,KAAK,IAAI,GAAG,IAAI,CAAC,IAAI;YACvB;YACA,IAAI,IAAI,CAAC,GAAG,EAAE;gBACZ,KAAK,GAAG,GAAG,IAAI,CAAC,GAAG;YACrB;YACA,KAAK,IAAI,GAAG,mBAAmB,SAAS,QAAQ,IAAI,IAAI;YACxD,KAAK,OAAO,GAAG;YACf,IAAI,CAAC,IAAI,CAAC,MAAM,IAAI,KAAK,WAAW,KAAK,OAAO;gBAC9C,IAAI,mBAAmB,OAAO;oBAC5B,OAAO,OAAO,MAAM,CAAC,SAAS;oBAC9B,UAAU,QAAQ,OAAO;gBAC3B;gBACA,IAAI,CAAC,IAAI,CAAC,QAAQ,KAAK,OAAO,EAAE,SAAS;YAC3C,OAAO,IAAI,mBAAmB,OAAO;gBACnC,IAAI,CAAC,IAAI,CAAC,SAAS,OAAO,MAAM,CAAC,SAAS;YAC5C,OAAO;gBACL,IAAI,CAAC,IAAI,CAAC,SAAS,OAAO,MAAM,CAAC,IAAI,MAAM,GAAG,KAAK,EAAE,EAAE,SAAS,GAAG;YACrE;QACF;IACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 830, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/winchars.js"],"sourcesContent":["'use strict'\n\n// When writing files on Windows, translate the characters to their\n// 0xf000 higher-encoded versions.\n\nconst raw = [\n  '|',\n  '<',\n  '>',\n  '?',\n  ':',\n]\n\nconst win = raw.map(char =>\n  String.fromCharCode(0xf000 + char.charCodeAt(0)))\n\nconst toWin = new Map(raw.map((char, i) => [char, win[i]]))\nconst toRaw = new Map(win.map((char, i) => [char, raw[i]]))\n\nmodule.exports = {\n  encode: s => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s),\n  decode: s => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s),\n}\n"],"names":[],"mappings":"AAAA;AAEA,mEAAmE;AACnE,kCAAkC;AAElC,MAAM,MAAM;IACV;IACA;IACA;IACA;IACA;CACD;AAED,MAAM,MAAM,IAAI,GAAG,CAAC,CAAA,OAClB,OAAO,YAAY,CAAC,SAAS,KAAK,UAAU,CAAC;AAE/C,MAAM,QAAQ,IAAI,IAAI,IAAI,GAAG,CAAC,CAAC,MAAM,IAAM;QAAC;QAAM,GAAG,CAAC,EAAE;KAAC;AACzD,MAAM,QAAQ,IAAI,IAAI,IAAI,GAAG,CAAC,CAAC,MAAM,IAAM;QAAC;QAAM,GAAG,CAAC,EAAE;KAAC;AAEzD,OAAO,OAAO,GAAG;IACf,QAAQ,CAAA,IAAK,IAAI,MAAM,CAAC,CAAC,GAAG,IAAM,EAAE,KAAK,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,KAAK;IACjE,QAAQ,CAAA,IAAK,IAAI,MAAM,CAAC,CAAC,GAAG,IAAM,EAAE,KAAK,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,KAAK;AACnE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 858, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/strip-absolute-path.js"],"sourcesContent":["// unix absolute paths are also absolute on win32, so we use this for both\nconst { isAbsolute, parse } = require('path').win32\n\n// returns [root, stripped]\n// Note that windows will think that //x/y/z/a has a \"root\" of //x/y, and in\n// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /\n// explicitly if it's the first character.\n// drive-specific relative paths on Windows get their root stripped off even\n// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']\nmodule.exports = path => {\n  let r = ''\n\n  let parsed = parse(path)\n  while (isAbsolute(path) || parsed.root) {\n    // windows will think that //x/y/z has a \"root\" of //x/y/\n    // but strip the //?/C:/ off of //?/C:/path\n    const root = path.charAt(0) === '/' && path.slice(0, 4) !== '//?/' ? '/'\n      : parsed.root\n    path = path.slice(root.length)\n    r += root\n    parsed = parse(path)\n  }\n  return [r, path]\n}\n"],"names":[],"mappings":"AAAA,0EAA0E;AAC1E,MAAM,EAAE,UAAU,EAAE,KAAK,EAAE,GAAG,yFAAgB,KAAK;AAEnD,2BAA2B;AAC3B,4EAA4E;AAC5E,yEAAyE;AACzE,0CAA0C;AAC1C,4EAA4E;AAC5E,uEAAuE;AACvE,OAAO,OAAO,GAAG,CAAA;IACf,IAAI,IAAI;IAER,IAAI,SAAS,MAAM;IACnB,MAAO,WAAW,SAAS,OAAO,IAAI,CAAE;QACtC,yDAAyD;QACzD,2CAA2C;QAC3C,MAAM,OAAO,KAAK,MAAM,CAAC,OAAO,OAAO,KAAK,KAAK,CAAC,GAAG,OAAO,SAAS,MACjE,OAAO,IAAI;QACf,OAAO,KAAK,KAAK,CAAC,KAAK,MAAM;QAC7B,KAAK;QACL,SAAS,MAAM;IACjB;IACA,OAAO;QAAC;QAAG;KAAK;AAClB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 887, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/mode-fix.js"],"sourcesContent":["'use strict'\nmodule.exports = (mode, isDir, portable) => {\n  mode &= 0o7777\n\n  // in portable mode, use the minimum reasonable umask\n  // if this system creates files with 0o664 by default\n  // (as some linux distros do), then we'll write the\n  // archive with 0o644 instead.  Also, don't ever create\n  // a file that is not readable/writable by the owner.\n  if (portable) {\n    mode = (mode | 0o600) & ~0o22\n  }\n\n  // if dirs are readable, then they should be listable\n  if (isDir) {\n    if (mode & 0o400) {\n      mode |= 0o100\n    }\n    if (mode & 0o40) {\n      mode |= 0o10\n    }\n    if (mode & 0o4) {\n      mode |= 0o1\n    }\n  }\n  return mode\n}\n"],"names":[],"mappings":"AAAA;AACA,OAAO,OAAO,GAAG,CAAC,MAAM,OAAO;IAC7B,QAAQ;IAER,qDAAqD;IACrD,qDAAqD;IACrD,mDAAmD;IACnD,uDAAuD;IACvD,qDAAqD;IACrD,IAAI,UAAU;QACZ,OAAO,CAAC,OAAO,KAAK,IAAI,CAAC;IAC3B;IAEA,qDAAqD;IACrD,IAAI,OAAO;QACT,IAAI,OAAO,OAAO;YAChB,QAAQ;QACV;QACA,IAAI,OAAO,MAAM;YACf,QAAQ;QACV;QACA,IAAI,OAAO,KAAK;YACd,QAAQ;QACV;IACF;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 917, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/write-entry.js"],"sourcesContent":["'use strict'\nconst { Minipass } = require('minipass')\nconst Pax = require('./pax.js')\nconst Header = require('./header.js')\nconst fs = require('fs')\nconst path = require('path')\nconst normPath = require('./normalize-windows-path.js')\nconst stripSlash = require('./strip-trailing-slashes.js')\n\nconst prefixPath = (path, prefix) => {\n  if (!prefix) {\n    return normPath(path)\n  }\n  path = normPath(path).replace(/^\\.(\\/|$)/, '')\n  return stripSlash(prefix) + '/' + path\n}\n\nconst maxReadSize = 16 * 1024 * 1024\nconst PROCESS = Symbol('process')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst HEADER = Symbol('header')\nconst READ = Symbol('read')\nconst LSTAT = Symbol('lstat')\nconst ONLSTAT = Symbol('onlstat')\nconst ONREAD = Symbol('onread')\nconst ONREADLINK = Symbol('onreadlink')\nconst OPENFILE = Symbol('openfile')\nconst ONOPENFILE = Symbol('onopenfile')\nconst CLOSE = Symbol('close')\nconst MODE = Symbol('mode')\nconst AWAITDRAIN = Symbol('awaitDrain')\nconst ONDRAIN = Symbol('ondrain')\nconst PREFIX = Symbol('prefix')\nconst HAD_ERROR = Symbol('hadError')\nconst warner = require('./warn-mixin.js')\nconst winchars = require('./winchars.js')\nconst stripAbsolutePath = require('./strip-absolute-path.js')\n\nconst modeFix = require('./mode-fix.js')\n\nconst WriteEntry = warner(class WriteEntry extends Minipass {\n  constructor (p, opt) {\n    opt = opt || {}\n    super(opt)\n    if (typeof p !== 'string') {\n      throw new TypeError('path is required')\n    }\n    this.path = normPath(p)\n    // suppress atime, ctime, uid, gid, uname, gname\n    this.portable = !!opt.portable\n    // until node has builtin pwnam functions, this'll have to do\n    this.myuid = process.getuid && process.getuid() || 0\n    this.myuser = process.env.USER || ''\n    this.maxReadSize = opt.maxReadSize || maxReadSize\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.preservePaths = !!opt.preservePaths\n    this.cwd = normPath(opt.cwd || process.cwd())\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n    this.prefix = opt.prefix ? normPath(opt.prefix) : null\n\n    this.fd = null\n    this.blockLen = null\n    this.blockRemain = null\n    this.buf = null\n    this.offset = null\n    this.length = null\n    this.pos = null\n    this.remain = null\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    let pathWarn = false\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path)\n      if (root) {\n        this.path = stripped\n        pathWarn = root\n      }\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n    if (this.win32) {\n      // force the \\ to / normalization, since we might not *actually*\n      // be on windows, but want \\ to be considered a path separator.\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'))\n      p = p.replace(/\\\\/g, '/')\n    }\n\n    this.absolute = normPath(opt.absolute || path.resolve(this.cwd, p))\n\n    if (this.path === '') {\n      this.path = './'\n    }\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.statCache.has(this.absolute)) {\n      this[ONLSTAT](this.statCache.get(this.absolute))\n    } else {\n      this[LSTAT]()\n    }\n  }\n\n  emit (ev, ...data) {\n    if (ev === 'error') {\n      this[HAD_ERROR] = true\n    }\n    return super.emit(ev, ...data)\n  }\n\n  [LSTAT] () {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONLSTAT](stat)\n    })\n  }\n\n  [ONLSTAT] (stat) {\n    this.statCache.set(this.absolute, stat)\n    this.stat = stat\n    if (!stat.isFile()) {\n      stat.size = 0\n    }\n    this.type = getType(stat)\n    this.emit('stat', stat)\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    switch (this.type) {\n      case 'File': return this[FILE]()\n      case 'Directory': return this[DIRECTORY]()\n      case 'SymbolicLink': return this[SYMLINK]()\n      // unsupported types are ignored.\n      default: return this.end()\n    }\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [HEADER] () {\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true\n    }\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      // only apply the prefix to hard links.\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null :\n      this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime,\n    })\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink,\n      }).encode())\n    }\n    super.write(this.header.block)\n  }\n\n  [DIRECTORY] () {\n    if (this.path.slice(-1) !== '/') {\n      this.path += '/'\n    }\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [SYMLINK] () {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONREADLINK](linkpath)\n    })\n  }\n\n  [ONREADLINK] (linkpath) {\n    this.linkpath = normPath(linkpath)\n    this[HEADER]()\n    this.end()\n  }\n\n  [HARDLINK] (linkpath) {\n    this.type = 'Link'\n    this.linkpath = normPath(path.relative(this.cwd, linkpath))\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [FILE] () {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey)\n        if (linkpath.indexOf(this.cwd) === 0) {\n          return this[HARDLINK](linkpath)\n        }\n      }\n      this.linkCache.set(linkKey, this.absolute)\n    }\n\n    this[HEADER]()\n    if (this.stat.size === 0) {\n      return this.end()\n    }\n\n    this[OPENFILE]()\n  }\n\n  [OPENFILE] () {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONOPENFILE](fd)\n    })\n  }\n\n  [ONOPENFILE] (fd) {\n    this.fd = fd\n    if (this[HAD_ERROR]) {\n      return this[CLOSE]()\n    }\n\n    this.blockLen = 512 * Math.ceil(this.stat.size / 512)\n    this.blockRemain = this.blockLen\n    const bufLen = Math.min(this.blockLen, this.maxReadSize)\n    this.buf = Buffer.allocUnsafe(bufLen)\n    this.offset = 0\n    this.pos = 0\n    this.remain = this.stat.size\n    this.length = this.buf.length\n    this[READ]()\n  }\n\n  [READ] () {\n    const { fd, buf, offset, length, pos } = this\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        return this[CLOSE](() => this.emit('error', er))\n      }\n      this[ONREAD](bytesRead)\n    })\n  }\n\n  [CLOSE] (cb) {\n    fs.close(this.fd, cb)\n  }\n\n  [ONREAD] (bytesRead) {\n    if (bytesRead <= 0 && this.remain > 0) {\n      const er = new Error('encountered unexpected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    if (bytesRead > this.remain) {\n      const er = new Error('did not encounter expected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    // null out the rest of the buffer, if we could fit the block padding\n    // at the end of this loop, we've incremented bytesRead and this.remain\n    // to be incremented up to the blockRemain level, as if we had expected\n    // to get a null-padded file, and read it until the end.  then we will\n    // decrement both remain and blockRemain by bytesRead, and know that we\n    // reached the expected EOF, without any null buffer to append.\n    if (bytesRead === this.remain) {\n      for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {\n        this.buf[i + this.offset] = 0\n        bytesRead++\n        this.remain++\n      }\n    }\n\n    const writeBuf = this.offset === 0 && bytesRead === this.buf.length ?\n      this.buf : this.buf.slice(this.offset, this.offset + bytesRead)\n\n    const flushed = this.write(writeBuf)\n    if (!flushed) {\n      this[AWAITDRAIN](() => this[ONDRAIN]())\n    } else {\n      this[ONDRAIN]()\n    }\n  }\n\n  [AWAITDRAIN] (cb) {\n    this.once('drain', cb)\n  }\n\n  write (writeBuf) {\n    if (this.blockRemain < writeBuf.length) {\n      const er = new Error('writing more data than expected')\n      er.path = this.absolute\n      return this.emit('error', er)\n    }\n    this.remain -= writeBuf.length\n    this.blockRemain -= writeBuf.length\n    this.pos += writeBuf.length\n    this.offset += writeBuf.length\n    return super.write(writeBuf)\n  }\n\n  [ONDRAIN] () {\n    if (!this.remain) {\n      if (this.blockRemain) {\n        super.write(Buffer.alloc(this.blockRemain))\n      }\n      return this[CLOSE](er => er ? this.emit('error', er) : this.end())\n    }\n\n    if (this.offset >= this.length) {\n      // if we only have a smaller bit left to read, alloc a smaller buffer\n      // otherwise, keep it the same length it was before.\n      this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length))\n      this.offset = 0\n    }\n    this.length = this.buf.length - this.offset\n    this[READ]()\n  }\n})\n\nclass WriteEntrySync extends WriteEntry {\n  [LSTAT] () {\n    this[ONLSTAT](fs.lstatSync(this.absolute))\n  }\n\n  [SYMLINK] () {\n    this[ONREADLINK](fs.readlinkSync(this.absolute))\n  }\n\n  [OPENFILE] () {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))\n  }\n\n  [READ] () {\n    let threw = true\n    try {\n      const { fd, buf, offset, length, pos } = this\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos)\n      this[ONREAD](bytesRead)\n      threw = false\n    } finally {\n      // ignoring the error from close(2) is a bad practice, but at\n      // this point we already have an error, don't need another one\n      if (threw) {\n        try {\n          this[CLOSE](() => {})\n        } catch (er) {}\n      }\n    }\n  }\n\n  [AWAITDRAIN] (cb) {\n    cb()\n  }\n\n  [CLOSE] (cb) {\n    fs.closeSync(this.fd)\n    cb()\n  }\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends Minipass {\n  constructor (readEntry, opt) {\n    opt = opt || {}\n    super(opt)\n    this.preservePaths = !!opt.preservePaths\n    this.portable = !!opt.portable\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n\n    this.readEntry = readEntry\n    this.type = readEntry.type\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true\n    }\n\n    this.prefix = opt.prefix || null\n\n    this.path = normPath(readEntry.path)\n    this.mode = this[MODE](readEntry.mode)\n    this.uid = this.portable ? null : readEntry.uid\n    this.gid = this.portable ? null : readEntry.gid\n    this.uname = this.portable ? null : readEntry.uname\n    this.gname = this.portable ? null : readEntry.gname\n    this.size = readEntry.size\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime\n    this.atime = this.portable ? null : readEntry.atime\n    this.ctime = this.portable ? null : readEntry.ctime\n    this.linkpath = normPath(readEntry.linkpath)\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    let pathWarn = false\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path)\n      if (root) {\n        this.path = stripped\n        pathWarn = root\n      }\n    }\n\n    this.remain = readEntry.size\n    this.blockRemain = readEntry.startBlockSize\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime,\n    })\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.atime,\n        ctime: this.portable ? null : this.ctime,\n        gid: this.portable ? null : this.gid,\n        mtime: this.noMtime ? null : this.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.size,\n        uid: this.portable ? null : this.uid,\n        uname: this.portable ? null : this.uname,\n        dev: this.portable ? null : this.readEntry.dev,\n        ino: this.portable ? null : this.readEntry.ino,\n        nlink: this.portable ? null : this.readEntry.nlink,\n      }).encode())\n    }\n\n    super.write(this.header.block)\n    readEntry.pipe(this)\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate')\n    }\n    this.blockRemain -= writeLen\n    return super.write(data)\n  }\n\n  end () {\n    if (this.blockRemain) {\n      super.write(Buffer.alloc(this.blockRemain))\n    }\n    return super.end()\n  }\n})\n\nWriteEntry.Sync = WriteEntrySync\nWriteEntry.Tar = WriteEntryTar\n\nconst getType = stat =>\n  stat.isFile() ? 'File'\n  : stat.isDirectory() ? 'Directory'\n  : stat.isSymbolicLink() ? 'SymbolicLink'\n  : 'Unsupported'\n\nmodule.exports = WriteEntry\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1402, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/pack.js"],"sourcesContent":["'use strict'\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nclass PackJob {\n  constructor (path, absolute) {\n    this.path = path || './'\n    this.absolute = absolute\n    this.entry = null\n    this.stat = null\n    this.readdir = null\n    this.pending = false\n    this.ignore = false\n    this.piped = false\n  }\n}\n\nconst { Minipass } = require('minipass')\nconst zlib = require('minizlib')\nconst ReadEntry = require('./read-entry.js')\nconst WriteEntry = require('./write-entry.js')\nconst WriteEntrySync = WriteEntry.Sync\nconst WriteEntryTar = WriteEntry.Tar\nconst Yallist = require('yallist')\nconst EOF = Buffer.alloc(1024)\nconst ONSTAT = Symbol('onStat')\nconst ENDED = Symbol('ended')\nconst QUEUE = Symbol('queue')\nconst CURRENT = Symbol('current')\nconst PROCESS = Symbol('process')\nconst PROCESSING = Symbol('processing')\nconst PROCESSJOB = Symbol('processJob')\nconst JOBS = Symbol('jobs')\nconst JOBDONE = Symbol('jobDone')\nconst ADDFSENTRY = Symbol('addFSEntry')\nconst ADDTARENTRY = Symbol('addTarEntry')\nconst STAT = Symbol('stat')\nconst READDIR = Symbol('readdir')\nconst ONREADDIR = Symbol('onreaddir')\nconst PIPE = Symbol('pipe')\nconst ENTRY = Symbol('entry')\nconst ENTRYOPT = Symbol('entryOpt')\nconst WRITEENTRYCLASS = Symbol('writeEntryClass')\nconst WRITE = Symbol('write')\nconst ONDRAIN = Symbol('ondrain')\n\nconst fs = require('fs')\nconst path = require('path')\nconst warner = require('./warn-mixin.js')\nconst normPath = require('./normalize-windows-path.js')\n\nconst Pack = warner(class Pack extends Minipass {\n  constructor (opt) {\n    super(opt)\n    opt = opt || Object.create(null)\n    this.opt = opt\n    this.file = opt.file || ''\n    this.cwd = opt.cwd || process.cwd()\n    this.maxReadSize = opt.maxReadSize\n    this.preservePaths = !!opt.preservePaths\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.prefix = normPath(opt.prefix || '')\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.readdirCache = opt.readdirCache || new Map()\n\n    this[WRITEENTRYCLASS] = WriteEntry\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    this.portable = !!opt.portable\n    this.zip = null\n\n    if (opt.gzip || opt.brotli) {\n      if (opt.gzip && opt.brotli) {\n        throw new TypeError('gzip and brotli are mutually exclusive')\n      }\n      if (opt.gzip) {\n        if (typeof opt.gzip !== 'object') {\n          opt.gzip = {}\n        }\n        if (this.portable) {\n          opt.gzip.portable = true\n        }\n        this.zip = new zlib.Gzip(opt.gzip)\n      }\n      if (opt.brotli) {\n        if (typeof opt.brotli !== 'object') {\n          opt.brotli = {}\n        }\n        this.zip = new zlib.BrotliCompress(opt.brotli)\n      }\n      this.zip.on('data', chunk => super.write(chunk))\n      this.zip.on('end', _ => super.end())\n      this.zip.on('drain', _ => this[ONDRAIN]())\n      this.on('resume', _ => this.zip.resume())\n    } else {\n      this.on('drain', this[ONDRAIN])\n    }\n\n    this.noDirRecurse = !!opt.noDirRecurse\n    this.follow = !!opt.follow\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true\n\n    this[QUEUE] = new Yallist()\n    this[JOBS] = 0\n    this.jobs = +opt.jobs || 4\n    this[PROCESSING] = false\n    this[ENDED] = false\n  }\n\n  [WRITE] (chunk) {\n    return super.write(chunk)\n  }\n\n  add (path) {\n    this.write(path)\n    return this\n  }\n\n  end (path) {\n    if (path) {\n      this.write(path)\n    }\n    this[ENDED] = true\n    this[PROCESS]()\n    return this\n  }\n\n  write (path) {\n    if (this[ENDED]) {\n      throw new Error('write after end')\n    }\n\n    if (path instanceof ReadEntry) {\n      this[ADDTARENTRY](path)\n    } else {\n      this[ADDFSENTRY](path)\n    }\n    return this.flowing\n  }\n\n  [ADDTARENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p.path))\n    // in this case, we don't have to wait for the stat\n    if (!this.filter(p.path, p)) {\n      p.resume()\n    } else {\n      const job = new PackJob(p.path, absolute, false)\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))\n      job.entry.on('end', _ => this[JOBDONE](job))\n      this[JOBS] += 1\n      this[QUEUE].push(job)\n    }\n\n    this[PROCESS]()\n  }\n\n  [ADDFSENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p))\n    this[QUEUE].push(new PackJob(p, absolute))\n    this[PROCESS]()\n  }\n\n  [STAT] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    const stat = this.follow ? 'stat' : 'lstat'\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er) {\n        this.emit('error', er)\n      } else {\n        this[ONSTAT](job, stat)\n      }\n    })\n  }\n\n  [ONSTAT] (job, stat) {\n    this.statCache.set(job.absolute, stat)\n    job.stat = stat\n\n    // now we have the stat, we can filter it.\n    if (!this.filter(job.path, stat)) {\n      job.ignore = true\n    }\n\n    this[PROCESS]()\n  }\n\n  [READDIR] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONREADDIR](job, entries)\n    })\n  }\n\n  [ONREADDIR] (job, entries) {\n    this.readdirCache.set(job.absolute, entries)\n    job.readdir = entries\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    if (this[PROCESSING]) {\n      return\n    }\n\n    this[PROCESSING] = true\n    for (let w = this[QUEUE].head;\n      w !== null && this[JOBS] < this.jobs;\n      w = w.next) {\n      this[PROCESSJOB](w.value)\n      if (w.value.ignore) {\n        const p = w.next\n        this[QUEUE].removeNode(w)\n        w.next = p\n      }\n    }\n\n    this[PROCESSING] = false\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip) {\n        this.zip.end(EOF)\n      } else {\n        super.write(EOF)\n        super.end()\n      }\n    }\n  }\n\n  get [CURRENT] () {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value\n  }\n\n  [JOBDONE] (job) {\n    this[QUEUE].shift()\n    this[JOBS] -= 1\n    this[PROCESS]()\n  }\n\n  [PROCESSJOB] (job) {\n    if (job.pending) {\n      return\n    }\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped) {\n        this[PIPE](job)\n      }\n      return\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute)) {\n        this[ONSTAT](job, this.statCache.get(job.absolute))\n      } else {\n        this[STAT](job)\n      }\n    }\n    if (!job.stat) {\n      return\n    }\n\n    // filtered out!\n    if (job.ignore) {\n      return\n    }\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute)) {\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute))\n      } else {\n        this[READDIR](job)\n      }\n      if (!job.readdir) {\n        return\n      }\n    }\n\n    // we know it doesn't have an entry, because that got checked above\n    job.entry = this[ENTRY](job)\n    if (!job.entry) {\n      job.ignore = true\n      return\n    }\n\n    if (job === this[CURRENT] && !job.piped) {\n      this[PIPE](job)\n    }\n  }\n\n  [ENTRYOPT] (job) {\n    return {\n      onwarn: (code, msg, data) => this.warn(code, msg, data),\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime,\n      prefix: this.prefix,\n    }\n  }\n\n  [ENTRY] (job) {\n    this[JOBS] += 1\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))\n        .on('end', () => this[JOBDONE](job))\n        .on('error', er => this.emit('error', er))\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n\n  [ONDRAIN] () {\n    if (this[CURRENT] && this[CURRENT].entry) {\n      this[CURRENT].entry.resume()\n    }\n  }\n\n  // like .pipe() but using super, because our write() is special\n  [PIPE] (job) {\n    job.piped = true\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    const source = job.entry\n    const zip = this.zip\n\n    if (zip) {\n      source.on('data', chunk => {\n        if (!zip.write(chunk)) {\n          source.pause()\n        }\n      })\n    } else {\n      source.on('data', chunk => {\n        if (!super.write(chunk)) {\n          source.pause()\n        }\n      })\n    }\n  }\n\n  pause () {\n    if (this.zip) {\n      this.zip.pause()\n    }\n    return super.pause()\n  }\n})\n\nclass PackSync extends Pack {\n  constructor (opt) {\n    super(opt)\n    this[WRITEENTRYCLASS] = WriteEntrySync\n  }\n\n  // pause/resume are no-ops in sync streams.\n  pause () {}\n  resume () {}\n\n  [STAT] (job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync'\n    this[ONSTAT](job, fs[stat](job.absolute))\n  }\n\n  [READDIR] (job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute))\n  }\n\n  // gotta get it all in this tick\n  [PIPE] (job) {\n    const source = job.entry\n    const zip = this.zip\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    if (zip) {\n      source.on('data', chunk => {\n        zip.write(chunk)\n      })\n    } else {\n      source.on('data', chunk => {\n        super[WRITE](chunk)\n      })\n    }\n  }\n}\n\nPack.Sync = PackSync\n\nmodule.exports = Pack\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1786, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/parse.js"],"sourcesContent":["'use strict'\n\n// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\nconst warner = require('./warn-mixin.js')\nconst Header = require('./header.js')\nconst EE = require('events')\nconst Yallist = require('yallist')\nconst maxMetaEntrySize = 1024 * 1024\nconst Entry = require('./read-entry.js')\nconst Pax = require('./pax.js')\nconst zlib = require('minizlib')\nconst { nextTick } = require('process')\n\nconst gzipHeader = Buffer.from([0x1f, 0x8b])\nconst STATE = Symbol('state')\nconst WRITEENTRY = Symbol('writeEntry')\nconst READENTRY = Symbol('readEntry')\nconst NEXTENTRY = Symbol('nextEntry')\nconst PROCESSENTRY = Symbol('processEntry')\nconst EX = Symbol('extendedHeader')\nconst GEX = Symbol('globalExtendedHeader')\nconst META = Symbol('meta')\nconst EMITMETA = Symbol('emitMeta')\nconst BUFFER = Symbol('buffer')\nconst QUEUE = Symbol('queue')\nconst ENDED = Symbol('ended')\nconst EMITTEDEND = Symbol('emittedEnd')\nconst EMIT = Symbol('emit')\nconst UNZIP = Symbol('unzip')\nconst CONSUMECHUNK = Symbol('consumeChunk')\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub')\nconst CONSUMEBODY = Symbol('consumeBody')\nconst CONSUMEMETA = Symbol('consumeMeta')\nconst CONSUMEHEADER = Symbol('consumeHeader')\nconst CONSUMING = Symbol('consuming')\nconst BUFFERCONCAT = Symbol('bufferConcat')\nconst MAYBEEND = Symbol('maybeEnd')\nconst WRITING = Symbol('writing')\nconst ABORTED = Symbol('aborted')\nconst DONE = Symbol('onDone')\nconst SAW_VALID_ENTRY = Symbol('sawValidEntry')\nconst SAW_NULL_BLOCK = Symbol('sawNullBlock')\nconst SAW_EOF = Symbol('sawEOF')\nconst CLOSESTREAM = Symbol('closeStream')\n\nconst noop = _ => true\n\nmodule.exports = warner(class Parser extends EE {\n  constructor (opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.file = opt.file || ''\n\n    // set to boolean false when an entry starts.  1024 bytes of \\0\n    // is technically a valid tarball, albeit a boring one.\n    this[SAW_VALID_ENTRY] = null\n\n    // these BADARCHIVE errors can't be detected early. listen on DONE.\n    this.on(DONE, _ => {\n      if (this[STATE] === 'begin' || this[SAW_VALID_ENTRY] === false) {\n        // either less than 1 block of data, or all entries were invalid.\n        // Either way, probably not even a tarball.\n        this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format')\n      }\n    })\n\n    if (opt.ondone) {\n      this.on(DONE, opt.ondone)\n    } else {\n      this.on(DONE, _ => {\n        this.emit('prefinish')\n        this.emit('finish')\n        this.emit('end')\n      })\n    }\n\n    this.strict = !!opt.strict\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop\n    // Unlike gzip, brotli doesn't have any magic bytes to identify it\n    // Users need to explicitly tell us they're extracting a brotli file\n    // Or we infer from the file extension\n    const isTBR = (opt.file && (\n        opt.file.endsWith('.tar.br') || opt.file.endsWith('.tbr')))\n    // if it's a tbr file it MIGHT be brotli, but we don't know until\n    // we look at it and verify it's not a valid tar file.\n    this.brotli = !opt.gzip && opt.brotli !== undefined ? opt.brotli\n      : isTBR ? undefined\n      : false\n\n    // have to set this so that streams are ok piping into it\n    this.writable = true\n    this.readable = false\n\n    this[QUEUE] = new Yallist()\n    this[BUFFER] = null\n    this[READENTRY] = null\n    this[WRITEENTRY] = null\n    this[STATE] = 'begin'\n    this[META] = ''\n    this[EX] = null\n    this[GEX] = null\n    this[ENDED] = false\n    this[UNZIP] = null\n    this[ABORTED] = false\n    this[SAW_NULL_BLOCK] = false\n    this[SAW_EOF] = false\n\n    this.on('end', () => this[CLOSESTREAM]())\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n    if (typeof opt.onentry === 'function') {\n      this.on('entry', opt.onentry)\n    }\n  }\n\n  [CONSUMEHEADER] (chunk, position) {\n    if (this[SAW_VALID_ENTRY] === null) {\n      this[SAW_VALID_ENTRY] = false\n    }\n    let header\n    try {\n      header = new Header(chunk, position, this[EX], this[GEX])\n    } catch (er) {\n      return this.warn('TAR_ENTRY_INVALID', er)\n    }\n\n    if (header.nullBlock) {\n      if (this[SAW_NULL_BLOCK]) {\n        this[SAW_EOF] = true\n        // ending an archive with no entries.  pointless, but legal.\n        if (this[STATE] === 'begin') {\n          this[STATE] = 'header'\n        }\n        this[EMIT]('eof')\n      } else {\n        this[SAW_NULL_BLOCK] = true\n        this[EMIT]('nullBlock')\n      }\n    } else {\n      this[SAW_NULL_BLOCK] = false\n      if (!header.cksumValid) {\n        this.warn('TAR_ENTRY_INVALID', 'checksum failure', { header })\n      } else if (!header.path) {\n        this.warn('TAR_ENTRY_INVALID', 'path is required', { header })\n      } else {\n        const type = header.type\n        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {\n          this.warn('TAR_ENTRY_INVALID', 'linkpath required', { header })\n        } else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) {\n          this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', { header })\n        } else {\n          const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])\n\n          // we do this for meta & ignored entries as well, because they\n          // are still valid tar, or else we wouldn't know to ignore them\n          if (!this[SAW_VALID_ENTRY]) {\n            if (entry.remain) {\n              // this might be the one!\n              const onend = () => {\n                if (!entry.invalid) {\n                  this[SAW_VALID_ENTRY] = true\n                }\n              }\n              entry.on('end', onend)\n            } else {\n              this[SAW_VALID_ENTRY] = true\n            }\n          }\n\n          if (entry.meta) {\n            if (entry.size > this.maxMetaEntrySize) {\n              entry.ignore = true\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = 'ignore'\n              entry.resume()\n            } else if (entry.size > 0) {\n              this[META] = ''\n              entry.on('data', c => this[META] += c)\n              this[STATE] = 'meta'\n            }\n          } else {\n            this[EX] = null\n            entry.ignore = entry.ignore || !this.filter(entry.path, entry)\n\n            if (entry.ignore) {\n              // probably valid, just not something we care about\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = entry.remain ? 'ignore' : 'header'\n              entry.resume()\n            } else {\n              if (entry.remain) {\n                this[STATE] = 'body'\n              } else {\n                this[STATE] = 'header'\n                entry.end()\n              }\n\n              if (!this[READENTRY]) {\n                this[QUEUE].push(entry)\n                this[NEXTENTRY]()\n              } else {\n                this[QUEUE].push(entry)\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  [CLOSESTREAM] () {\n    nextTick(() => this.emit('close'))\n  }\n\n  [PROCESSENTRY] (entry) {\n    let go = true\n\n    if (!entry) {\n      this[READENTRY] = null\n      go = false\n    } else if (Array.isArray(entry)) {\n      this.emit.apply(this, entry)\n    } else {\n      this[READENTRY] = entry\n      this.emit('entry', entry)\n      if (!entry.emittedEnd) {\n        entry.on('end', _ => this[NEXTENTRY]())\n        go = false\n      }\n    }\n\n    return go\n  }\n\n  [NEXTENTRY] () {\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))\n\n    if (!this[QUEUE].length) {\n      // At this point, there's nothing in the queue, but we may have an\n      // entry which is being consumed (readEntry).\n      // If we don't, then we definitely can handle more data.\n      // If we do, and either it's flowing, or it has never had any data\n      // written to it, then it needs more.\n      // The only other possibility is that it has returned false from a\n      // write() call, so we wait for the next drain to continue.\n      const re = this[READENTRY]\n      const drainNow = !re || re.flowing || re.size === re.remain\n      if (drainNow) {\n        if (!this[WRITING]) {\n          this.emit('drain')\n        }\n      } else {\n        re.once('drain', _ => this.emit('drain'))\n      }\n    }\n  }\n\n  [CONSUMEBODY] (chunk, position) {\n    // write up to but no  more than writeEntry.blockRemain\n    const entry = this[WRITEENTRY]\n    const br = entry.blockRemain\n    const c = (br >= chunk.length && position === 0) ? chunk\n      : chunk.slice(position, position + br)\n\n    entry.write(c)\n\n    if (!entry.blockRemain) {\n      this[STATE] = 'header'\n      this[WRITEENTRY] = null\n      entry.end()\n    }\n\n    return c.length\n  }\n\n  [CONSUMEMETA] (chunk, position) {\n    const entry = this[WRITEENTRY]\n    const ret = this[CONSUMEBODY](chunk, position)\n\n    // if we finished, then the entry is reset\n    if (!this[WRITEENTRY]) {\n      this[EMITMETA](entry)\n    }\n\n    return ret\n  }\n\n  [EMIT] (ev, data, extra) {\n    if (!this[QUEUE].length && !this[READENTRY]) {\n      this.emit(ev, data, extra)\n    } else {\n      this[QUEUE].push([ev, data, extra])\n    }\n  }\n\n  [EMITMETA] (entry) {\n    this[EMIT]('meta', this[META])\n    switch (entry.type) {\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this[EX] = Pax.parse(this[META], this[EX], false)\n        break\n\n      case 'GlobalExtendedHeader':\n        this[GEX] = Pax.parse(this[META], this[GEX], true)\n        break\n\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].path = this[META].replace(/\\0.*/, '')\n        break\n\n      case 'NextFileHasLongLinkpath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].linkpath = this[META].replace(/\\0.*/, '')\n        break\n\n      /* istanbul ignore next */\n      default: throw new Error('unknown meta: ' + entry.type)\n    }\n  }\n\n  abort (error) {\n    this[ABORTED] = true\n    this.emit('abort', error)\n    // always throws, even in non-strict mode\n    this.warn('TAR_ABORT', error, { recoverable: false })\n  }\n\n  write (chunk) {\n    if (this[ABORTED]) {\n      return\n    }\n\n    // first write, might be gzipped\n    const needSniff = this[UNZIP] === null ||\n      this.brotli === undefined && this[UNZIP] === false\n    if (needSniff && chunk) {\n      if (this[BUFFER]) {\n        chunk = Buffer.concat([this[BUFFER], chunk])\n        this[BUFFER] = null\n      }\n      if (chunk.length < gzipHeader.length) {\n        this[BUFFER] = chunk\n        return true\n      }\n\n      // look for gzip header\n      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\n        if (chunk[i] !== gzipHeader[i]) {\n          this[UNZIP] = false\n        }\n      }\n\n      const maybeBrotli = this.brotli === undefined\n      if (this[UNZIP] === false && maybeBrotli) {\n        // read the first header to see if it's a valid tar file. If so,\n        // we can safely assume that it's not actually brotli, despite the\n        // .tbr or .tar.br file extension.\n        // if we ended before getting a full chunk, yes, def brotli\n        if (chunk.length < 512) {\n          if (this[ENDED]) {\n            this.brotli = true\n          } else {\n            this[BUFFER] = chunk\n            return true\n          }\n        } else {\n          // if it's tar, it's pretty reliably not brotli, chances of\n          // that happening are astronomical.\n          try {\n            new Header(chunk.slice(0, 512))\n            this.brotli = false\n          } catch (_) {\n            this.brotli = true\n          }\n        }\n      }\n\n      if (this[UNZIP] === null || (this[UNZIP] === false && this.brotli)) {\n        const ended = this[ENDED]\n        this[ENDED] = false\n        this[UNZIP] = this[UNZIP] === null\n          ? new zlib.Unzip()\n          : new zlib.BrotliDecompress()\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))\n        this[UNZIP].on('error', er => this.abort(er))\n        this[UNZIP].on('end', _ => {\n          this[ENDED] = true\n          this[CONSUMECHUNK]()\n        })\n        this[WRITING] = true\n        const ret = this[UNZIP][ended ? 'end' : 'write'](chunk)\n        this[WRITING] = false\n        return ret\n      }\n    }\n\n    this[WRITING] = true\n    if (this[UNZIP]) {\n      this[UNZIP].write(chunk)\n    } else {\n      this[CONSUMECHUNK](chunk)\n    }\n    this[WRITING] = false\n\n    // return false if there's a queue, or if the current entry isn't flowing\n    const ret =\n      this[QUEUE].length ? false :\n      this[READENTRY] ? this[READENTRY].flowing :\n      true\n\n    // if we have no queue, then that means a clogged READENTRY\n    if (!ret && !this[QUEUE].length) {\n      this[READENTRY].once('drain', _ => this.emit('drain'))\n    }\n\n    return ret\n  }\n\n  [BUFFERCONCAT] (c) {\n    if (c && !this[ABORTED]) {\n      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c\n    }\n  }\n\n  [MAYBEEND] () {\n    if (this[ENDED] &&\n        !this[EMITTEDEND] &&\n        !this[ABORTED] &&\n        !this[CONSUMING]) {\n      this[EMITTEDEND] = true\n      const entry = this[WRITEENTRY]\n      if (entry && entry.blockRemain) {\n        // truncated, likely a damaged file\n        const have = this[BUFFER] ? this[BUFFER].length : 0\n        this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${\n          entry.blockRemain} more bytes, only ${have} available)`, { entry })\n        if (this[BUFFER]) {\n          entry.write(this[BUFFER])\n        }\n        entry.end()\n      }\n      this[EMIT](DONE)\n    }\n  }\n\n  [CONSUMECHUNK] (chunk) {\n    if (this[CONSUMING]) {\n      this[BUFFERCONCAT](chunk)\n    } else if (!chunk && !this[BUFFER]) {\n      this[MAYBEEND]()\n    } else {\n      this[CONSUMING] = true\n      if (this[BUFFER]) {\n        this[BUFFERCONCAT](chunk)\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      } else {\n        this[CONSUMECHUNKSUB](chunk)\n      }\n\n      while (this[BUFFER] &&\n          this[BUFFER].length >= 512 &&\n          !this[ABORTED] &&\n          !this[SAW_EOF]) {\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      }\n      this[CONSUMING] = false\n    }\n\n    if (!this[BUFFER] || this[ENDED]) {\n      this[MAYBEEND]()\n    }\n  }\n\n  [CONSUMECHUNKSUB] (chunk) {\n    // we know that we are in CONSUMING mode, so anything written goes into\n    // the buffer.  Advance the position and put any remainder in the buffer.\n    let position = 0\n    const length = chunk.length\n    while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {\n      switch (this[STATE]) {\n        case 'begin':\n        case 'header':\n          this[CONSUMEHEADER](chunk, position)\n          position += 512\n          break\n\n        case 'ignore':\n        case 'body':\n          position += this[CONSUMEBODY](chunk, position)\n          break\n\n        case 'meta':\n          position += this[CONSUMEMETA](chunk, position)\n          break\n\n        /* istanbul ignore next */\n        default:\n          throw new Error('invalid state: ' + this[STATE])\n      }\n    }\n\n    if (position < length) {\n      if (this[BUFFER]) {\n        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])\n      } else {\n        this[BUFFER] = chunk.slice(position)\n      }\n    }\n  }\n\n  end (chunk) {\n    if (!this[ABORTED]) {\n      if (this[UNZIP]) {\n        this[UNZIP].end(chunk)\n      } else {\n        this[ENDED] = true\n        if (this.brotli === undefined) chunk = chunk || Buffer.alloc(0)\n        this.write(chunk)\n      }\n    }\n  }\n})\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2294, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/list.js"],"sourcesContent":["'use strict'\n\n// XXX: This shares a lot in common with extract.js\n// maybe some DRY opportunity here?\n\n// tar -t\nconst hlo = require('./high-level-opt.js')\nconst Parser = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst stripSlash = require('./strip-trailing-slashes.js')\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function') {\n    cb = opt_, files = null, opt_ = {}\n  } else if (Array.isArray(opt_)) {\n    files = opt_, opt_ = {}\n  }\n\n  if (typeof files === 'function') {\n    cb = files, files = null\n  }\n\n  if (!files) {\n    files = []\n  } else {\n    files = Array.from(files)\n  }\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function') {\n    throw new TypeError('callback not supported for sync tar functions')\n  }\n\n  if (!opt.file && typeof cb === 'function') {\n    throw new TypeError('callback only supported with file option')\n  }\n\n  if (files.length) {\n    filesFilter(opt, files)\n  }\n\n  if (!opt.noResume) {\n    onentryFunction(opt)\n  }\n\n  return opt.file && opt.sync ? listFileSync(opt)\n    : opt.file ? listFile(opt, cb)\n    : list(opt)\n}\n\nconst onentryFunction = opt => {\n  const onentry = opt.onentry\n  opt.onentry = onentry ? e => {\n    onentry(e)\n    e.resume()\n  } : e => e.resume()\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [stripSlash(f), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))\n    : file => mapHas(stripSlash(file))\n}\n\nconst listFileSync = opt => {\n  const p = list(opt)\n  const file = opt.file\n  let threw = true\n  let fd\n  try {\n    const stat = fs.statSync(file)\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024\n    if (stat.size < readSize) {\n      p.end(fs.readFileSync(file))\n    } else {\n      let pos = 0\n      const buf = Buffer.allocUnsafe(readSize)\n      fd = fs.openSync(file, 'r')\n      while (pos < stat.size) {\n        const bytesRead = fs.readSync(fd, buf, 0, readSize, pos)\n        pos += bytesRead\n        p.write(buf.slice(0, bytesRead))\n      }\n      p.end()\n    }\n    threw = false\n  } finally {\n    if (threw && fd) {\n      try {\n        fs.closeSync(fd)\n      } catch (er) {}\n    }\n  }\n}\n\nconst listFile = (opt, cb) => {\n  const parse = new Parser(opt)\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    parse.on('error', reject)\n    parse.on('end', resolve)\n\n    fs.stat(file, (er, stat) => {\n      if (er) {\n        reject(er)\n      } else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size,\n        })\n        stream.on('error', reject)\n        stream.pipe(parse)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst list = opt => new Parser(opt)\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2419, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/create.js"],"sourcesContent":["'use strict'\n\n// tar -c\nconst hlo = require('./high-level-opt.js')\n\nconst Pack = require('./pack.js')\nconst fsm = require('fs-minipass')\nconst t = require('./list.js')\nconst path = require('path')\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof files === 'function') {\n    cb = files\n  }\n\n  if (Array.isArray(opt_)) {\n    files = opt_, opt_ = {}\n  }\n\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified')\n  }\n\n  files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function') {\n    throw new TypeError('callback not supported for sync tar functions')\n  }\n\n  if (!opt.file && typeof cb === 'function') {\n    throw new TypeError('callback only supported with file option')\n  }\n\n  return opt.file && opt.sync ? createFileSync(opt, files)\n    : opt.file ? createFile(opt, files, cb)\n    : opt.sync ? createSync(opt, files)\n    : create(opt, files)\n}\n\nconst createFileSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    mode: opt.mode || 0o666,\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst createFile = (opt, files, cb) => {\n  const p = new Pack(opt)\n  const stream = new fsm.WriteStream(opt.file, {\n    mode: opt.mode || 0o666,\n  })\n  p.pipe(stream)\n\n  const promise = new Promise((res, rej) => {\n    stream.on('error', rej)\n    stream.on('close', res)\n    p.on('error', rej)\n  })\n\n  addFilesAsync(p, files)\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry),\n      })\n    } else {\n      p.add(file)\n    }\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        noResume: true,\n        onentry: entry => p.add(entry),\n      }).then(_ => addFilesAsync(p, files))\n    } else {\n      p.add(file)\n    }\n  }\n  p.end()\n}\n\nconst createSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  addFilesSync(p, files)\n  return p\n}\n\nconst create = (opt, files) => {\n  const p = new Pack(opt)\n  addFilesAsync(p, files)\n  return p\n}\n"],"names":[],"mappings":"AAAA;AAEA,SAAS;AACT,MAAM;AAEN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AAEN,OAAO,OAAO,GAAG,CAAC,MAAM,OAAO;IAC7B,IAAI,OAAO,UAAU,YAAY;QAC/B,KAAK;IACP;IAEA,IAAI,MAAM,OAAO,CAAC,OAAO;QACvB,QAAQ,MAAM,OAAO,CAAC;IACxB;IAEA,IAAI,CAAC,SAAS,CAAC,MAAM,OAAO,CAAC,UAAU,CAAC,MAAM,MAAM,EAAE;QACpD,MAAM,IAAI,UAAU;IACtB;IAEA,QAAQ,MAAM,IAAI,CAAC;IAEnB,MAAM,MAAM,IAAI;IAEhB,IAAI,IAAI,IAAI,IAAI,OAAO,OAAO,YAAY;QACxC,MAAM,IAAI,UAAU;IACtB;IAEA,IAAI,CAAC,IAAI,IAAI,IAAI,OAAO,OAAO,YAAY;QACzC,MAAM,IAAI,UAAU;IACtB;IAEA,OAAO,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG,eAAe,KAAK,SAC9C,IAAI,IAAI,GAAG,WAAW,KAAK,OAAO,MAClC,IAAI,IAAI,GAAG,WAAW,KAAK,SAC3B,OAAO,KAAK;AAClB;AAEA,MAAM,iBAAiB,CAAC,KAAK;IAC3B,MAAM,IAAI,IAAI,KAAK,IAAI,CAAC;IACxB,MAAM,SAAS,IAAI,IAAI,eAAe,CAAC,IAAI,IAAI,EAAE;QAC/C,MAAM,IAAI,IAAI,IAAI;IACpB;IACA,EAAE,IAAI,CAAC;IACP,aAAa,GAAG;AAClB;AAEA,MAAM,aAAa,CAAC,KAAK,OAAO;IAC9B,MAAM,IAAI,IAAI,KAAK;IACnB,MAAM,SAAS,IAAI,IAAI,WAAW,CAAC,IAAI,IAAI,EAAE;QAC3C,MAAM,IAAI,IAAI,IAAI;IACpB;IACA,EAAE,IAAI,CAAC;IAEP,MAAM,UAAU,IAAI,QAAQ,CAAC,KAAK;QAChC,OAAO,EAAE,CAAC,SAAS;QACnB,OAAO,EAAE,CAAC,SAAS;QACnB,EAAE,EAAE,CAAC,SAAS;IAChB;IAEA,cAAc,GAAG;IAEjB,OAAO,KAAK,QAAQ,IAAI,CAAC,IAAI,MAAM;AACrC;AAEA,MAAM,eAAe,CAAC,GAAG;IACvB,MAAM,OAAO,CAAC,CAAA;QACZ,IAAI,KAAK,MAAM,CAAC,OAAO,KAAK;YAC1B,EAAE;gBACA,MAAM,KAAK,OAAO,CAAC,EAAE,GAAG,EAAE,KAAK,KAAK,CAAC;gBACrC,MAAM;gBACN,UAAU;gBACV,SAAS,CAAA,QAAS,EAAE,GAAG,CAAC;YAC1B;QACF,OAAO;YACL,EAAE,GAAG,CAAC;QACR;IACF;IACA,EAAE,GAAG;AACP;AAEA,MAAM,gBAAgB,CAAC,GAAG;IACxB,MAAO,MAAM,MAAM,CAAE;QACnB,MAAM,OAAO,MAAM,KAAK;QACxB,IAAI,KAAK,MAAM,CAAC,OAAO,KAAK;YAC1B,OAAO,EAAE;gBACP,MAAM,KAAK,OAAO,CAAC,EAAE,GAAG,EAAE,KAAK,KAAK,CAAC;gBACrC,UAAU;gBACV,SAAS,CAAA,QAAS,EAAE,GAAG,CAAC;YAC1B,GAAG,IAAI,CAAC,CAAA,IAAK,cAAc,GAAG;QAChC,OAAO;YACL,EAAE,GAAG,CAAC;QACR;IACF;IACA,EAAE,GAAG;AACP;AAEA,MAAM,aAAa,CAAC,KAAK;IACvB,MAAM,IAAI,IAAI,KAAK,IAAI,CAAC;IACxB,aAAa,GAAG;IAChB,OAAO;AACT;AAEA,MAAM,SAAS,CAAC,KAAK;IACnB,MAAM,IAAI,IAAI,KAAK;IACnB,cAAc,GAAG;IACjB,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2513, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/replace.js"],"sourcesContent":["'use strict'\n\n// tar -r\nconst hlo = require('./high-level-opt.js')\nconst Pack = require('./pack.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst t = require('./list.js')\nconst path = require('path')\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst Header = require('./header.js')\n\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file) {\n    throw new TypeError('file is required')\n  }\n\n  if (opt.gzip || opt.brotli || opt.file.endsWith('.br') || opt.file.endsWith('.tbr')) {\n    throw new TypeError('cannot append to compressed archives')\n  }\n\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified')\n  }\n\n  files = Array.from(files)\n\n  return opt.sync ? replaceSync(opt, files)\n    : replace(opt, files, cb)\n}\n\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n\n  let threw = true\n  let fd\n  let position\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+')\n    } catch (er) {\n      if (er.code === 'ENOENT') {\n        fd = fs.openSync(opt.file, 'w+')\n      } else {\n        throw er\n      }\n    }\n\n    const st = fs.fstatSync(fd)\n    const headBuf = Buffer.alloc(512)\n\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(\n          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos\n        )\n\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n          throw new Error('cannot append to compressed archives')\n        }\n\n        if (!bytes) {\n          break POSITION\n        }\n      }\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid) {\n        break\n      }\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > st.size) {\n        break\n      }\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime)\n      }\n    }\n    threw = false\n\n    streamSync(opt, p, position, fd, files)\n  } finally {\n    if (threw) {\n      try {\n        fs.closeSync(fd)\n      } catch (er) {}\n    }\n  }\n}\n\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position,\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst replace = (opt, files, cb) => {\n  files = Array.from(files)\n  const p = new Pack(opt)\n\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er) {\n        fs.close(fd, _ => cb_(er))\n      } else {\n        cb_(null, pos)\n      }\n    }\n\n    let position = 0\n    if (size === 0) {\n      return cb(null, 0)\n    }\n\n    let bufPos = 0\n    const headBuf = Buffer.alloc(512)\n    const onread = (er, bytes) => {\n      if (er) {\n        return cb(er)\n      }\n      bufPos += bytes\n      if (bufPos < 512 && bytes) {\n        return fs.read(\n          fd, headBuf, bufPos, headBuf.length - bufPos,\n          position + bufPos, onread\n        )\n      }\n\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n        return cb(new Error('cannot append to compressed archives'))\n      }\n\n      // truncated header\n      if (bufPos < 512) {\n        return cb(null, position)\n      }\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid) {\n        return cb(null, position)\n      }\n\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > size) {\n        return cb(null, position)\n      }\n\n      position += entryBlockSize + 512\n      if (position >= size) {\n        return cb(null, position)\n      }\n\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime)\n      }\n      bufPos = 0\n      fs.read(fd, headBuf, 0, 512, position, onread)\n    }\n    fs.read(fd, headBuf, 0, 512, position, onread)\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject)\n    let flag = 'r+'\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+'\n        return fs.open(opt.file, flag, onopen)\n      }\n\n      if (er) {\n        return reject(er)\n      }\n\n      fs.fstat(fd, (er, st) => {\n        if (er) {\n          return fs.close(fd, () => reject(er))\n        }\n\n        getPos(fd, st.size, (er, position) => {\n          if (er) {\n            return reject(er)\n          }\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position,\n          })\n          p.pipe(stream)\n          stream.on('error', reject)\n          stream.on('close', resolve)\n          addFilesAsync(p, files)\n        })\n      })\n    }\n    fs.open(opt.file, flag, onopen)\n  })\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry),\n      })\n    } else {\n      p.add(file)\n    }\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        noResume: true,\n        onentry: entry => p.add(entry),\n      }).then(_ => addFilesAsync(p, files))\n    } else {\n      p.add(file)\n    }\n  }\n  p.end()\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2727, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/update.js"],"sourcesContent":["'use strict'\n\n// tar -u\n\nconst hlo = require('./high-level-opt.js')\nconst r = require('./replace.js')\n// just call tar.r with the filter and mtimeCache\n\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file) {\n    throw new TypeError('file is required')\n  }\n\n  if (opt.gzip || opt.brotli || opt.file.endsWith('.br') || opt.file.endsWith('.tbr')) {\n    throw new TypeError('cannot append to compressed archives')\n  }\n\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified')\n  }\n\n  files = Array.from(files)\n\n  mtimeFilter(opt)\n  return r(opt, files, cb)\n}\n\nconst mtimeFilter = opt => {\n  const filter = opt.filter\n\n  if (!opt.mtimeCache) {\n    opt.mtimeCache = new Map()\n  }\n\n  opt.filter = filter ? (path, stat) =>\n    filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime)\n    : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime)\n}\n"],"names":[],"mappings":"AAAA;AAEA,SAAS;AAET,MAAM;AACN,MAAM;AACN,iDAAiD;AAEjD,OAAO,OAAO,GAAG,CAAC,MAAM,OAAO;IAC7B,MAAM,MAAM,IAAI;IAEhB,IAAI,CAAC,IAAI,IAAI,EAAE;QACb,MAAM,IAAI,UAAU;IACtB;IAEA,IAAI,IAAI,IAAI,IAAI,IAAI,MAAM,IAAI,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS;QACnF,MAAM,IAAI,UAAU;IACtB;IAEA,IAAI,CAAC,SAAS,CAAC,MAAM,OAAO,CAAC,UAAU,CAAC,MAAM,MAAM,EAAE;QACpD,MAAM,IAAI,UAAU;IACtB;IAEA,QAAQ,MAAM,IAAI,CAAC;IAEnB,YAAY;IACZ,OAAO,EAAE,KAAK,OAAO;AACvB;AAEA,MAAM,cAAc,CAAA;IAClB,MAAM,SAAS,IAAI,MAAM;IAEzB,IAAI,CAAC,IAAI,UAAU,EAAE;QACnB,IAAI,UAAU,GAAG,IAAI;IACvB;IAEA,IAAI,MAAM,GAAG,SAAS,CAAC,MAAM,OAC3B,OAAO,MAAM,SAAS,CAAC,CAAC,IAAI,UAAU,CAAC,GAAG,CAAC,QAAQ,KAAK,KAAK,IAC3D,CAAC,MAAM,OAAS,CAAC,CAAC,IAAI,UAAU,CAAC,GAAG,CAAC,QAAQ,KAAK,KAAK;AAC7D","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2759, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/mkdir.js"],"sourcesContent":["'use strict'\n// wrapper around mkdirp for tar's needs.\n\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nconst mkdirp = require('mkdirp')\nconst fs = require('fs')\nconst path = require('path')\nconst chownr = require('chownr')\nconst normPath = require('./normalize-windows-path.js')\n\nclass SymlinkError extends Error {\n  constructor (symlink, path) {\n    super('Cannot extract through symbolic link')\n    this.path = path\n    this.symlink = symlink\n  }\n\n  get name () {\n    return 'SylinkError'\n  }\n}\n\nclass CwdError extends Error {\n  constructor (path, code) {\n    super(code + ': Cannot cd into \\'' + path + '\\'')\n    this.path = path\n    this.code = code\n  }\n\n  get name () {\n    return 'CwdError'\n  }\n}\n\nconst cGet = (cache, key) => cache.get(normPath(key))\nconst cSet = (cache, key, val) => cache.set(normPath(key), val)\n\nconst checkCwd = (dir, cb) => {\n  fs.stat(dir, (er, st) => {\n    if (er || !st.isDirectory()) {\n      er = new CwdError(dir, er && er.code || 'ENOTDIR')\n    }\n    cb(er)\n  })\n}\n\nmodule.exports = (dir, opt, cb) => {\n  dir = normPath(dir)\n\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = normPath(opt.cwd)\n\n  const done = (er, created) => {\n    if (er) {\n      cb(er)\n    } else {\n      cSet(cache, dir, true)\n      if (created && doChown) {\n        chownr(created, uid, gid, er => done(er))\n      } else if (needChmod) {\n        fs.chmod(dir, mode, cb)\n      } else {\n        cb()\n      }\n    }\n  }\n\n  if (cache && cGet(cache, dir) === true) {\n    return done()\n  }\n\n  if (dir === cwd) {\n    return checkCwd(dir, done)\n  }\n\n  if (preserve) {\n    return mkdirp(dir, { mode }).then(made => done(null, made), done)\n  }\n\n  const sub = normPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)\n}\n\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n  if (!parts.length) {\n    return cb(null, created)\n  }\n  const p = parts.shift()\n  const part = normPath(path.resolve(base + '/' + p))\n  if (cGet(cache, part)) {\n    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n}\n\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {\n  if (er) {\n    fs.lstat(part, (statEr, st) => {\n      if (statEr) {\n        statEr.path = statEr.path && normPath(statEr.path)\n        cb(statEr)\n      } else if (st.isDirectory()) {\n        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n      } else if (unlink) {\n        fs.unlink(part, er => {\n          if (er) {\n            return cb(er)\n          }\n          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n        })\n      } else if (st.isSymbolicLink()) {\n        return cb(new SymlinkError(part, part + '/' + parts.join('/')))\n      } else {\n        cb(er)\n      }\n    })\n  } else {\n    created = created || part\n    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n}\n\nconst checkCwdSync = dir => {\n  let ok = false\n  let code = 'ENOTDIR'\n  try {\n    ok = fs.statSync(dir).isDirectory()\n  } catch (er) {\n    code = er.code\n  } finally {\n    if (!ok) {\n      throw new CwdError(dir, code)\n    }\n  }\n}\n\nmodule.exports.sync = (dir, opt) => {\n  dir = normPath(dir)\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = normPath(opt.cwd)\n\n  const done = (created) => {\n    cSet(cache, dir, true)\n    if (created && doChown) {\n      chownr.sync(created, uid, gid)\n    }\n    if (needChmod) {\n      fs.chmodSync(dir, mode)\n    }\n  }\n\n  if (cache && cGet(cache, dir) === true) {\n    return done()\n  }\n\n  if (dir === cwd) {\n    checkCwdSync(cwd)\n    return done()\n  }\n\n  if (preserve) {\n    return done(mkdirp.sync(dir, mode))\n  }\n\n  const sub = normPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  let created = null\n  for (let p = parts.shift(), part = cwd;\n    p && (part += '/' + p);\n    p = parts.shift()) {\n    part = normPath(path.resolve(part))\n    if (cGet(cache, part)) {\n      continue\n    }\n\n    try {\n      fs.mkdirSync(part, mode)\n      created = created || part\n      cSet(cache, part, true)\n    } catch (er) {\n      const st = fs.lstatSync(part)\n      if (st.isDirectory()) {\n        cSet(cache, part, true)\n        continue\n      } else if (unlink) {\n        fs.unlinkSync(part)\n        fs.mkdirSync(part, mode)\n        created = created || part\n        cSet(cache, part, true)\n        continue\n      } else if (st.isSymbolicLink()) {\n        return new SymlinkError(part, part + '/' + parts.join('/'))\n      }\n    }\n  }\n\n  return done(created)\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2963, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/normalize-unicode.js"],"sourcesContent":["// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nconst normalizeCache = Object.create(null)\nconst { hasOwnProperty } = Object.prototype\nmodule.exports = s => {\n  if (!hasOwnProperty.call(normalizeCache, s)) {\n    normalizeCache[s] = s.normalize('NFD')\n  }\n  return normalizeCache[s]\n}\n"],"names":[],"mappings":"AAAA,oCAAoC;AACpC,+CAA+C;AAC/C,6CAA6C;AAC7C,4CAA4C;AAC5C,MAAM,iBAAiB,OAAO,MAAM,CAAC;AACrC,MAAM,EAAE,cAAc,EAAE,GAAG,OAAO,SAAS;AAC3C,OAAO,OAAO,GAAG,CAAA;IACf,IAAI,CAAC,eAAe,IAAI,CAAC,gBAAgB,IAAI;QAC3C,cAAc,CAAC,EAAE,GAAG,EAAE,SAAS,CAAC;IAClC;IACA,OAAO,cAAc,CAAC,EAAE;AAC1B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2980, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/path-reservations.js"],"sourcesContent":["// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\n\nconst assert = require('assert')\nconst normalize = require('./normalize-unicode.js')\nconst stripSlashes = require('./strip-trailing-slashes.js')\nconst { join } = require('path')\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\n\nmodule.exports = () => {\n  // path => [function or Set]\n  // A Set object means a directory reservation\n  // A fn is a direct reservation on that path\n  const queues = new Map()\n\n  // fn => {paths:[path,...], dirs:[path, ...]}\n  const reservations = new Map()\n\n  // return a set of parent dirs for a given path\n  // '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']\n  const getDirs = path => {\n    const dirs = path.split('/').slice(0, -1).reduce((set, path) => {\n      if (set.length) {\n        path = join(set[set.length - 1], path)\n      }\n      set.push(path || '/')\n      return set\n    }, [])\n    return dirs\n  }\n\n  // functions currently running\n  const running = new Set()\n\n  // return the queues for each path the function cares about\n  // fn => {paths, dirs}\n  const getQueues = fn => {\n    const res = reservations.get(fn)\n    /* istanbul ignore if - unpossible */\n    if (!res) {\n      throw new Error('function does not have any path reservations')\n    }\n    return {\n      paths: res.paths.map(path => queues.get(path)),\n      dirs: [...res.dirs].map(path => queues.get(path)),\n    }\n  }\n\n  // check if fn is first in line for all its paths, and is\n  // included in the first set for all its dir queues\n  const check = fn => {\n    const { paths, dirs } = getQueues(fn)\n    return paths.every(q => q[0] === fn) &&\n      dirs.every(q => q[0] instanceof Set && q[0].has(fn))\n  }\n\n  // run the function if it's first in line and not already running\n  const run = fn => {\n    if (running.has(fn) || !check(fn)) {\n      return false\n    }\n    running.add(fn)\n    fn(() => clear(fn))\n    return true\n  }\n\n  const clear = fn => {\n    if (!running.has(fn)) {\n      return false\n    }\n\n    const { paths, dirs } = reservations.get(fn)\n    const next = new Set()\n\n    paths.forEach(path => {\n      const q = queues.get(path)\n      assert.equal(q[0], fn)\n      if (q.length === 1) {\n        queues.delete(path)\n      } else {\n        q.shift()\n        if (typeof q[0] === 'function') {\n          next.add(q[0])\n        } else {\n          q[0].forEach(fn => next.add(fn))\n        }\n      }\n    })\n\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      assert(q[0] instanceof Set)\n      if (q[0].size === 1 && q.length === 1) {\n        queues.delete(dir)\n      } else if (q[0].size === 1) {\n        q.shift()\n\n        // must be a function or else the Set would've been reused\n        next.add(q[0])\n      } else {\n        q[0].delete(fn)\n      }\n    })\n    running.delete(fn)\n\n    next.forEach(fn => run(fn))\n    return true\n  }\n\n  const reserve = (paths, fn) => {\n    // collide on matches across case and unicode normalization\n    // On windows, thanks to the magic of 8.3 shortnames, it is fundamentally\n    // impossible to determine whether two paths refer to the same thing on\n    // disk, without asking the kernel for a shortname.\n    // So, we just pretend that every path matches every other path here,\n    // effectively removing all parallelization on windows.\n    paths = isWindows ? ['win32 parallelization disabled'] : paths.map(p => {\n      // don't need normPath, because we skip this entirely for windows\n      return stripSlashes(join(normalize(p))).toLowerCase()\n    })\n\n    const dirs = new Set(\n      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))\n    )\n    reservations.set(fn, { dirs, paths })\n    paths.forEach(path => {\n      const q = queues.get(path)\n      if (!q) {\n        queues.set(path, [fn])\n      } else {\n        q.push(fn)\n      }\n    })\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      if (!q) {\n        queues.set(dir, [new Set([fn])])\n      } else if (q[q.length - 1] instanceof Set) {\n        q[q.length - 1].add(fn)\n      } else {\n        q.push(new Set([fn]))\n      }\n    })\n\n    return run(fn)\n  }\n\n  return { check, reserve }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3137, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/get-write-flag.js"],"sourcesContent":["// Get the appropriate flag to use for creating files\n// We use fmap on Windows platforms for files less than\n// 512kb.  This is a fairly low limit, but avoids making\n// things slower in some cases.  Since most of what this\n// library is used for is extracting tarballs of many\n// relatively small files in npm packages and the like,\n// it can be a big boost on Windows platforms.\n// Only supported in Node v12.9.0 and above.\nconst platform = process.env.__FAKE_PLATFORM__ || process.platform\nconst isWindows = platform === 'win32'\nconst fs = global.__FAKE_TESTING_FS__ || require('fs')\n\n/* istanbul ignore next */\nconst { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs.constants\n\nconst fMapEnabled = isWindows && !!UV_FS_O_FILEMAP\nconst fMapLimit = 512 * 1024\nconst fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY\nmodule.exports = !fMapEnabled ? () => 'w'\n  : size => size < fMapLimit ? fMapFlag : 'w'\n"],"names":[],"mappings":"AAAA,qDAAqD;AACrD,uDAAuD;AACvD,wDAAwD;AACxD,wDAAwD;AACxD,qDAAqD;AACrD,uDAAuD;AACvD,8CAA8C;AAC9C,4CAA4C;AAC3B;AAAjB,MAAM,WAAW,gKAAA,CAAA,UAAO,CAAC,GAAG,CAAC,iBAAiB,IAAI,gKAAA,CAAA,UAAO,CAAC,QAAQ;AAClE,MAAM,YAAY,aAAa;AAC/B,MAAM,KAAK,OAAO,mBAAmB;;;;;AAErC,wBAAwB,GACxB,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,kBAAkB,CAAC,EAAE,GAAG,GAAG,SAAS;AAExE,MAAM,cAAc,aAAa,CAAC,CAAC;AACnC,MAAM,YAAY,MAAM;AACxB,MAAM,WAAW,kBAAkB,UAAU,UAAU;AACvD,OAAO,OAAO,GAAG,CAAC,cAAc,IAAM,MAClC,CAAA,OAAQ,OAAO,YAAY,WAAW","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3163, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/unpack.js"],"sourcesContent":["'use strict'\n\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\nconst assert = require('assert')\nconst Parser = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst mkdir = require('./mkdir.js')\nconst wc = require('./winchars.js')\nconst pathReservations = require('./path-reservations.js')\nconst stripAbsolutePath = require('./strip-absolute-path.js')\nconst normPath = require('./normalize-windows-path.js')\nconst stripSlash = require('./strip-trailing-slashes.js')\nconst normalize = require('./normalize-unicode.js')\n\nconst ONENTRY = Symbol('onEntry')\nconst CHECKFS = Symbol('checkFs')\nconst CHECKFS2 = Symbol('checkFs2')\nconst PRUNECACHE = Symbol('pruneCache')\nconst ISREUSABLE = Symbol('isReusable')\nconst MAKEFS = Symbol('makeFs')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst LINK = Symbol('link')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst UNSUPPORTED = Symbol('unsupported')\nconst CHECKPATH = Symbol('checkPath')\nconst MKDIR = Symbol('mkdir')\nconst ONERROR = Symbol('onError')\nconst PENDING = Symbol('pending')\nconst PEND = Symbol('pend')\nconst UNPEND = Symbol('unpend')\nconst ENDED = Symbol('ended')\nconst MAYBECLOSE = Symbol('maybeClose')\nconst SKIP = Symbol('skip')\nconst DOCHOWN = Symbol('doChown')\nconst UID = Symbol('uid')\nconst GID = Symbol('gid')\nconst CHECKED_CWD = Symbol('checkedCwd')\nconst crypto = require('crypto')\nconst getFlag = require('./get-write-flag.js')\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\nconst DEFAULT_MAX_DEPTH = 1024\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* istanbul ignore next */\nconst unlinkFile = (path, cb) => {\n  if (!isWindows) {\n    return fs.unlink(path, cb)\n  }\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.rename(path, name, er => {\n    if (er) {\n      return cb(er)\n    }\n    fs.unlink(name, cb)\n  })\n}\n\n/* istanbul ignore next */\nconst unlinkFileSync = path => {\n  if (!isWindows) {\n    return fs.unlinkSync(path)\n  }\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.renameSync(path, name)\n  fs.unlinkSync(name)\n}\n\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) =>\n  a === a >>> 0 ? a\n  : b === b >>> 0 ? b\n  : c\n\n// clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\nconst cacheKeyNormalize = path => stripSlash(normPath(normalize(path)))\n  .toLowerCase()\n\nconst pruneCache = (cache, abs) => {\n  abs = cacheKeyNormalize(abs)\n  for (const path of cache.keys()) {\n    const pnorm = cacheKeyNormalize(path)\n    if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) {\n      cache.delete(path)\n    }\n  }\n}\n\nconst dropCache = cache => {\n  for (const key of cache.keys()) {\n    cache.delete(key)\n  }\n}\n\nclass Unpack extends Parser {\n  constructor (opt) {\n    if (!opt) {\n      opt = {}\n    }\n\n    opt.ondone = _ => {\n      this[ENDED] = true\n      this[MAYBECLOSE]()\n    }\n\n    super(opt)\n\n    this[CHECKED_CWD] = false\n\n    this.reservations = pathReservations()\n\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null\n\n    this.writable = true\n    this.readable = false\n\n    this[PENDING] = 0\n    this[ENDED] = false\n\n    this.dirCache = opt.dirCache || new Map()\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') {\n        throw new TypeError('cannot set owner without number uid and gid')\n      }\n      if (opt.preserveOwner) {\n        throw new TypeError(\n          'cannot preserve owner in archive and also set owner explicitly')\n      }\n      this.uid = opt.uid\n      this.gid = opt.gid\n      this.setOwner = true\n    } else {\n      this.uid = null\n      this.gid = null\n      this.setOwner = false\n    }\n\n    // default true for root\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') {\n      this.preserveOwner = process.getuid && process.getuid() === 0\n    } else {\n      this.preserveOwner = !!opt.preserveOwner\n    }\n\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?\n      process.getuid() : null\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?\n      process.getgid() : null\n\n    // prevent excessively deep nesting of subfolders\n    // set to `Infinity` to remove this restriction\n    this.maxDepth = typeof opt.maxDepth === 'number'\n      ? opt.maxDepth\n      : DEFAULT_MAX_DEPTH\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    this.forceChown = opt.forceChown === true\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    this.win32 = !!opt.win32 || isWindows\n\n    // do not unpack over files that are newer than what's in the archive\n    this.newer = !!opt.newer\n\n    // do not unpack over ANY files\n    this.keep = !!opt.keep\n\n    // do not set mtime/atime of extracted entries\n    this.noMtime = !!opt.noMtime\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    this.preservePaths = !!opt.preservePaths\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    this.unlink = !!opt.unlink\n\n    this.cwd = normPath(path.resolve(opt.cwd || process.cwd()))\n    this.strip = +opt.strip || 0\n    // if we're not chmodding, then we don't need the process umask\n    this.processUmask = opt.noChmod ? 0 : process.umask()\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask\n\n    // default mode for dirs created as parents\n    this.dmode = opt.dmode || (0o0777 & (~this.umask))\n    this.fmode = opt.fmode || (0o0666 & (~this.umask))\n\n    this.on('entry', entry => this[ONENTRY](entry))\n  }\n\n  // a bad or damaged archive is a warning for Parser, but an error\n  // when extracting.  Mark those errors as unrecoverable, because\n  // the Unpack contract cannot be met.\n  warn (code, msg, data = {}) {\n    if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {\n      data.recoverable = false\n    }\n    return super.warn(code, msg, data)\n  }\n\n  [MAYBECLOSE] () {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish')\n      this.emit('finish')\n      this.emit('end')\n    }\n  }\n\n  [CHECKPATH] (entry) {\n    const p = normPath(entry.path)\n    const parts = p.split('/')\n\n    if (this.strip) {\n      if (parts.length < this.strip) {\n        return false\n      }\n      if (entry.type === 'Link') {\n        const linkparts = normPath(entry.linkpath).split('/')\n        if (linkparts.length >= this.strip) {\n          entry.linkpath = linkparts.slice(this.strip).join('/')\n        } else {\n          return false\n        }\n      }\n      parts.splice(0, this.strip)\n      entry.path = parts.join('/')\n    }\n\n    if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {\n      this.warn('TAR_ENTRY_ERROR', 'path excessively deep', {\n        entry,\n        path: p,\n        depth: parts.length,\n        maxDepth: this.maxDepth,\n      })\n      return false\n    }\n\n    if (!this.preservePaths) {\n      if (parts.includes('..') || isWindows && /^[a-z]:\\.\\.$/i.test(parts[0])) {\n        this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {\n          entry,\n          path: p,\n        })\n        return false\n      }\n\n      // strip off the root\n      const [root, stripped] = stripAbsolutePath(p)\n      if (root) {\n        entry.path = stripped\n        this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {\n          entry,\n          path: p,\n        })\n      }\n    }\n\n    if (path.isAbsolute(entry.path)) {\n      entry.absolute = normPath(path.resolve(entry.path))\n    } else {\n      entry.absolute = normPath(path.resolve(this.cwd, entry.path))\n    }\n\n    // if we somehow ended up with a path that escapes the cwd, and we are\n    // not in preservePaths mode, then something is fishy!  This should have\n    // been prevented above, so ignore this for coverage.\n    /* istanbul ignore if - defense in depth */\n    if (!this.preservePaths &&\n        entry.absolute.indexOf(this.cwd + '/') !== 0 &&\n        entry.absolute !== this.cwd) {\n      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n        entry,\n        path: normPath(entry.path),\n        resolvedPath: entry.absolute,\n        cwd: this.cwd,\n      })\n      return false\n    }\n\n    // an archive can set properties on the extraction directory, but it\n    // may not replace the cwd with a different kind of thing entirely.\n    if (entry.absolute === this.cwd &&\n        entry.type !== 'Directory' &&\n        entry.type !== 'GNUDumpDir') {\n      return false\n    }\n\n    // only encode : chars that aren't drive letter indicators\n    if (this.win32) {\n      const { root: aRoot } = path.win32.parse(entry.absolute)\n      entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length))\n      const { root: pRoot } = path.win32.parse(entry.path)\n      entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length))\n    }\n\n    return true\n  }\n\n  [ONENTRY] (entry) {\n    if (!this[CHECKPATH](entry)) {\n      return entry.resume()\n    }\n\n    assert.equal(typeof entry.absolute, 'string')\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode) {\n          entry.mode = entry.mode | 0o700\n        }\n\n      // eslint-disable-next-line no-fallthrough\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry)\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n      default:\n        return this[UNSUPPORTED](entry)\n    }\n  }\n\n  [ONERROR] (er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError') {\n      this.emit('error', er)\n    } else {\n      this.warn('TAR_ENTRY_ERROR', er, { entry })\n      this[UNPEND]()\n      entry.resume()\n    }\n  }\n\n  [MKDIR] (dir, mode, cb) {\n    mkdir(normPath(dir), {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode,\n      noChmod: this.noChmod,\n    }, cb)\n  }\n\n  [DOCHOWN] (entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown ||\n      this.preserveOwner &&\n      (typeof entry.uid === 'number' && entry.uid !== this.processUid ||\n        typeof entry.gid === 'number' && entry.gid !== this.processGid)\n      ||\n      (typeof this.uid === 'number' && this.uid !== this.processUid ||\n        typeof this.gid === 'number' && this.gid !== this.processGid)\n  }\n\n  [UID] (entry) {\n    return uint32(this.uid, entry.uid, this.processUid)\n  }\n\n  [GID] (entry) {\n    return uint32(this.gid, entry.gid, this.processGid)\n  }\n\n  [FILE] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.fmode\n    const stream = new fsm.WriteStream(entry.absolute, {\n      flags: getFlag(entry.size),\n      mode: mode,\n      autoClose: false,\n    })\n    stream.on('error', er => {\n      if (stream.fd) {\n        fs.close(stream.fd, () => {})\n      }\n\n      // flush all the data out so that we aren't left hanging\n      // if the error wasn't actually fatal.  otherwise the parse\n      // is blocked, and we never proceed.\n      stream.write = () => true\n      this[ONERROR](er, entry)\n      fullyDone()\n    })\n\n    let actions = 1\n    const done = er => {\n      if (er) {\n        /* istanbul ignore else - we should always have a fd by now */\n        if (stream.fd) {\n          fs.close(stream.fd, () => {})\n        }\n\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      if (--actions === 0) {\n        fs.close(stream.fd, er => {\n          if (er) {\n            this[ONERROR](er, entry)\n          } else {\n            this[UNPEND]()\n          }\n          fullyDone()\n        })\n      }\n    }\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute\n      const fd = stream.fd\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        fs.futimes(fd, atime, mtime, er =>\n          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))\n          : done())\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n        fs.fchown(fd, uid, gid, er =>\n          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))\n          : done())\n      }\n\n      done()\n    })\n\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => {\n        this[ONERROR](er, entry)\n        fullyDone()\n      })\n      entry.pipe(tx)\n    }\n    tx.pipe(stream)\n  }\n\n  [DIRECTORY] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er) {\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      let actions = 1\n      const done = _ => {\n        if (--actions === 0) {\n          fullyDone()\n          this[UNPEND]()\n          entry.resume()\n        }\n      }\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)\n      }\n\n      done()\n    })\n  }\n\n  [UNSUPPORTED] (entry) {\n    entry.unsupported = true\n    this.warn('TAR_ENTRY_UNSUPPORTED',\n      `unsupported entry type: ${entry.type}`, { entry })\n    entry.resume()\n  }\n\n  [SYMLINK] (entry, done) {\n    this[LINK](entry, entry.linkpath, 'symlink', done)\n  }\n\n  [HARDLINK] (entry, done) {\n    const linkpath = normPath(path.resolve(this.cwd, entry.linkpath))\n    this[LINK](entry, linkpath, 'link', done)\n  }\n\n  [PEND] () {\n    this[PENDING]++\n  }\n\n  [UNPEND] () {\n    this[PENDING]--\n    this[MAYBECLOSE]()\n  }\n\n  [SKIP] (entry) {\n    this[UNPEND]()\n    entry.resume()\n  }\n\n  // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n  [ISREUSABLE] (entry, st) {\n    return entry.type === 'File' &&\n      !this.unlink &&\n      st.isFile() &&\n      st.nlink <= 1 &&\n      !isWindows\n  }\n\n  // check if a thing is there, and if so, try to clobber it\n  [CHECKFS] (entry) {\n    this[PEND]()\n    const paths = [entry.path]\n    if (entry.linkpath) {\n      paths.push(entry.linkpath)\n    }\n    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done))\n  }\n\n  [PRUNECACHE] (entry) {\n    // if we are not creating a directory, and the path is in the dirCache,\n    // then that means we are about to delete the directory we created\n    // previously, and it is no longer going to be a directory, and neither\n    // is any of its children.\n    // If a symbolic link is encountered, all bets are off.  There is no\n    // reasonable way to sanitize the cache in such a way we will be able to\n    // avoid having filesystem collisions.  If this happens with a non-symlink\n    // entry, it'll just fail to unpack, but a symlink to a directory, using an\n    // 8.3 shortname or certain unicode attacks, can evade detection and lead\n    // to arbitrary writes to anywhere on the system.\n    if (entry.type === 'SymbolicLink') {\n      dropCache(this.dirCache)\n    } else if (entry.type !== 'Directory') {\n      pruneCache(this.dirCache, entry.absolute)\n    }\n  }\n\n  [CHECKFS2] (entry, fullyDone) {\n    this[PRUNECACHE](entry)\n\n    const done = er => {\n      this[PRUNECACHE](entry)\n      fullyDone(er)\n    }\n\n    const checkCwd = () => {\n      this[MKDIR](this.cwd, this.dmode, er => {\n        if (er) {\n          this[ONERROR](er, entry)\n          done()\n          return\n        }\n        this[CHECKED_CWD] = true\n        start()\n      })\n    }\n\n    const start = () => {\n      if (entry.absolute !== this.cwd) {\n        const parent = normPath(path.dirname(entry.absolute))\n        if (parent !== this.cwd) {\n          return this[MKDIR](parent, this.dmode, er => {\n            if (er) {\n              this[ONERROR](er, entry)\n              done()\n              return\n            }\n            afterMakeParent()\n          })\n        }\n      }\n      afterMakeParent()\n    }\n\n    const afterMakeParent = () => {\n      fs.lstat(entry.absolute, (lstatEr, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n          this[SKIP](entry)\n          done()\n          return\n        }\n        if (lstatEr || this[ISREUSABLE](entry, st)) {\n          return this[MAKEFS](null, entry, done)\n        }\n\n        if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            const needChmod = !this.noChmod &&\n              entry.mode &&\n              (st.mode & 0o7777) !== entry.mode\n            const afterChmod = er => this[MAKEFS](er, entry, done)\n            if (!needChmod) {\n              return afterChmod()\n            }\n            return fs.chmod(entry.absolute, entry.mode, afterChmod)\n          }\n          // Not a dir entry, have to remove it.\n          // NB: the only way to end up with an entry that is the cwd\n          // itself, in such a way that == does not detect, is a\n          // tricky windows absolute path with UNC or 8.3 parts (and\n          // preservePaths:true, or else it will have been stripped).\n          // In that case, the user has opted out of path protections\n          // explicitly, so if they blow away the cwd, c'est la vie.\n          if (entry.absolute !== this.cwd) {\n            return fs.rmdir(entry.absolute, er =>\n              this[MAKEFS](er, entry, done))\n          }\n        }\n\n        // not a dir, and not reusable\n        // don't remove if the cwd, we want that error\n        if (entry.absolute === this.cwd) {\n          return this[MAKEFS](null, entry, done)\n        }\n\n        unlinkFile(entry.absolute, er =>\n          this[MAKEFS](er, entry, done))\n      })\n    }\n\n    if (this[CHECKED_CWD]) {\n      start()\n    } else {\n      checkCwd()\n    }\n  }\n\n  [MAKEFS] (er, entry, done) {\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry, done)\n\n      case 'Link':\n        return this[HARDLINK](entry, done)\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry, done)\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry, done)\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    // XXX: get the type ('symlink' or 'junction') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er) {\n        this[ONERROR](er, entry)\n      } else {\n        this[UNPEND]()\n        entry.resume()\n      }\n      done()\n    })\n  }\n}\n\nconst callSync = fn => {\n  try {\n    return [null, fn()]\n  } catch (er) {\n    return [er, null]\n  }\n}\nclass UnpackSync extends Unpack {\n  [MAKEFS] (er, entry) {\n    return super[MAKEFS](er, entry, () => {})\n  }\n\n  [CHECKFS] (entry) {\n    this[PRUNECACHE](entry)\n\n    if (!this[CHECKED_CWD]) {\n      const er = this[MKDIR](this.cwd, this.dmode)\n      if (er) {\n        return this[ONERROR](er, entry)\n      }\n      this[CHECKED_CWD] = true\n    }\n\n    // don't bother to make the parent if the current entry is the cwd,\n    // we've already checked it.\n    if (entry.absolute !== this.cwd) {\n      const parent = normPath(path.dirname(entry.absolute))\n      if (parent !== this.cwd) {\n        const mkParent = this[MKDIR](parent, this.dmode)\n        if (mkParent) {\n          return this[ONERROR](mkParent, entry)\n        }\n      }\n    }\n\n    const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute))\n    if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n      return this[SKIP](entry)\n    }\n\n    if (lstatEr || this[ISREUSABLE](entry, st)) {\n      return this[MAKEFS](null, entry)\n    }\n\n    if (st.isDirectory()) {\n      if (entry.type === 'Directory') {\n        const needChmod = !this.noChmod &&\n          entry.mode &&\n          (st.mode & 0o7777) !== entry.mode\n        const [er] = needChmod ? callSync(() => {\n          fs.chmodSync(entry.absolute, entry.mode)\n        }) : []\n        return this[MAKEFS](er, entry)\n      }\n      // not a dir entry, have to remove it\n      const [er] = callSync(() => fs.rmdirSync(entry.absolute))\n      this[MAKEFS](er, entry)\n    }\n\n    // not a dir, and not reusable.\n    // don't remove if it's the cwd, since we want that error.\n    const [er] = entry.absolute === this.cwd ? []\n      : callSync(() => unlinkFileSync(entry.absolute))\n    this[MAKEFS](er, entry)\n  }\n\n  [FILE] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.fmode\n\n    const oner = er => {\n      let closeError\n      try {\n        fs.closeSync(fd)\n      } catch (e) {\n        closeError = e\n      }\n      if (er || closeError) {\n        this[ONERROR](er || closeError, entry)\n      }\n      done()\n    }\n\n    let fd\n    try {\n      fd = fs.openSync(entry.absolute, getFlag(entry.size), mode)\n    } catch (er) {\n      return oner(er)\n    }\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length)\n      } catch (er) {\n        oner(er)\n      }\n    })\n\n    tx.on('end', _ => {\n      let er = null\n      // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        try {\n          fs.futimesSync(fd, atime, mtime)\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime)\n          } catch (utimeser) {\n            er = futimeser\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n\n        try {\n          fs.fchownSync(fd, uid, gid)\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid)\n          } catch (chowner) {\n            er = er || fchowner\n          }\n        }\n      }\n\n      oner(er)\n    })\n  }\n\n  [DIRECTORY] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    const er = this[MKDIR](entry.absolute, mode)\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)\n      } catch (er) {}\n    }\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))\n      } catch (er) {}\n    }\n    done()\n    entry.resume()\n  }\n\n  [MKDIR] (dir, mode) {\n    try {\n      return mkdir.sync(normPath(dir), {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode,\n      })\n    } catch (er) {\n      return er\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute)\n      done()\n      entry.resume()\n    } catch (er) {\n      return this[ONERROR](er, entry)\n    }\n  }\n}\n\nUnpack.Sync = UnpackSync\nmodule.exports = Unpack\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3954, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/lib/extract.js"],"sourcesContent":["'use strict'\n\n// tar -x\nconst hlo = require('./high-level-opt.js')\nconst Unpack = require('./unpack.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst stripSlash = require('./strip-trailing-slashes.js')\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function') {\n    cb = opt_, files = null, opt_ = {}\n  } else if (Array.isArray(opt_)) {\n    files = opt_, opt_ = {}\n  }\n\n  if (typeof files === 'function') {\n    cb = files, files = null\n  }\n\n  if (!files) {\n    files = []\n  } else {\n    files = Array.from(files)\n  }\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function') {\n    throw new TypeError('callback not supported for sync tar functions')\n  }\n\n  if (!opt.file && typeof cb === 'function') {\n    throw new TypeError('callback only supported with file option')\n  }\n\n  if (files.length) {\n    filesFilter(opt, files)\n  }\n\n  return opt.file && opt.sync ? extractFileSync(opt)\n    : opt.file ? extractFile(opt, cb)\n    : opt.sync ? extractSync(opt)\n    : extract(opt)\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [stripSlash(f), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))\n    : file => mapHas(stripSlash(file))\n}\n\nconst extractFileSync = opt => {\n  const u = new Unpack.Sync(opt)\n\n  const file = opt.file\n  const stat = fs.statSync(file)\n  // This trades a zero-byte read() syscall for a stat\n  // However, it will usually result in less memory allocation\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n  const stream = new fsm.ReadStreamSync(file, {\n    readSize: readSize,\n    size: stat.size,\n  })\n  stream.pipe(u)\n}\n\nconst extractFile = (opt, cb) => {\n  const u = new Unpack(opt)\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    u.on('error', reject)\n    u.on('close', resolve)\n\n    // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n    fs.stat(file, (er, stat) => {\n      if (er) {\n        reject(er)\n      } else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size,\n        })\n        stream.on('error', reject)\n        stream.pipe(u)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst extractSync = opt => new Unpack.Sync(opt)\n\nconst extract = opt => new Unpack(opt)\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4052, "column": 0}, "map": {"version":3,"sources":["file:///Users/narendrakumar/Documents/Session_02_Final/node_modules/tar/index.js"],"sourcesContent":["'use strict'\n\n// high-level commands\nexports.c = exports.create = require('./lib/create.js')\nexports.r = exports.replace = require('./lib/replace.js')\nexports.t = exports.list = require('./lib/list.js')\nexports.u = exports.update = require('./lib/update.js')\nexports.x = exports.extract = require('./lib/extract.js')\n\n// classes\nexports.Pack = require('./lib/pack.js')\nexports.Unpack = require('./lib/unpack.js')\nexports.Parse = require('./lib/parse.js')\nexports.ReadEntry = require('./lib/read-entry.js')\nexports.WriteEntry = require('./lib/write-entry.js')\nexports.Header = require('./lib/header.js')\nexports.Pax = require('./lib/pax.js')\nexports.types = require('./lib/types.js')\n"],"names":[],"mappings":"AAAA;AAEA,sBAAsB;AACtB,QAAQ,CAAC,GAAG,QAAQ,MAAM;AAC1B,QAAQ,CAAC,GAAG,QAAQ,OAAO;AAC3B,QAAQ,CAAC,GAAG,QAAQ,IAAI;AACxB,QAAQ,CAAC,GAAG,QAAQ,MAAM;AAC1B,QAAQ,CAAC,GAAG,QAAQ,OAAO;AAE3B,UAAU;AACV,QAAQ,IAAI;AACZ,QAAQ,MAAM;AACd,QAAQ,KAAK;AACb,QAAQ,SAAS;AACjB,QAAQ,UAAU;AAClB,QAAQ,MAAM;AACd,QAAQ,GAAG;AACX,QAAQ,KAAK","ignoreList":[0],"debugId":null}}]
}