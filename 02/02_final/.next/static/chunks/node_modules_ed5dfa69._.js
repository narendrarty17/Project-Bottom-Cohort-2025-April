(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push(["static/chunks/node_modules_ed5dfa69._.js", {

"[project]/node_modules/util/support/isBufferBrowser.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = function isBuffer(arg) {
    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};
}}),
"[project]/node_modules/util/util.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
    if (!isString(f)) {
        var objects = [];
        for(var i = 0; i < arguments.length; i++){
            objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
    }
    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%') return '%';
        if (i >= len) return x;
        switch(x){
            case '%s':
                return String(args[i++]);
            case '%d':
                return Number(args[i++]);
            case '%j':
                try {
                    return JSON.stringify(args[i++]);
                } catch (_) {
                    return '[Circular]';
                }
            default:
                return x;
        }
    });
    for(var x = args[i]; i < len; x = args[++i]){
        if (isNull(x) || !isObject(x)) {
            str += ' ' + x;
        } else {
            str += ' ' + inspect(x);
        }
    }
    return str;
};
// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
    // Allow for deprecating things in the process of starting up.
    if (isUndefined(global.process)) {
        return function() {
            return exports.deprecate(fn, msg).apply(this, arguments);
        };
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].noDeprecation === true) {
        return fn;
    }
    var warned = false;
    function deprecated() {
        if (!warned) {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].throwDeprecation) {
                throw new Error(msg);
            } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].traceDeprecation) {
                console.trace(msg);
            } else {
                console.error(msg);
            }
            warned = true;
        }
        return fn.apply(this, arguments);
    }
    return deprecated;
};
var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
    if (isUndefined(debugEnviron)) debugEnviron = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.NODE_DEBUG || '';
    set = set.toUpperCase();
    if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
            var pid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].pid;
            debugs[set] = function() {
                var msg = exports.format.apply(exports, arguments);
                console.error('%s %d: %s', set, pid, msg);
            };
        } else {
            debugs[set] = function() {};
        }
    }
    return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) {
    // default options
    var ctx = {
        seen: [],
        stylize: stylizeNoColor
    };
    // legacy...
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];
    if (isBoolean(opts)) {
        // legacy...
        ctx.showHidden = opts;
    } else if (opts) {
        // got an "options" object
        exports._extend(ctx, opts);
    }
    // set default options
    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;
// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
    'bold': [
        1,
        22
    ],
    'italic': [
        3,
        23
    ],
    'underline': [
        4,
        24
    ],
    'inverse': [
        7,
        27
    ],
    'white': [
        37,
        39
    ],
    'grey': [
        90,
        39
    ],
    'black': [
        30,
        39
    ],
    'blue': [
        34,
        39
    ],
    'cyan': [
        36,
        39
    ],
    'green': [
        32,
        39
    ],
    'magenta': [
        35,
        39
    ],
    'red': [
        31,
        39
    ],
    'yellow': [
        33,
        39
    ]
};
// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    // "name": intentionally not styling
    'regexp': 'red'
};
function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];
    if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
    } else {
        return str;
    }
}
function stylizeNoColor(str, styleType) {
    return str;
}
function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
        hash[val] = true;
    });
    return hash;
}
function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
    }
    // Primitive types cannot have properties
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
        return primitive;
    }
    // Look up the keys of the object.
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);
    if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
    }
    // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
    }
    // Some type of object without properties can be shortcutted.
    if (keys.length === 0) {
        if (isFunction(value)) {
            var name = value.name ? ': ' + value.name : '';
            return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
            return formatError(value);
        }
    }
    var base = '', array = false, braces = [
        '{',
        '}'
    ];
    // Make Array say that they are Array
    if (isArray(value)) {
        array = true;
        braces = [
            '[',
            ']'
        ];
    }
    // Make functions say that they are functions
    if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
    }
    // Make RegExps say that they are RegExps
    if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
    }
    // Make dates with properties first say the date
    if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
    }
    // Make error with message first say the error
    if (isError(value)) {
        base = ' ' + formatError(value);
    }
    if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
    }
    if (recurseTimes < 0) {
        if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
            return ctx.stylize('[Object]', 'special');
        }
    }
    ctx.seen.push(value);
    var output;
    if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
        output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
    }
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
    if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
    }
    if (isNumber(value)) return ctx.stylize('' + value, 'number');
    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
    // For some reason typeof null is "object", so special case here.
    if (isNull(value)) return ctx.stylize('null', 'null');
}
function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for(var i = 0, l = value.length; i < l; ++i){
        if (hasOwnProperty(value, String(i))) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
            output.push('');
        }
    }
    keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
    });
    return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
    };
    if (desc.get) {
        if (desc.set) {
            str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
            str = ctx.stylize('[Getter]', 'special');
        }
    } else {
        if (desc.set) {
            str = ctx.stylize('[Setter]', 'special');
        }
    }
    if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
    }
    if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
                str = formatValue(ctx, desc.value, null);
            } else {
                str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf('\n') > -1) {
                if (array) {
                    str = str.split('\n').map(function(line) {
                        return '  ' + line;
                    }).join('\n').substr(2);
                } else {
                    str = '\n' + str.split('\n').map(function(line) {
                        return '   ' + line;
                    }).join('\n');
                }
            }
        } else {
            str = ctx.stylize('[Circular]', 'special');
        }
    }
    if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
            return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, 'name');
        } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, 'string');
        }
    }
    return name + ': ' + str;
}
function reduceToSingleString(output, base, braces) {
    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);
    if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
    }
    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
    return Array.isArray(ar);
}
exports.isArray = isArray;
function isBoolean(arg) {
    return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;
function isNull(arg) {
    return arg === null;
}
exports.isNull = isNull;
function isNullOrUndefined(arg) {
    return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {
    return typeof arg === 'number';
}
exports.isNumber = isNumber;
function isString(arg) {
    return typeof arg === 'string';
}
exports.isString = isString;
function isSymbol(arg) {
    return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;
function isUndefined(arg) {
    return arg === void 0;
}
exports.isUndefined = isUndefined;
function isRegExp(re) {
    return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;
function isDate(d) {
    return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
function isError(e) {
    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
function isFunction(arg) {
    return typeof arg === 'function';
}
exports.isFunction = isFunction;
function isPrimitive(arg) {
    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
    typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;
exports.isBuffer = __turbopack_context__.r("[project]/node_modules/util/support/isBufferBrowser.js [app-client] (ecmascript)");
function objectToString(o) {
    return Object.prototype.toString.call(o);
}
function pad(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
}
var months = [
    'Jan',
    'Feb',
    'Mar',
    'Apr',
    'May',
    'Jun',
    'Jul',
    'Aug',
    'Sep',
    'Oct',
    'Nov',
    'Dec'
];
// 26 Feb 16:19:34
function timestamp() {
    var d = new Date();
    var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
    ].join(':');
    return [
        d.getDate(),
        months[d.getMonth()],
        time
    ].join(' ');
}
// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
    console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */ exports.inherits = __turbopack_context__.r("[project]/node_modules/util/node_modules/inherits/inherits_browser.js [app-client] (ecmascript)");
exports._extend = function(origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !isObject(add)) return origin;
    var keys = Object.keys(add);
    var i = keys.length;
    while(i--){
        origin[keys[i]] = add[keys[i]];
    }
    return origin;
};
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
}}),
"[project]/node_modules/util/node_modules/inherits/inherits_browser.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    };
} else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    };
}
}}),
"[project]/node_modules/inherits/inherits_browser.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        }
    };
} else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
        }
    };
}
}}),
"[project]/node_modules/path/path.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
var isWindows = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform === 'win32';
var util = __turbopack_context__.r("[project]/node_modules/util/util.js [app-client] (ecmascript)");
// resolves . and .. elements in a path array with directory names there
// must be no slashes or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
    var res = [];
    for(var i = 0; i < parts.length; i++){
        var p = parts[i];
        // ignore empty parts
        if (!p || p === '.') continue;
        if (p === '..') {
            if (res.length && res[res.length - 1] !== '..') {
                res.pop();
            } else if (allowAboveRoot) {
                res.push('..');
            }
        } else {
            res.push(p);
        }
    }
    return res;
}
// returns an array with empty elements removed from either end of the input
// array or the original array if no elements need to be removed
function trimArray(arr) {
    var lastIndex = arr.length - 1;
    var start = 0;
    for(; start <= lastIndex; start++){
        if (arr[start]) break;
    }
    var end = lastIndex;
    for(; end >= 0; end--){
        if (arr[end]) break;
    }
    if (start === 0 && end === lastIndex) return arr;
    if (start > end) return [];
    return arr.slice(start, end + 1);
}
// Regex to split a windows path into three parts: [*, device, slash,
// tail] windows-only
var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
// Regex to split the tail part of the above into [*, dir, basename, ext]
var splitTailRe = /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;
var win32 = {};
// Function to split a filename into [root, dir, basename, ext]
function win32SplitPath(filename) {
    // Separate device+slash from tail
    var result = splitDeviceRe.exec(filename), device = (result[1] || '') + (result[2] || ''), tail = result[3] || '';
    // Split the tail into dir, basename and extension
    var result2 = splitTailRe.exec(tail), dir = result2[1], basename = result2[2], ext = result2[3];
    return [
        device,
        dir,
        basename,
        ext
    ];
}
function win32StatPath(path) {
    var result = splitDeviceRe.exec(path), device = result[1] || '', isUnc = !!device && device[1] !== ':';
    return {
        device: device,
        isUnc: isUnc,
        isAbsolute: isUnc || !!result[2],
        tail: result[3]
    };
}
function normalizeUNCRoot(device) {
    return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
}
// path.resolve([from ...], to)
win32.resolve = function() {
    var resolvedDevice = '', resolvedTail = '', resolvedAbsolute = false;
    for(var i = arguments.length - 1; i >= -1; i--){
        var path;
        if (i >= 0) {
            path = arguments[i];
        } else if (!resolvedDevice) {
            path = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cwd();
        } else {
            // Windows has the concept of drive-specific current working
            // directories. If we've resolved a drive letter but not yet an
            // absolute path, get cwd for that drive. We're sure the device is not
            // an unc path at this points, because unc paths are always absolute.
            path = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env['=' + resolvedDevice];
            // Verify that a drive-local cwd was found and that it actually points
            // to our drive. If not, default to the drive's root.
            if (!path || path.substr(0, 3).toLowerCase() !== resolvedDevice.toLowerCase() + '\\') {
                path = resolvedDevice + '\\';
            }
        }
        // Skip empty and invalid entries
        if (!util.isString(path)) {
            throw new TypeError('Arguments to path.resolve must be strings');
        } else if (!path) {
            continue;
        }
        var result = win32StatPath(path), device = result.device, isUnc = result.isUnc, isAbsolute = result.isAbsolute, tail = result.tail;
        if (device && resolvedDevice && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (!resolvedDevice) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = tail + '\\' + resolvedTail;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedDevice && resolvedAbsolute) {
            break;
        }
    }
    // Convert slashes to backslashes when `resolvedDevice` points to an UNC
    // root. Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
        resolvedDevice = normalizeUNCRoot(resolvedDevice);
    }
    // At this point the path should be resolved to a full absolute path,
    // but handle relative paths to be safe (might happen when process.cwd()
    // fails)
    // Normalize the tail path
    resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/), !resolvedAbsolute).join('\\');
    return resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail || '.';
};
win32.normalize = function(path) {
    var result = win32StatPath(path), device = result.device, isUnc = result.isUnc, isAbsolute = result.isAbsolute, tail = result.tail, trailingSlash = /[\\\/]$/.test(tail);
    // Normalize the tail path
    tail = normalizeArray(tail.split(/[\\\/]+/), !isAbsolute).join('\\');
    if (!tail && !isAbsolute) {
        tail = '.';
    }
    if (tail && trailingSlash) {
        tail += '\\';
    }
    // Convert slashes to backslashes when `device` points to an UNC root.
    // Also squash multiple slashes into a single one where appropriate.
    if (isUnc) {
        device = normalizeUNCRoot(device);
    }
    return device + (isAbsolute ? '\\' : '') + tail;
};
win32.isAbsolute = function(path) {
    return win32StatPath(path).isAbsolute;
};
win32.join = function() {
    var paths = [];
    for(var i = 0; i < arguments.length; i++){
        var arg = arguments[i];
        if (!util.isString(arg)) {
            throw new TypeError('Arguments to path.join must be strings');
        }
        if (arg) {
            paths.push(arg);
        }
    }
    var joined = paths.join('\\');
    // Make sure that the joined path doesn't start with two slashes, because
    // normalize() will mistake it for an UNC path then.
    //
    // This step is skipped when it is very clear that the user actually
    // intended to point at an UNC path. This is assumed when the first
    // non-empty string arguments starts with exactly two slashes followed by
    // at least one more non-slash character.
    //
    // Note that for normalize() to treat a path as an UNC path it needs to
    // have at least 2 components, so we don't filter for that here.
    // This means that the user can use join to construct UNC paths from
    // a server name and a share name; for example:
    //   path.join('//server', 'share') -> '\\\\server\\share\')
    if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
        joined = joined.replace(/^[\\\/]{2,}/, '\\');
    }
    return win32.normalize(joined);
};
// path.relative(from, to)
// it will solve the relative path from 'from' to 'to', for instance:
// from = 'C:\\orandea\\test\\aaa'
// to = 'C:\\orandea\\impl\\bbb'
// The output of the function should be: '..\\..\\impl\\bbb'
win32.relative = function(from, to) {
    from = win32.resolve(from);
    to = win32.resolve(to);
    // windows is not case sensitive
    var lowerFrom = from.toLowerCase();
    var lowerTo = to.toLowerCase();
    var toParts = trimArray(to.split('\\'));
    var lowerFromParts = trimArray(lowerFrom.split('\\'));
    var lowerToParts = trimArray(lowerTo.split('\\'));
    var length = Math.min(lowerFromParts.length, lowerToParts.length);
    var samePartsLength = length;
    for(var i = 0; i < length; i++){
        if (lowerFromParts[i] !== lowerToParts[i]) {
            samePartsLength = i;
            break;
        }
    }
    if (samePartsLength == 0) {
        return to;
    }
    var outputParts = [];
    for(var i = samePartsLength; i < lowerFromParts.length; i++){
        outputParts.push('..');
    }
    outputParts = outputParts.concat(toParts.slice(samePartsLength));
    return outputParts.join('\\');
};
win32._makeLong = function(path) {
    // Note: this will *probably* throw somewhere.
    if (!util.isString(path)) return path;
    if (!path) {
        return '';
    }
    var resolvedPath = win32.resolve(path);
    if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
        // path is local filesystem path, which needs to be converted
        // to long UNC path.
        return '\\\\?\\' + resolvedPath;
    } else if (/^\\\\[^?.]/.test(resolvedPath)) {
        // path is network UNC path, which needs to be converted
        // to long UNC path.
        return '\\\\?\\UNC\\' + resolvedPath.substring(2);
    }
    return path;
};
win32.dirname = function(path) {
    var result = win32SplitPath(path), root = result[0], dir = result[1];
    if (!root && !dir) {
        // No dirname whatsoever
        return '.';
    }
    if (dir) {
        // It has a dirname, strip trailing slash
        dir = dir.substr(0, dir.length - 1);
    }
    return root + dir;
};
win32.basename = function(path, ext) {
    var f = win32SplitPath(path)[2];
    // TODO: make this comparison case-insensitive on windows?
    if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
    }
    return f;
};
win32.extname = function(path) {
    return win32SplitPath(path)[3];
};
win32.format = function(pathObject) {
    if (!util.isObject(pathObject)) {
        throw new TypeError("Parameter 'pathObject' must be an object, not " + typeof pathObject);
    }
    var root = pathObject.root || '';
    if (!util.isString(root)) {
        throw new TypeError("'pathObject.root' must be a string or undefined, not " + typeof pathObject.root);
    }
    var dir = pathObject.dir;
    var base = pathObject.base || '';
    if (!dir) {
        return base;
    }
    if (dir[dir.length - 1] === win32.sep) {
        return dir + base;
    }
    return dir + win32.sep + base;
};
win32.parse = function(pathString) {
    if (!util.isString(pathString)) {
        throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = win32SplitPath(pathString);
    if (!allParts || allParts.length !== 4) {
        throw new TypeError("Invalid path '" + pathString + "'");
    }
    return {
        root: allParts[0],
        dir: allParts[0] + allParts[1].slice(0, -1),
        base: allParts[2],
        ext: allParts[3],
        name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
    };
};
win32.sep = '\\';
win32.delimiter = ';';
// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var posix = {};
function posixSplitPath(filename) {
    return splitPathRe.exec(filename).slice(1);
}
// path.resolve([from ...], to)
// posix version
posix.resolve = function() {
    var resolvedPath = '', resolvedAbsolute = false;
    for(var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        var path = i >= 0 ? arguments[i] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cwd();
        // Skip empty and invalid entries
        if (!util.isString(path)) {
            throw new TypeError('Arguments to path.resolve must be strings');
        } else if (!path) {
            continue;
        }
        resolvedPath = path + '/' + resolvedPath;
        resolvedAbsolute = path[0] === '/';
    }
    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)
    // Normalize the path
    resolvedPath = normalizeArray(resolvedPath.split('/'), !resolvedAbsolute).join('/');
    return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
};
// path.normalize(path)
// posix version
posix.normalize = function(path) {
    var isAbsolute = posix.isAbsolute(path), trailingSlash = path && path[path.length - 1] === '/';
    // Normalize the path
    path = normalizeArray(path.split('/'), !isAbsolute).join('/');
    if (!path && !isAbsolute) {
        path = '.';
    }
    if (path && trailingSlash) {
        path += '/';
    }
    return (isAbsolute ? '/' : '') + path;
};
// posix version
posix.isAbsolute = function(path) {
    return path.charAt(0) === '/';
};
// posix version
posix.join = function() {
    var path = '';
    for(var i = 0; i < arguments.length; i++){
        var segment = arguments[i];
        if (!util.isString(segment)) {
            throw new TypeError('Arguments to path.join must be strings');
        }
        if (segment) {
            if (!path) {
                path += segment;
            } else {
                path += '/' + segment;
            }
        }
    }
    return posix.normalize(path);
};
// path.relative(from, to)
// posix version
posix.relative = function(from, to) {
    from = posix.resolve(from).substr(1);
    to = posix.resolve(to).substr(1);
    var fromParts = trimArray(from.split('/'));
    var toParts = trimArray(to.split('/'));
    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;
    for(var i = 0; i < length; i++){
        if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
        }
    }
    var outputParts = [];
    for(var i = samePartsLength; i < fromParts.length; i++){
        outputParts.push('..');
    }
    outputParts = outputParts.concat(toParts.slice(samePartsLength));
    return outputParts.join('/');
};
posix._makeLong = function(path) {
    return path;
};
posix.dirname = function(path) {
    var result = posixSplitPath(path), root = result[0], dir = result[1];
    if (!root && !dir) {
        // No dirname whatsoever
        return '.';
    }
    if (dir) {
        // It has a dirname, strip trailing slash
        dir = dir.substr(0, dir.length - 1);
    }
    return root + dir;
};
posix.basename = function(path, ext) {
    var f = posixSplitPath(path)[2];
    // TODO: make this comparison case-insensitive on windows?
    if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
    }
    return f;
};
posix.extname = function(path) {
    return posixSplitPath(path)[3];
};
posix.format = function(pathObject) {
    if (!util.isObject(pathObject)) {
        throw new TypeError("Parameter 'pathObject' must be an object, not " + typeof pathObject);
    }
    var root = pathObject.root || '';
    if (!util.isString(root)) {
        throw new TypeError("'pathObject.root' must be a string or undefined, not " + typeof pathObject.root);
    }
    var dir = pathObject.dir ? pathObject.dir + posix.sep : '';
    var base = pathObject.base || '';
    return dir + base;
};
posix.parse = function(pathString) {
    if (!util.isString(pathString)) {
        throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
    }
    var allParts = posixSplitPath(pathString);
    if (!allParts || allParts.length !== 4) {
        throw new TypeError("Invalid path '" + pathString + "'");
    }
    allParts[1] = allParts[1] || '';
    allParts[2] = allParts[2] || '';
    allParts[3] = allParts[3] || '';
    return {
        root: allParts[0],
        dir: allParts[0] + allParts[1].slice(0, -1),
        base: allParts[2],
        ext: allParts[3],
        name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
    };
};
posix.sep = '/';
posix.delimiter = ':';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else /* posix */ module.exports = posix;
module.exports.posix = posix;
module.exports.win32 = win32;
}}),
"[project]/node_modules/fs.realpath/old.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var pathModule = __turbopack_context__.r("[project]/node_modules/path/path.js [app-client] (ecmascript)");
var isWindows = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform === 'win32';
var fs = (()=>{
    const e = new Error("Cannot find module 'fs'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
// JavaScript implementation of realpath, ported from node pre-v6
var DEBUG = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.NODE_DEBUG && /fs/.test(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.NODE_DEBUG);
function rethrow() {
    // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
    // is fairly slow to generate.
    var callback;
    if (DEBUG) {
        var backtrace = new Error;
        callback = debugCallback;
    } else callback = missingCallback;
    return callback;
    "TURBOPACK unreachable";
    function debugCallback(err) {
        if (err) {
            backtrace.message = err.message;
            err = backtrace;
            missingCallback(err);
        }
    }
    function missingCallback(err) {
        if (err) {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].throwDeprecation) throw err; // Forgot a callback but don't know where? Use NODE_DEBUG=fs
            else if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].noDeprecation) {
                var msg = 'fs: missing callback ' + (err.stack || err.message);
                if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].traceDeprecation) console.trace(msg);
                else console.error(msg);
            }
        }
    }
}
function maybeCallback(cb) {
    return typeof cb === 'function' ? cb : rethrow();
}
var normalize = pathModule.normalize;
// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
if (isWindows) {
    var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
    var nextPartRe = /(.*?)(?:[\/]+|$)/g;
}
// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
if (isWindows) {
    var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
    var splitRootRe = /^[\/]*/;
}
exports.realpathSync = function realpathSync(p, cache) {
    // make p is absolute
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
    }
    var original = p, seenLinks = {}, knownHard = {};
    // current character position in p
    var pos;
    // the partial path so far, including a trailing slash if any
    var current;
    // the partial path without a trailing slash (except when pointing at a root)
    var base;
    // the partial path scanned in the previous round, with slash
    var previous;
    start();
    function start() {
        // Skip over roots
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = '';
        // On windows, check that the root exists. On unix there is no need.
        if ("TURBOPACK compile-time falsy", 0) {
            "TURBOPACK unreachable";
        }
    }
    // walk down the path, swapping out linked pathparts for their real
    // values
    // NB: p.length changes.
    while(pos < p.length){
        // find the next part
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        // continue if not a symlink
        if (knownHard[base] || cache && cache[base] === base) {
            continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
            // some known symbolic link.  no need to stat again.
            resolvedLink = cache[base];
        } else {
            var stat = fs.lstatSync(base);
            if (!stat.isSymbolicLink()) {
                knownHard[base] = true;
                if (cache) cache[base] = base;
                continue;
            }
            // read the link if it wasn't read before
            // dev/ino always return 0 on windows, so skip the check.
            var linkTarget = null;
            if ("TURBOPACK compile-time truthy", 1) {
                var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
                if (seenLinks.hasOwnProperty(id)) {
                    linkTarget = seenLinks[id];
                }
            }
            if (linkTarget === null) {
                fs.statSync(base);
                linkTarget = fs.readlinkSync(base);
            }
            resolvedLink = pathModule.resolve(previous, linkTarget);
            // track this, if given a cache.
            if (cache) cache[base] = resolvedLink;
            if ("TURBOPACK compile-time truthy", 1) seenLinks[id] = linkTarget;
        }
        // resolve the link, then start over
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
    }
    if (cache) cache[original] = p;
    return p;
};
exports.realpath = function realpath(p, cache, cb) {
    if (typeof cb !== 'function') {
        cb = maybeCallback(cache);
        cache = null;
    }
    // make p is absolute
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(cb.bind(null, null, cache[p]));
    }
    var original = p, seenLinks = {}, knownHard = {};
    // current character position in p
    var pos;
    // the partial path so far, including a trailing slash if any
    var current;
    // the partial path without a trailing slash (except when pointing at a root)
    var base;
    // the partial path scanned in the previous round, with slash
    var previous;
    start();
    function start() {
        // Skip over roots
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = '';
        // On windows, check that the root exists. On unix there is no need.
        if ("TURBOPACK compile-time falsy", 0) {
            "TURBOPACK unreachable";
        } else {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(LOOP);
        }
    }
    // walk down the path, swapping out linked pathparts for their real
    // values
    function LOOP() {
        // stop if scanned past end of path
        if (pos >= p.length) {
            if (cache) cache[original] = p;
            return cb(null, p);
        }
        // find the next part
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        // continue if not a symlink
        if (knownHard[base] || cache && cache[base] === base) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
            // known symbolic link.  no need to stat again.
            return gotResolvedLink(cache[base]);
        }
        return fs.lstat(base, gotStat);
    }
    function gotStat(err, stat) {
        if (err) return cb(err);
        // if not a symlink, skip to the next path part
        if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache) cache[base] = base;
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(LOOP);
        }
        // stat & read the link if not read before
        // call gotTarget as soon as the link target is known
        // dev/ino always return 0 on windows, so skip the check.
        if ("TURBOPACK compile-time truthy", 1) {
            var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
                return gotTarget(null, seenLinks[id], base);
            }
        }
        fs.stat(base, function(err) {
            if (err) return cb(err);
            fs.readlink(base, function(err, target) {
                if ("TURBOPACK compile-time truthy", 1) seenLinks[id] = target;
                gotTarget(err, target);
            });
        });
    }
    function gotTarget(err, target, base) {
        if (err) return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache) cache[base] = resolvedLink;
        gotResolvedLink(resolvedLink);
    }
    function gotResolvedLink(resolvedLink) {
        // resolve the link, then start over
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
    }
};
}}),
"[project]/node_modules/fs.realpath/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
module.exports = realpath;
realpath.realpath = realpath;
realpath.sync = realpathSync;
realpath.realpathSync = realpathSync;
realpath.monkeypatch = monkeypatch;
realpath.unmonkeypatch = unmonkeypatch;
var fs = (()=>{
    const e = new Error("Cannot find module 'fs'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var origRealpath = fs.realpath;
var origRealpathSync = fs.realpathSync;
var version = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].version;
var ok = /^v[0-5]\./.test(version);
var old = __turbopack_context__.r("[project]/node_modules/fs.realpath/old.js [app-client] (ecmascript)");
function newError(er) {
    return er && er.syscall === 'realpath' && (er.code === 'ELOOP' || er.code === 'ENOMEM' || er.code === 'ENAMETOOLONG');
}
function realpath(p, cache, cb) {
    if (ok) {
        return origRealpath(p, cache, cb);
    }
    if (typeof cache === 'function') {
        cb = cache;
        cache = null;
    }
    origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
            old.realpath(p, cache, cb);
        } else {
            cb(er, result);
        }
    });
}
function realpathSync(p, cache) {
    if (ok) {
        return origRealpathSync(p, cache);
    }
    try {
        return origRealpathSync(p, cache);
    } catch (er) {
        if (newError(er)) {
            return old.realpathSync(p, cache);
        } else {
            throw er;
        }
    }
}
function monkeypatch() {
    fs.realpath = realpath;
    fs.realpathSync = realpathSync;
}
function unmonkeypatch() {
    fs.realpath = origRealpath;
    fs.realpathSync = origRealpathSync;
}
}}),
"[project]/node_modules/concat-map/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = function(xs, fn) {
    var res = [];
    for(var i = 0; i < xs.length; i++){
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};
var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};
}}),
"[project]/node_modules/balanced-match/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = balanced;
function balanced(a, b, str) {
    if (a instanceof RegExp) a = maybeMatch(a, str);
    if (b instanceof RegExp) b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
    };
}
function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
}
balanced.range = range;
function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
        if (a === b) {
            return [
                ai,
                bi
            ];
        }
        begs = [];
        left = str.length;
        while(i >= 0 && !result){
            if (i == ai) {
                begs.push(i);
                ai = str.indexOf(a, i + 1);
            } else if (begs.length == 1) {
                result = [
                    begs.pop(),
                    bi
                ];
            } else {
                beg = begs.pop();
                if (beg < left) {
                    left = beg;
                    right = bi;
                }
                bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
            result = [
                left,
                right
            ];
        }
    }
    return result;
}
}}),
"[project]/node_modules/brace-expansion/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var concatMap = __turbopack_context__.r("[project]/node_modules/concat-map/index.js [app-client] (ecmascript)");
var balanced = __turbopack_context__.r("[project]/node_modules/balanced-match/index.js [app-client] (ecmascript)");
module.exports = expandTop;
var escSlash = '\0SLASH' + Math.random() + '\0';
var escOpen = '\0OPEN' + Math.random() + '\0';
var escClose = '\0CLOSE' + Math.random() + '\0';
var escComma = '\0COMMA' + Math.random() + '\0';
var escPeriod = '\0PERIOD' + Math.random() + '\0';
function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
}
function escapeBraces(str) {
    return str.split('\\\\').join(escSlash).split('\\{').join(escOpen).split('\\}').join(escClose).split('\\,').join(escComma).split('\\.').join(escPeriod);
}
function unescapeBraces(str) {
    return str.split(escSlash).join('\\').split(escOpen).join('{').split(escClose).join('}').split(escComma).join(',').split(escPeriod).join('.');
}
// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
    if (!str) return [
        ''
    ];
    var parts = [];
    var m = balanced('{', '}', str);
    if (!m) return str.split(',');
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(',');
    p[p.length - 1] += '{' + body + '}';
    var postParts = parseCommaParts(post);
    if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
}
function expandTop(str) {
    if (!str) return [];
    // I don't know why Bash 4.3 does this, but it does.
    // Anything starting with {} will have the first two bytes preserved
    // but *only* at the top level, so {},a}b will not expand to anything,
    // but a{},b}c will be expanded to [a}c,abc].
    // One could argue that this is a bug in Bash, but since the goal of
    // this module is to match Bash's rules, we escape a leading {}
    if (str.substr(0, 2) === '{}') {
        str = '\\{\\}' + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
}
function identity(e) {
    return e;
}
function embrace(str) {
    return '{' + str + '}';
}
function isPadded(el) {
    return /^-?0\d/.test(el);
}
function lte(i, y) {
    return i <= y;
}
function gte(i, y) {
    return i >= y;
}
function expand(str, isTop) {
    var expansions = [];
    var m = balanced('{', '}', str);
    if (!m || /\$$/.test(m.pre)) return [
        str
    ];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(',') >= 0;
    if (!isSequence && !isOptions) {
        // {a},b}
        if (m.post.match(/,.*\}/)) {
            str = m.pre + '{' + m.body + escClose + m.post;
            return expand(str);
        }
        return [
            str
        ];
    }
    var n;
    if (isSequence) {
        n = m.body.split(/\.\./);
    } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
            // x{{a,b}}y ==> x{a}y x{b}y
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
                var post = m.post.length ? expand(m.post, false) : [
                    ''
                ];
                return post.map(function(p) {
                    return m.pre + n[0] + p;
                });
            }
        }
    }
    // at this point, n is the parts, and we know it's not a comma set
    // with a single entry.
    // no need to expand pre, since it is guaranteed to be free of brace-sets
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [
        ''
    ];
    var N;
    if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
            incr *= -1;
            test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for(var i = x; test(i, y); i += incr){
            var c;
            if (isAlphaSequence) {
                c = String.fromCharCode(i);
                if (c === '\\') c = '';
            } else {
                c = String(i);
                if (pad) {
                    var need = width - c.length;
                    if (need > 0) {
                        var z = new Array(need + 1).join('0');
                        if (i < 0) c = '-' + z + c.slice(1);
                        else c = z + c;
                    }
                }
            }
            N.push(c);
        }
    } else {
        N = concatMap(n, function(el) {
            return expand(el, false);
        });
    }
    for(var j = 0; j < N.length; j++){
        for(var k = 0; k < post.length; k++){
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion) expansions.push(expansion);
        }
    }
    return expansions;
}
}}),
"[project]/node_modules/minimatch/minimatch.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = minimatch;
minimatch.Minimatch = Minimatch;
var path = function() {
    try {
        return __turbopack_context__.r("[project]/node_modules/path/path.js [app-client] (ecmascript)");
    } catch (e) {}
}() || {
    sep: '/'
};
minimatch.sep = path.sep;
var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
var expand = __turbopack_context__.r("[project]/node_modules/brace-expansion/index.js [app-client] (ecmascript)");
var plTypes = {
    '!': {
        open: '(?:(?!(?:',
        close: '))[^/]*?)'
    },
    '?': {
        open: '(?:',
        close: ')?'
    },
    '+': {
        open: '(?:',
        close: ')+'
    },
    '*': {
        open: '(?:',
        close: ')*'
    },
    '@': {
        open: '(?:',
        close: ')'
    }
};
// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]';
// * => any number of characters
var star = qmark + '*?';
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';
// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!');
// "abc" -> { a:true, b:true, c:true }
function charSet(s) {
    return s.split('').reduce(function(set, c) {
        set[c] = true;
        return set;
    }, {});
}
// normalizes slashes.
var slashSplit = /\/+/;
minimatch.filter = filter;
function filter(pattern, options) {
    options = options || {};
    return function(p, i, list) {
        return minimatch(p, pattern, options);
    };
}
function ext(a, b) {
    b = b || {};
    var t = {};
    Object.keys(a).forEach(function(k) {
        t[k] = a[k];
    });
    Object.keys(b).forEach(function(k) {
        t[k] = b[k];
    });
    return t;
}
minimatch.defaults = function(def) {
    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
        return minimatch;
    }
    var orig = minimatch;
    var m = function minimatch(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
    };
    m.Minimatch = function Minimatch(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
    };
    m.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
    };
    m.filter = function filter(pattern, options) {
        return orig.filter(pattern, ext(def, options));
    };
    m.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
    };
    m.makeRe = function makeRe(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
    };
    m.braceExpand = function braceExpand(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
    };
    m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
    };
    return m;
};
Minimatch.defaults = function(def) {
    return minimatch.defaults(def).Minimatch;
};
function minimatch(p, pattern, options) {
    assertValidPattern(pattern);
    if (!options) options = {};
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
}
function Minimatch(pattern, options) {
    if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
    }
    assertValidPattern(pattern);
    if (!options) options = {};
    pattern = pattern.trim();
    // windows support: need to use /, not \
    if (!options.allowWindowsEscape && path.sep !== '/') {
        pattern = pattern.split(path.sep).join('/');
    }
    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    // make the set of regexps etc.
    this.make();
}
Minimatch.prototype.debug = function() {};
Minimatch.prototype.make = make;
function make() {
    var pattern = this.pattern;
    var options = this.options;
    // empty patterns and comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
        this.comment = true;
        return;
    }
    if (!pattern) {
        this.empty = true;
        return;
    }
    // step 1: figure out negation, etc.
    this.parseNegate();
    // step 2: expand braces
    var set = this.globSet = this.braceExpand();
    if (options.debug) this.debug = function debug() {
        console.error.apply(console, arguments);
    };
    this.debug(this.pattern, set);
    // step 3: now we have a set, so turn each one into a series of path-portion
    // matching patterns.
    // These will be regexps, except in the case of "**", which is
    // set to the GLOBSTAR object for globstar behavior,
    // and will not contain any / characters
    set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
    });
    this.debug(this.pattern, set);
    // glob --> regexps
    set = set.map(function(s, si, set) {
        return s.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    // filter out everything that didn't compile properly.
    set = set.filter(function(s) {
        return s.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
}
Minimatch.prototype.parseNegate = parseNegate;
function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options = this.options;
    var negateOffset = 0;
    if (options.nonegate) return;
    for(var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++){
        negate = !negate;
        negateOffset++;
    }
    if (negateOffset) this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
}
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function(pattern, options) {
    return braceExpand(pattern, options);
};
Minimatch.prototype.braceExpand = braceExpand;
function braceExpand(pattern, options) {
    if (!options) {
        if (this instanceof Minimatch) {
            options = this.options;
        } else {
            options = {};
        }
    }
    pattern = typeof pattern === 'undefined' ? this.pattern : pattern;
    assertValidPattern(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [
            pattern
        ];
    }
    return expand(pattern);
}
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = function(pattern) {
    if (typeof pattern !== 'string') {
        throw new TypeError('invalid pattern');
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError('pattern is too long');
    }
};
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse;
var SUBPARSE = {};
function parse(pattern, isSub) {
    assertValidPattern(pattern);
    var options = this.options;
    // shortcuts
    if (pattern === '**') {
        if (!options.noglobstar) return GLOBSTAR;
        else pattern = '*';
    }
    if (pattern === '') return '';
    var re = '';
    var hasMagic = !!options.nocase;
    var escaping = false;
    // ? => one single character
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    // . and .. never match anything that doesn't start with .,
    // even when options.dot is set.
    var patternStart = pattern.charAt(0) === '.' ? '' // anything
     : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))' : '(?!\\.)';
    var self = this;
    function clearStateChar() {
        if (stateChar) {
            // we had some state-tracking character
            // that wasn't consumed by this pass.
            switch(stateChar){
                case '*':
                    re += star;
                    hasMagic = true;
                    break;
                case '?':
                    re += qmark;
                    hasMagic = true;
                    break;
                default:
                    re += '\\' + stateChar;
                    break;
            }
            self.debug('clearStateChar %j %j', stateChar, re);
            stateChar = false;
        }
    }
    for(var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++){
        this.debug('%s\t%s %s %j', pattern, i, re, c);
        // skip over any that are escaped.
        if (escaping && reSpecials[c]) {
            re += '\\' + c;
            escaping = false;
            continue;
        }
        switch(c){
            /* istanbul ignore next */ case '/':
                {
                    // completely not allowed, even escaped.
                    // Should already be path-split by now.
                    return false;
                }
            case '\\':
                clearStateChar();
                escaping = true;
                continue;
            // the various stateChar values
            // for the "extglob" stuff.
            case '?':
            case '*':
            case '+':
            case '@':
            case '!':
                this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);
                // all of those are literals inside a class, except that
                // the glob [!a] means [^a] in regexp
                if (inClass) {
                    this.debug('  in class');
                    if (c === '!' && i === classStart + 1) c = '^';
                    re += c;
                    continue;
                }
                // if we already have a stateChar, then it means
                // that there was something like ** or +? in there.
                // Handle the stateChar, then proceed with this one.
                self.debug('call clearStateChar %j', stateChar);
                clearStateChar();
                stateChar = c;
                // if extglob is disabled, then +(asdf|foo) isn't a thing.
                // just clear the statechar *now*, rather than even diving into
                // the patternList stuff.
                if (options.noext) clearStateChar();
                continue;
            case '(':
                if (inClass) {
                    re += '(';
                    continue;
                }
                if (!stateChar) {
                    re += '\\(';
                    continue;
                }
                patternListStack.push({
                    type: stateChar,
                    start: i - 1,
                    reStart: re.length,
                    open: plTypes[stateChar].open,
                    close: plTypes[stateChar].close
                });
                // negation is (?:(?!js)[^/]*)
                re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
                this.debug('plType %j %j', stateChar, re);
                stateChar = false;
                continue;
            case ')':
                if (inClass || !patternListStack.length) {
                    re += '\\)';
                    continue;
                }
                clearStateChar();
                hasMagic = true;
                var pl = patternListStack.pop();
                // negation is (?:(?!js)[^/]*)
                // The others are (?:<pattern>)<type>
                re += pl.close;
                if (pl.type === '!') {
                    negativeLists.push(pl);
                }
                pl.reEnd = re.length;
                continue;
            case '|':
                if (inClass || !patternListStack.length || escaping) {
                    re += '\\|';
                    escaping = false;
                    continue;
                }
                clearStateChar();
                re += '|';
                continue;
            // these are mostly the same in regexp and glob
            case '[':
                // swallow any state-tracking char before the [
                clearStateChar();
                if (inClass) {
                    re += '\\' + c;
                    continue;
                }
                inClass = true;
                classStart = i;
                reClassStart = re.length;
                re += c;
                continue;
            case ']':
                //  a right bracket shall lose its special
                //  meaning and represent itself in
                //  a bracket expression if it occurs
                //  first in the list.  -- POSIX.2 2.8.3.2
                if (i === classStart + 1 || !inClass) {
                    re += '\\' + c;
                    escaping = false;
                    continue;
                }
                // handle the case where we left a class open.
                // "[z-a]" is valid, equivalent to "\[z-a\]"
                // split where the last [ was, make sure we don't have
                // an invalid re. if so, re-walk the contents of the
                // would-be class to re-translate any characters that
                // were passed through as-is
                // TODO: It would probably be faster to determine this
                // without a try/catch and a new RegExp, but it's tricky
                // to do safely.  For now, this is safe and works.
                var cs = pattern.substring(classStart + 1, i);
                try {
                    RegExp('[' + cs + ']');
                } catch (er) {
                    // not a valid class!
                    var sp = this.parse(cs, SUBPARSE);
                    re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
                    hasMagic = hasMagic || sp[1];
                    inClass = false;
                    continue;
                }
                // finish up the class.
                hasMagic = true;
                inClass = false;
                re += c;
                continue;
            default:
                // swallow any state char that wasn't consumed
                clearStateChar();
                if (escaping) {
                    // no need
                    escaping = false;
                } else if (reSpecials[c] && !(c === '^' && inClass)) {
                    re += '\\';
                }
                re += c;
        } // switch
    } // for
    // handle the case where we left a class open.
    // "[abc" is valid, equivalent to "\[abc"
    if (inClass) {
        // split where the last [ was, and escape it
        // this is a huge pita.  We now have to re-walk
        // the contents of the would-be class to re-translate
        // any characters that were passed through as-is
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + '\\[' + sp[0];
        hasMagic = hasMagic || sp[1];
    }
    // handle the case where we had a +( thing at the *end*
    // of the pattern.
    // each pattern list stack adds 3 chars, and we need to go through
    // and escape any | chars that were passed through as-is for the regexp.
    // Go through and escape them, taking care not to double-escape any
    // | chars that were already escaped.
    for(pl = patternListStack.pop(); pl; pl = patternListStack.pop()){
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug('setting tail', re, pl);
        // maybe some even number of \, then maybe 1 \, followed by a |
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
            if (!$2) {
                // the | isn't already escaped, so escape it.
                $2 = '\\';
            }
            // need to escape all those slashes *again*, without escaping the
            // one that we need for escaping the | character.  As it works out,
            // escaping an even number of slashes can be done by simply repeating
            // it exactly after itself.  That's why this trick works.
            //
            // I am sorry that you have to see this.
            return $1 + $1 + $2 + '|';
        });
        this.debug('tail=%j\n   %s', tail, tail, pl, re);
        var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\' + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + '\\(' + tail;
    }
    // handle trailing things that only matter at the very end.
    clearStateChar();
    if (escaping) {
        // trailing \\
        re += '\\\\';
    }
    // only need to apply the nodot start if the re starts with
    // something that could conceivably capture a dot
    var addPatternStart = false;
    switch(re.charAt(0)){
        case '[':
        case '.':
        case '(':
            addPatternStart = true;
    }
    // Hack to work around lack of negative lookbehind in JS
    // A pattern like: *.!(x).!(y|z) needs to ensure that a name
    // like 'a.xyz.yz' doesn't match.  So, the first negative
    // lookahead, has to look ALL the way ahead, to the end of
    // the pattern.
    for(var n = negativeLists.length - 1; n > -1; n--){
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        // Handle nested stuff like *(*.js|!(*.json)), where open parens
        // mean that we should *not* include the ) in the bit that is considered
        // "after" the negated section.
        var openParensBefore = nlBefore.split('(').length - 1;
        var cleanAfter = nlAfter;
        for(i = 0; i < openParensBefore; i++){
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
        }
        nlAfter = cleanAfter;
        var dollar = '';
        if (nlAfter === '' && isSub !== SUBPARSE) {
            dollar = '$';
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
    }
    // if the re is not "" at this point, then we need to make sure
    // it doesn't match against an empty path part.
    // Otherwise a/* will match a/, which it should not.
    if (re !== '' && hasMagic) {
        re = '(?=.)' + re;
    }
    if (addPatternStart) {
        re = patternStart + re;
    }
    // parsing just a piece of a larger pattern.
    if (isSub === SUBPARSE) {
        return [
            re,
            hasMagic
        ];
    }
    // skip the regexp for non-magical patterns
    // unescape anything in it, though, so that it'll be
    // an exact match against a file etc.
    if (!hasMagic) {
        return globUnescape(pattern);
    }
    var flags = options.nocase ? 'i' : '';
    try {
        var regExp = new RegExp('^' + re + '$', flags);
    } catch (er) /* istanbul ignore next - should be impossible */ {
        // If it was an invalid regular expression, then it can't match
        // anything.  This trick looks for a character after the end of
        // the string, which is of course impossible, except in multi-line
        // mode, but it's not a /m regex.
        return new RegExp('$.');
    }
    regExp._glob = pattern;
    regExp._src = re;
    return regExp;
}
minimatch.makeRe = function(pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe();
};
Minimatch.prototype.makeRe = makeRe;
function makeRe() {
    if (this.regexp || this.regexp === false) return this.regexp;
    // at this point, this.set is a 2d array of partial
    // pattern strings, or "**".
    //
    // It's better to use .match().  This function shouldn't
    // be used, really, but it's pretty convenient sometimes,
    // when you just want to work with a regex.
    var set = this.set;
    if (!set.length) {
        this.regexp = false;
        return this.regexp;
    }
    var options = this.options;
    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    var flags = options.nocase ? 'i' : '';
    var re = set.map(function(pattern) {
        return pattern.map(function(p) {
            return p === GLOBSTAR ? twoStar : typeof p === 'string' ? regExpEscape(p) : p._src;
        }).join('\\\/');
    }).join('|');
    // must match entire pattern
    // ending in a * or ** will make it less strict.
    re = '^(?:' + re + ')$';
    // can match anything, as long as it's not this.
    if (this.negate) re = '^(?!' + re + ').*$';
    try {
        this.regexp = new RegExp(re, flags);
    } catch (ex) /* istanbul ignore next - should be impossible */ {
        this.regexp = false;
    }
    return this.regexp;
}
minimatch.match = function(list, pattern, options) {
    options = options || {};
    var mm = new Minimatch(pattern, options);
    list = list.filter(function(f) {
        return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
Minimatch.prototype.match = function match(f, partial) {
    if (typeof partial === 'undefined') partial = this.partial;
    this.debug('match', f, this.pattern);
    // short-circuit in the case of busted things.
    // comments, etc.
    if (this.comment) return false;
    if (this.empty) return f === '';
    if (f === '/' && partial) return true;
    var options = this.options;
    // windows: need to use /, not \
    if (path.sep !== '/') {
        f = f.split(path.sep).join('/');
    }
    // treat the test path as a set of pathparts.
    f = f.split(slashSplit);
    this.debug(this.pattern, 'split', f);
    // just ONE of the pattern sets in this.set needs to match
    // in order for it to be valid.  If negating, then just one
    // match means that we have failed.
    // Either way, return on the first hit.
    var set = this.set;
    this.debug(this.pattern, 'set', set);
    // Find the basename of the path by looking for the last non-empty segment
    var filename;
    var i;
    for(i = f.length - 1; i >= 0; i--){
        filename = f[i];
        if (filename) break;
    }
    for(i = 0; i < set.length; i++){
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
            file = [
                filename
            ];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
            if (options.flipNegate) return true;
            return !this.negate;
        }
    }
    // didn't get any hits.  this is success if it's a negative
    // pattern, failure otherwise.
    if (options.flipNegate) return false;
    return this.negate;
};
// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options = this.options;
    this.debug('matchOne', {
        'this': this,
        file: file,
        pattern: pattern
    });
    this.debug('matchOne', file.length, pattern.length);
    for(var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++){
        this.debug('matchOne loop');
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        // should be impossible.
        // some invalid regexp stuff in the set.
        /* istanbul ignore if */ if (p === false) return false;
        if (p === GLOBSTAR) {
            this.debug('GLOBSTAR', [
                pattern,
                p,
                f
            ]);
            // "**"
            // a/**/b/**/c would match the following:
            // a/b/x/y/z/c
            // a/x/y/z/b/c
            // a/b/x/b/x/c
            // a/b/c
            // To do this, take the rest of the pattern after
            // the **, and see if it would match the file remainder.
            // If so, return success.
            // If not, the ** "swallows" a segment, and try again.
            // This is recursively awful.
            //
            // a/**/b/**/c matching a/b/x/y/z/c
            // - a matches a
            // - doublestar
            //   - matchOne(b/x/y/z/c, b/**/c)
            //     - b matches b
            //     - doublestar
            //       - matchOne(x/y/z/c, c) -> no
            //       - matchOne(y/z/c, c) -> no
            //       - matchOne(z/c, c) -> no
            //       - matchOne(c, c) yes, hit
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
                this.debug('** at the end');
                // a ** at the end will just swallow the rest.
                // We have found a match.
                // however, it will not swallow /.x, unless
                // options.dot is set.
                // . and .. are *never* matched by **, for explosively
                // exponential reasons.
                for(; fi < fl; fi++){
                    if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;
                }
                return true;
            }
            // ok, let's see if we can swallow whatever we can.
            while(fr < fl){
                var swallowee = file[fr];
                this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                // XXX remove this slice.  Just pass the start index.
                if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                    this.debug('globstar found match!', fr, fl, swallowee);
                    // found a match.
                    return true;
                } else {
                    // can't swallow "." or ".." ever.
                    // can only swallow ".foo" when explicitly asked.
                    if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {
                        this.debug('dot detected!', file, fr, pattern, pr);
                        break;
                    }
                    // ** swallows a segment, and continue.
                    this.debug('globstar swallow a segment, and continue');
                    fr++;
                }
            }
            // no match was found.
            // However, in partial mode, we can't say this is necessarily over.
            // If there's more *pattern* left, then
            /* istanbul ignore if */ if (partial) {
                // ran out of file
                this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                if (fr === fl) return true;
            }
            return false;
        }
        // something other than **
        // non-magic patterns just have to match exactly
        // patterns with magic have been turned into regexps.
        var hit;
        if (typeof p === 'string') {
            hit = f === p;
            this.debug('string match', p, f, hit);
        } else {
            hit = f.match(p);
            this.debug('pattern match', p, f, hit);
        }
        if (!hit) return false;
    }
    // Note: ending in / means that we'll get a final ""
    // at the end of the pattern.  This can only match a
    // corresponding "" at the end of the file.
    // If the file ends in /, then it can only match a
    // a pattern that ends in /, unless the pattern just
    // doesn't have any more for it. But, a/b/ should *not*
    // match "a/b/*", even though "" matches against the
    // [^/]*? pattern, except in partial mode, where it might
    // simply not be reached yet.
    // However, a/b/ should still satisfy a/*
    // now either we fell off the end of the pattern, or we're done.
    if (fi === fl && pi === pl) {
        // ran out of pattern and filename at the same time.
        // an exact hit!
        return true;
    } else if (fi === fl) {
        // ran out of file, but still had pattern left.
        // this is ok if we're doing the match as part of
        // a glob fs traversal.
        return partial;
    } else /* istanbul ignore else */ if (pi === pl) {
        // ran out of pattern, still have file left.
        // this is only acceptable if we're on the very last
        // empty segment of a file with a trailing slash.
        // a/* should match a/b/
        return fi === fl - 1 && file[fi] === '';
    }
    // should be unreachable.
    /* istanbul ignore next */ throw new Error('wtf?');
};
// replace stuff like \* with *
function globUnescape(s) {
    return s.replace(/\\(.)/g, '$1');
}
function regExpEscape(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
}
}}),
"[project]/node_modules/path-is-absolute/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
function posix(path) {
    return path.charAt(0) === '/';
}
function win32(path) {
    // https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
    var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    var result = splitDeviceRe.exec(path);
    var device = result[1] || '';
    var isUnc = Boolean(device && device.charAt(1) !== ':');
    // UNC paths are always absolute
    return Boolean(result[2] || isUnc);
}
module.exports = ("TURBOPACK compile-time falsy", 0) ? ("TURBOPACK unreachable", undefined) : posix;
module.exports.posix = posix;
module.exports.win32 = win32;
}}),
"[project]/node_modules/glob/common.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
exports.setopts = setopts;
exports.ownProp = ownProp;
exports.makeAbs = makeAbs;
exports.finish = finish;
exports.mark = mark;
exports.isIgnored = isIgnored;
exports.childrenIgnored = childrenIgnored;
function ownProp(obj, field) {
    return Object.prototype.hasOwnProperty.call(obj, field);
}
var fs = (()=>{
    const e = new Error("Cannot find module 'fs'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var path = __turbopack_context__.r("[project]/node_modules/path/path.js [app-client] (ecmascript)");
var minimatch = __turbopack_context__.r("[project]/node_modules/minimatch/minimatch.js [app-client] (ecmascript)");
var isAbsolute = __turbopack_context__.r("[project]/node_modules/path-is-absolute/index.js [app-client] (ecmascript)");
var Minimatch = minimatch.Minimatch;
function alphasort(a, b) {
    return a.localeCompare(b, 'en');
}
function setupIgnores(self, options) {
    self.ignore = options.ignore || [];
    if (!Array.isArray(self.ignore)) self.ignore = [
        self.ignore
    ];
    if (self.ignore.length) {
        self.ignore = self.ignore.map(ignoreMap);
    }
}
// ignore patterns are always in dot:true mode.
function ignoreMap(pattern) {
    var gmatcher = null;
    if (pattern.slice(-3) === '/**') {
        var gpattern = pattern.replace(/(\/\*\*)+$/, '');
        gmatcher = new Minimatch(gpattern, {
            dot: true
        });
    }
    return {
        matcher: new Minimatch(pattern, {
            dot: true
        }),
        gmatcher: gmatcher
    };
}
function setopts(self, pattern, options) {
    if (!options) options = {};
    // base-matching: just use globstar for that.
    if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
            throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
    }
    self.silent = !!options.silent;
    self.pattern = pattern;
    self.strict = options.strict !== false;
    self.realpath = !!options.realpath;
    self.realpathCache = options.realpathCache || Object.create(null);
    self.follow = !!options.follow;
    self.dot = !!options.dot;
    self.mark = !!options.mark;
    self.nodir = !!options.nodir;
    if (self.nodir) self.mark = true;
    self.sync = !!options.sync;
    self.nounique = !!options.nounique;
    self.nonull = !!options.nonull;
    self.nosort = !!options.nosort;
    self.nocase = !!options.nocase;
    self.stat = !!options.stat;
    self.noprocess = !!options.noprocess;
    self.absolute = !!options.absolute;
    self.fs = options.fs || fs;
    self.maxLength = options.maxLength || Infinity;
    self.cache = options.cache || Object.create(null);
    self.statCache = options.statCache || Object.create(null);
    self.symlinks = options.symlinks || Object.create(null);
    setupIgnores(self, options);
    self.changedCwd = false;
    var cwd = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].cwd();
    if (!ownProp(options, "cwd")) self.cwd = cwd;
    else {
        self.cwd = path.resolve(options.cwd);
        self.changedCwd = self.cwd !== cwd;
    }
    self.root = options.root || path.resolve(self.cwd, "/");
    self.root = path.resolve(self.root);
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    // TODO: is an absolute `cwd` supposed to be resolved against `root`?
    // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
    self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    self.nomount = !!options.nomount;
    // disable comments and negation in Minimatch.
    // Note that they are not supported in Glob itself anyway.
    options.nonegate = true;
    options.nocomment = true;
    // always treat \ in patterns as escapes, not path separators
    options.allowWindowsEscape = false;
    self.minimatch = new Minimatch(pattern, options);
    self.options = self.minimatch.options;
}
function finish(self) {
    var nou = self.nounique;
    var all = nou ? [] : Object.create(null);
    for(var i = 0, l = self.matches.length; i < l; i++){
        var matches = self.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
            if (self.nonull) {
                // do like the shell, and spit out the literal glob
                var literal = self.minimatch.globSet[i];
                if (nou) all.push(literal);
                else all[literal] = true;
            }
        } else {
            // had matches
            var m = Object.keys(matches);
            if (nou) all.push.apply(all, m);
            else m.forEach(function(m) {
                all[m] = true;
            });
        }
    }
    if (!nou) all = Object.keys(all);
    if (!self.nosort) all = all.sort(alphasort);
    // at *some* point we statted all of these
    if (self.mark) {
        for(var i = 0; i < all.length; i++){
            all[i] = self._mark(all[i]);
        }
        if (self.nodir) {
            all = all.filter(function(e) {
                var notDir = !/\/$/.test(e);
                var c = self.cache[e] || self.cache[makeAbs(self, e)];
                if (notDir && c) notDir = c !== 'DIR' && !Array.isArray(c);
                return notDir;
            });
        }
    }
    if (self.ignore.length) all = all.filter(function(m) {
        return !isIgnored(self, m);
    });
    self.found = all;
}
function mark(self, p) {
    var abs = makeAbs(self, p);
    var c = self.cache[abs];
    var m = p;
    if (c) {
        var isDir = c === 'DIR' || Array.isArray(c);
        var slash = p.slice(-1) === '/';
        if (isDir && !slash) m += '/';
        else if (!isDir && slash) m = m.slice(0, -1);
        if (m !== p) {
            var mabs = makeAbs(self, m);
            self.statCache[mabs] = self.statCache[abs];
            self.cache[mabs] = self.cache[abs];
        }
    }
    return m;
}
// lotta situps...
function makeAbs(self, f) {
    var abs = f;
    if (f.charAt(0) === '/') {
        abs = path.join(self.root, f);
    } else if (isAbsolute(f) || f === '') {
        abs = f;
    } else if (self.changedCwd) {
        abs = path.resolve(self.cwd, f);
    } else {
        abs = path.resolve(f);
    }
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    return abs;
}
// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored(self, path) {
    if (!self.ignore.length) return false;
    return self.ignore.some(function(item) {
        return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path));
    });
}
function childrenIgnored(self, path) {
    if (!self.ignore.length) return false;
    return self.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path));
    });
}
}}),
"[project]/node_modules/glob/sync.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
module.exports = globSync;
globSync.GlobSync = GlobSync;
var rp = __turbopack_context__.r("[project]/node_modules/fs.realpath/index.js [app-client] (ecmascript)");
var minimatch = __turbopack_context__.r("[project]/node_modules/minimatch/minimatch.js [app-client] (ecmascript)");
var Minimatch = minimatch.Minimatch;
var Glob = __turbopack_context__.r("[project]/node_modules/glob/glob.js [app-client] (ecmascript)").Glob;
var util = __turbopack_context__.r("[project]/node_modules/util/util.js [app-client] (ecmascript)");
var path = __turbopack_context__.r("[project]/node_modules/path/path.js [app-client] (ecmascript)");
var assert = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/assert/assert.js [app-client] (ecmascript)");
var isAbsolute = __turbopack_context__.r("[project]/node_modules/path-is-absolute/index.js [app-client] (ecmascript)");
var common = __turbopack_context__.r("[project]/node_modules/glob/common.js [app-client] (ecmascript)");
var setopts = common.setopts;
var ownProp = common.ownProp;
var childrenIgnored = common.childrenIgnored;
var isIgnored = common.isIgnored;
function globSync(pattern, options) {
    if (typeof options === 'function' || arguments.length === 3) throw new TypeError('callback provided to sync glob\n' + 'See: https://github.com/isaacs/node-glob/issues/167');
    return new GlobSync(pattern, options).found;
}
function GlobSync(pattern, options) {
    if (!pattern) throw new Error('must provide pattern');
    if (typeof options === 'function' || arguments.length === 3) throw new TypeError('callback provided to sync glob\n' + 'See: https://github.com/isaacs/node-glob/issues/167');
    if (!(this instanceof GlobSync)) return new GlobSync(pattern, options);
    setopts(this, pattern, options);
    if (this.noprocess) return this;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    for(var i = 0; i < n; i++){
        this._process(this.minimatch.set[i], i, false);
    }
    this._finish();
}
GlobSync.prototype._finish = function() {
    assert.ok(this instanceof GlobSync);
    if (this.realpath) {
        var self = this;
        this.matches.forEach(function(matchset, index) {
            var set = self.matches[index] = Object.create(null);
            for(var p in matchset){
                try {
                    p = self._makeAbs(p);
                    var real = rp.realpathSync(p, self.realpathCache);
                    set[real] = true;
                } catch (er) {
                    if (er.syscall === 'stat') set[self._makeAbs(p)] = true;
                    else throw er;
                }
            }
        });
    }
    common.finish(this);
};
GlobSync.prototype._process = function(pattern, index, inGlobStar) {
    assert.ok(this instanceof GlobSync);
    // Get the first [n] parts of pattern that are all strings.
    var n = 0;
    while(typeof pattern[n] === 'string'){
        n++;
    }
    // now n is the index of the first one that is *not* a string.
    // See if there's anything else
    var prefix;
    switch(n){
        // if not, then this is rather simple
        case pattern.length:
            this._processSimple(pattern.join('/'), index);
            return;
        case 0:
            // pattern *starts* with some non-trivial item.
            // going to readdir(cwd), but not include the prefix in matches.
            prefix = null;
            break;
        default:
            // pattern has some string bits in the front.
            // whatever it starts with, whether that's 'absolute' like /foo/bar,
            // or 'relative' like '../baz'
            prefix = pattern.slice(0, n).join('/');
            break;
    }
    var remain = pattern.slice(n);
    // get the list of entries.
    var read;
    if (prefix === null) read = '.';
    else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === 'string' ? p : '[*]';
    }).join('/'))) {
        if (!prefix || !isAbsolute(prefix)) prefix = '/' + prefix;
        read = prefix;
    } else read = prefix;
    var abs = this._makeAbs(read);
    //if ignored, skip processing
    if (childrenIgnored(this, read)) return;
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
    else this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
};
GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    // if the abs isn't a dir, then nothing can match!
    if (!entries) return;
    // It will only match dot entries if it starts with a dot, or if
    // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === '.';
    var matchedEntries = [];
    for(var i = 0; i < entries.length; i++){
        var e = entries[i];
        if (e.charAt(0) !== '.' || dotOk) {
            var m;
            if (negate && !prefix) {
                m = !e.match(pn);
            } else {
                m = e.match(pn);
            }
            if (m) matchedEntries.push(e);
        }
    }
    var len = matchedEntries.length;
    // If there are no matched entries, then nothing matches.
    if (len === 0) return;
    // if this is the last remaining pattern bit, then no need for
    // an additional stat *unless* the user has specified mark or
    // stat explicitly.  We know they exist, since readdir returned
    // them.
    if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index]) this.matches[index] = Object.create(null);
        for(var i = 0; i < len; i++){
            var e = matchedEntries[i];
            if (prefix) {
                if (prefix.slice(-1) !== '/') e = prefix + '/' + e;
                else e = prefix + e;
            }
            if (e.charAt(0) === '/' && !this.nomount) {
                e = path.join(this.root, e);
            }
            this._emitMatch(index, e);
        }
        // This was the last one, and no stats were needed
        return;
    }
    // now test all matched entries as stand-ins for that part
    // of the pattern.
    remain.shift();
    for(var i = 0; i < len; i++){
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) newPattern = [
            prefix,
            e
        ];
        else newPattern = [
            e
        ];
        this._process(newPattern.concat(remain), index, inGlobStar);
    }
};
GlobSync.prototype._emitMatch = function(index, e) {
    if (isIgnored(this, e)) return;
    var abs = this._makeAbs(e);
    if (this.mark) e = this._mark(e);
    if (this.absolute) {
        e = abs;
    }
    if (this.matches[index][e]) return;
    if (this.nodir) {
        var c = this.cache[abs];
        if (c === 'DIR' || Array.isArray(c)) return;
    }
    this.matches[index][e] = true;
    if (this.stat) this._stat(e);
};
GlobSync.prototype._readdirInGlobStar = function(abs) {
    // follow all symlinked directories forever
    // just proceed as if this is a non-globstar situation
    if (this.follow) return this._readdir(abs, false);
    var entries;
    var lstat;
    var stat;
    try {
        lstat = this.fs.lstatSync(abs);
    } catch (er) {
        if (er.code === 'ENOENT') {
            // lstat failed, doesn't exist
            return null;
        }
    }
    var isSym = lstat && lstat.isSymbolicLink();
    this.symlinks[abs] = isSym;
    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && lstat && !lstat.isDirectory()) this.cache[abs] = 'FILE';
    else entries = this._readdir(abs, false);
    return entries;
};
GlobSync.prototype._readdir = function(abs, inGlobStar) {
    var entries;
    if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs);
    if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === 'FILE') return null;
        if (Array.isArray(c)) return c;
    }
    try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
    } catch (er) {
        this._readdirError(abs, er);
        return null;
    }
};
GlobSync.prototype._readdirEntries = function(abs, entries) {
    // if we haven't asked to stat everything, then just
    // assume that everything in there exists, so we can avoid
    // having to stat it a second time.
    if (!this.mark && !this.stat) {
        for(var i = 0; i < entries.length; i++){
            var e = entries[i];
            if (abs === '/') e = abs + e;
            else e = abs + '/' + e;
            this.cache[e] = true;
        }
    }
    this.cache[abs] = entries;
    // mark and cache dir-ness
    return entries;
};
GlobSync.prototype._readdirError = function(f, er) {
    // handle errors, and cache the information
    switch(er.code){
        case 'ENOTSUP':
        case 'ENOTDIR':
            var abs = this._makeAbs(f);
            this.cache[abs] = 'FILE';
            if (abs === this.cwdAbs) {
                var error = new Error(er.code + ' invalid cwd ' + this.cwd);
                error.path = this.cwd;
                error.code = er.code;
                throw error;
            }
            break;
        case 'ENOENT':
        case 'ELOOP':
        case 'ENAMETOOLONG':
        case 'UNKNOWN':
            this.cache[this._makeAbs(f)] = false;
            break;
        default:
            this.cache[this._makeAbs(f)] = false;
            if (this.strict) throw er;
            if (!this.silent) console.error('glob error', er);
            break;
    }
};
GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    // no entries means not a dir, so it can never have matches
    // foo.txt/** doesn't match foo.txt
    if (!entries) return;
    // test without the globstar, and with every child both below
    // and replacing the globstar.
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [
        prefix
    ] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    // the noGlobStar pattern exits the inGlobStar state
    this._process(noGlobStar, index, false);
    var len = entries.length;
    var isSym = this.symlinks[abs];
    // If it's a symlink, and we're in a globstar, then stop
    if (isSym && inGlobStar) return;
    for(var i = 0; i < len; i++){
        var e = entries[i];
        if (e.charAt(0) === '.' && !this.dot) continue;
        // these two cases enter the inGlobStar state
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
    }
};
GlobSync.prototype._processSimple = function(prefix, index) {
    // XXX review this.  Shouldn't it be doing the mounting etc
    // before doing stat?  kinda weird?
    var exists = this._stat(prefix);
    if (!this.matches[index]) this.matches[index] = Object.create(null);
    // If it doesn't exist, then just mark the lack of results
    if (!exists) return;
    if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === '/') {
            prefix = path.join(this.root, prefix);
        } else {
            prefix = path.resolve(this.root, prefix);
            if (trail) prefix += '/';
        }
    }
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    // Mark this as a match
    this._emitMatch(index, prefix);
};
// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function(f) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === '/';
    if (f.length > this.maxLength) return false;
    if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c)) c = 'DIR';
        // It exists, but maybe not how we need it
        if (!needDir || c === 'DIR') return c;
        if (needDir && c === 'FILE') return false;
    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
    }
    var exists;
    var stat = this.statCache[abs];
    if (!stat) {
        var lstat;
        try {
            lstat = this.fs.lstatSync(abs);
        } catch (er) {
            if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
                this.statCache[abs] = false;
                return false;
            }
        }
        if (lstat && lstat.isSymbolicLink()) {
            try {
                stat = this.fs.statSync(abs);
            } catch (er) {
                stat = lstat;
            }
        } else {
            stat = lstat;
        }
    }
    this.statCache[abs] = stat;
    var c = true;
    if (stat) c = stat.isDirectory() ? 'DIR' : 'FILE';
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === 'FILE') return false;
    return c;
};
GlobSync.prototype._mark = function(p) {
    return common.mark(this, p);
};
GlobSync.prototype._makeAbs = function(f) {
    return common.makeAbs(this, f);
};
}}),
"[project]/node_modules/glob/glob.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
module.exports = glob;
var rp = __turbopack_context__.r("[project]/node_modules/fs.realpath/index.js [app-client] (ecmascript)");
var minimatch = __turbopack_context__.r("[project]/node_modules/minimatch/minimatch.js [app-client] (ecmascript)");
var Minimatch = minimatch.Minimatch;
var inherits = __turbopack_context__.r("[project]/node_modules/inherits/inherits_browser.js [app-client] (ecmascript)");
var EE = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)").EventEmitter;
var path = __turbopack_context__.r("[project]/node_modules/path/path.js [app-client] (ecmascript)");
var assert = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/assert/assert.js [app-client] (ecmascript)");
var isAbsolute = __turbopack_context__.r("[project]/node_modules/path-is-absolute/index.js [app-client] (ecmascript)");
var globSync = __turbopack_context__.r("[project]/node_modules/glob/sync.js [app-client] (ecmascript)");
var common = __turbopack_context__.r("[project]/node_modules/glob/common.js [app-client] (ecmascript)");
var setopts = common.setopts;
var ownProp = common.ownProp;
var inflight = __turbopack_context__.r("[project]/node_modules/inflight/inflight.js [app-client] (ecmascript)");
var util = __turbopack_context__.r("[project]/node_modules/util/util.js [app-client] (ecmascript)");
var childrenIgnored = common.childrenIgnored;
var isIgnored = common.isIgnored;
var once = __turbopack_context__.r("[project]/node_modules/once/once.js [app-client] (ecmascript)");
function glob(pattern, options, cb) {
    if (typeof options === 'function') cb = options, options = {};
    if (!options) options = {};
    if (options.sync) {
        if (cb) throw new TypeError('callback provided to sync glob');
        return globSync(pattern, options);
    }
    return new Glob(pattern, options, cb);
}
glob.sync = globSync;
var GlobSync = glob.GlobSync = globSync.GlobSync;
// old api surface
glob.glob = glob;
function extend(origin, add) {
    if (add === null || typeof add !== 'object') {
        return origin;
    }
    var keys = Object.keys(add);
    var i = keys.length;
    while(i--){
        origin[keys[i]] = add[keys[i]];
    }
    return origin;
}
glob.hasMagic = function(pattern, options_) {
    var options = extend({}, options_);
    options.noprocess = true;
    var g = new Glob(pattern, options);
    var set = g.minimatch.set;
    if (!pattern) return false;
    if (set.length > 1) return true;
    for(var j = 0; j < set[0].length; j++){
        if (typeof set[0][j] !== 'string') return true;
    }
    return false;
};
glob.Glob = Glob;
inherits(Glob, EE);
function Glob(pattern, options, cb) {
    if (typeof options === 'function') {
        cb = options;
        options = null;
    }
    if (options && options.sync) {
        if (cb) throw new TypeError('callback provided to sync glob');
        return new GlobSync(pattern, options);
    }
    if (!(this instanceof Glob)) return new Glob(pattern, options, cb);
    setopts(this, pattern, options);
    this._didRealPath = false;
    // process each pattern in the minimatch set
    var n = this.minimatch.set.length;
    // The matches are stored as {<filename>: true,...} so that
    // duplicates are automagically pruned.
    // Later, we do an Object.keys() on these.
    // Keep them as a list so we can fill in when nonull is set.
    this.matches = new Array(n);
    if (typeof cb === 'function') {
        cb = once(cb);
        this.on('error', cb);
        this.on('end', function(matches) {
            cb(null, matches);
        });
    }
    var self = this;
    this._processing = 0;
    this._emitQueue = [];
    this._processQueue = [];
    this.paused = false;
    if (this.noprocess) return this;
    if (n === 0) return done();
    var sync = true;
    for(var i = 0; i < n; i++){
        this._process(this.minimatch.set[i], i, false, done);
    }
    sync = false;
    function done() {
        --self._processing;
        if (self._processing <= 0) {
            if (sync) {
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(function() {
                    self._finish();
                });
            } else {
                self._finish();
            }
        }
    }
}
Glob.prototype._finish = function() {
    assert(this instanceof Glob);
    if (this.aborted) return;
    if (this.realpath && !this._didRealpath) return this._realpath();
    common.finish(this);
    this.emit('end', this.found);
};
Glob.prototype._realpath = function() {
    if (this._didRealpath) return;
    this._didRealpath = true;
    var n = this.matches.length;
    if (n === 0) return this._finish();
    var self = this;
    for(var i = 0; i < this.matches.length; i++)this._realpathSet(i, next);
    function next() {
        if (--n === 0) self._finish();
    }
};
Glob.prototype._realpathSet = function(index, cb) {
    var matchset = this.matches[index];
    if (!matchset) return cb();
    var found = Object.keys(matchset);
    var self = this;
    var n = found.length;
    if (n === 0) return cb();
    var set = this.matches[index] = Object.create(null);
    found.forEach(function(p, i) {
        // If there's a problem with the stat, then it means that
        // one or more of the links in the realpath couldn't be
        // resolved.  just return the abs value in that case.
        p = self._makeAbs(p);
        rp.realpath(p, self.realpathCache, function(er, real) {
            if (!er) set[real] = true;
            else if (er.syscall === 'stat') set[p] = true;
            else self.emit('error', er) // srsly wtf right here
            ;
            if (--n === 0) {
                self.matches[index] = set;
                cb();
            }
        });
    });
};
Glob.prototype._mark = function(p) {
    return common.mark(this, p);
};
Glob.prototype._makeAbs = function(f) {
    return common.makeAbs(this, f);
};
Glob.prototype.abort = function() {
    this.aborted = true;
    this.emit('abort');
};
Glob.prototype.pause = function() {
    if (!this.paused) {
        this.paused = true;
        this.emit('pause');
    }
};
Glob.prototype.resume = function() {
    if (this.paused) {
        this.emit('resume');
        this.paused = false;
        if (this._emitQueue.length) {
            var eq = this._emitQueue.slice(0);
            this._emitQueue.length = 0;
            for(var i = 0; i < eq.length; i++){
                var e = eq[i];
                this._emitMatch(e[0], e[1]);
            }
        }
        if (this._processQueue.length) {
            var pq = this._processQueue.slice(0);
            this._processQueue.length = 0;
            for(var i = 0; i < pq.length; i++){
                var p = pq[i];
                this._processing--;
                this._process(p[0], p[1], p[2], p[3]);
            }
        }
    }
};
Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
    assert(this instanceof Glob);
    assert(typeof cb === 'function');
    if (this.aborted) return;
    this._processing++;
    if (this.paused) {
        this._processQueue.push([
            pattern,
            index,
            inGlobStar,
            cb
        ]);
        return;
    }
    //console.error('PROCESS %d', this._processing, pattern)
    // Get the first [n] parts of pattern that are all strings.
    var n = 0;
    while(typeof pattern[n] === 'string'){
        n++;
    }
    // now n is the index of the first one that is *not* a string.
    // see if there's anything else
    var prefix;
    switch(n){
        // if not, then this is rather simple
        case pattern.length:
            this._processSimple(pattern.join('/'), index, cb);
            return;
        case 0:
            // pattern *starts* with some non-trivial item.
            // going to readdir(cwd), but not include the prefix in matches.
            prefix = null;
            break;
        default:
            // pattern has some string bits in the front.
            // whatever it starts with, whether that's 'absolute' like /foo/bar,
            // or 'relative' like '../baz'
            prefix = pattern.slice(0, n).join('/');
            break;
    }
    var remain = pattern.slice(n);
    // get the list of entries.
    var read;
    if (prefix === null) read = '.';
    else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === 'string' ? p : '[*]';
    }).join('/'))) {
        if (!prefix || !isAbsolute(prefix)) prefix = '/' + prefix;
        read = prefix;
    } else read = prefix;
    var abs = this._makeAbs(read);
    //if ignored, skip _processing
    if (childrenIgnored(this, read)) return cb();
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
    else this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
};
Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
        return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
};
Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    // if the abs isn't a dir, then nothing can match!
    if (!entries) return cb();
    // It will only match dot entries if it starts with a dot, or if
    // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === '.';
    var matchedEntries = [];
    for(var i = 0; i < entries.length; i++){
        var e = entries[i];
        if (e.charAt(0) !== '.' || dotOk) {
            var m;
            if (negate && !prefix) {
                m = !e.match(pn);
            } else {
                m = e.match(pn);
            }
            if (m) matchedEntries.push(e);
        }
    }
    //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)
    var len = matchedEntries.length;
    // If there are no matched entries, then nothing matches.
    if (len === 0) return cb();
    // if this is the last remaining pattern bit, then no need for
    // an additional stat *unless* the user has specified mark or
    // stat explicitly.  We know they exist, since readdir returned
    // them.
    if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index]) this.matches[index] = Object.create(null);
        for(var i = 0; i < len; i++){
            var e = matchedEntries[i];
            if (prefix) {
                if (prefix !== '/') e = prefix + '/' + e;
                else e = prefix + e;
            }
            if (e.charAt(0) === '/' && !this.nomount) {
                e = path.join(this.root, e);
            }
            this._emitMatch(index, e);
        }
        // This was the last one, and no stats were needed
        return cb();
    }
    // now test all matched entries as stand-ins for that part
    // of the pattern.
    remain.shift();
    for(var i = 0; i < len; i++){
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
            if (prefix !== '/') e = prefix + '/' + e;
            else e = prefix + e;
        }
        this._process([
            e
        ].concat(remain), index, inGlobStar, cb);
    }
    cb();
};
Glob.prototype._emitMatch = function(index, e) {
    if (this.aborted) return;
    if (isIgnored(this, e)) return;
    if (this.paused) {
        this._emitQueue.push([
            index,
            e
        ]);
        return;
    }
    var abs = isAbsolute(e) ? e : this._makeAbs(e);
    if (this.mark) e = this._mark(e);
    if (this.absolute) e = abs;
    if (this.matches[index][e]) return;
    if (this.nodir) {
        var c = this.cache[abs];
        if (c === 'DIR' || Array.isArray(c)) return;
    }
    this.matches[index][e] = true;
    var st = this.statCache[abs];
    if (st) this.emit('stat', e, st);
    this.emit('match', e);
};
Glob.prototype._readdirInGlobStar = function(abs, cb) {
    if (this.aborted) return;
    // follow all symlinked directories forever
    // just proceed as if this is a non-globstar situation
    if (this.follow) return this._readdir(abs, false, cb);
    var lstatkey = 'lstat\0' + abs;
    var self = this;
    var lstatcb = inflight(lstatkey, lstatcb_);
    if (lstatcb) self.fs.lstat(abs, lstatcb);
    function lstatcb_(er, lstat) {
        if (er && er.code === 'ENOENT') return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self.symlinks[abs] = isSym;
        // If it's not a symlink or a dir, then it's definitely a regular file.
        // don't bother doing a readdir in that case.
        if (!isSym && lstat && !lstat.isDirectory()) {
            self.cache[abs] = 'FILE';
            cb();
        } else self._readdir(abs, false, cb);
    }
};
Glob.prototype._readdir = function(abs, inGlobStar, cb) {
    if (this.aborted) return;
    cb = inflight('readdir\0' + abs + '\0' + inGlobStar, cb);
    if (!cb) return;
    //console.error('RD %j %j', +inGlobStar, abs)
    if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs, cb);
    if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === 'FILE') return cb();
        if (Array.isArray(c)) return cb(null, c);
    }
    var self = this;
    self.fs.readdir(abs, readdirCb(this, abs, cb));
};
function readdirCb(self, abs, cb) {
    return function(er, entries) {
        if (er) self._readdirError(abs, er, cb);
        else self._readdirEntries(abs, entries, cb);
    };
}
Glob.prototype._readdirEntries = function(abs, entries, cb) {
    if (this.aborted) return;
    // if we haven't asked to stat everything, then just
    // assume that everything in there exists, so we can avoid
    // having to stat it a second time.
    if (!this.mark && !this.stat) {
        for(var i = 0; i < entries.length; i++){
            var e = entries[i];
            if (abs === '/') e = abs + e;
            else e = abs + '/' + e;
            this.cache[e] = true;
        }
    }
    this.cache[abs] = entries;
    return cb(null, entries);
};
Glob.prototype._readdirError = function(f, er, cb) {
    if (this.aborted) return;
    // handle errors, and cache the information
    switch(er.code){
        case 'ENOTSUP':
        case 'ENOTDIR':
            var abs = this._makeAbs(f);
            this.cache[abs] = 'FILE';
            if (abs === this.cwdAbs) {
                var error = new Error(er.code + ' invalid cwd ' + this.cwd);
                error.path = this.cwd;
                error.code = er.code;
                this.emit('error', error);
                this.abort();
            }
            break;
        case 'ENOENT':
        case 'ELOOP':
        case 'ENAMETOOLONG':
        case 'UNKNOWN':
            this.cache[this._makeAbs(f)] = false;
            break;
        default:
            this.cache[this._makeAbs(f)] = false;
            if (this.strict) {
                this.emit('error', er);
                // If the error is handled, then we abort
                // if not, we threw out of here
                this.abort();
            }
            if (!this.silent) console.error('glob error', er);
            break;
    }
    return cb();
};
Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
        self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
};
Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    //console.error('pgs2', prefix, remain[0], entries)
    // no entries means not a dir, so it can never have matches
    // foo.txt/** doesn't match foo.txt
    if (!entries) return cb();
    // test without the globstar, and with every child both below
    // and replacing the globstar.
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [
        prefix
    ] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    // the noGlobStar pattern exits the inGlobStar state
    this._process(noGlobStar, index, false, cb);
    var isSym = this.symlinks[abs];
    var len = entries.length;
    // If it's a symlink, and we're in a globstar, then stop
    if (isSym && inGlobStar) return cb();
    for(var i = 0; i < len; i++){
        var e = entries[i];
        if (e.charAt(0) === '.' && !this.dot) continue;
        // these two cases enter the inGlobStar state
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
    }
    cb();
};
Glob.prototype._processSimple = function(prefix, index, cb) {
    // XXX review this.  Shouldn't it be doing the mounting etc
    // before doing stat?  kinda weird?
    var self = this;
    this._stat(prefix, function(er, exists) {
        self._processSimple2(prefix, index, er, exists, cb);
    });
};
Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
    //console.error('ps2', prefix, exists)
    if (!this.matches[index]) this.matches[index] = Object.create(null);
    // If it doesn't exist, then just mark the lack of results
    if (!exists) return cb();
    if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === '/') {
            prefix = path.join(this.root, prefix);
        } else {
            prefix = path.resolve(this.root, prefix);
            if (trail) prefix += '/';
        }
    }
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    // Mark this as a match
    this._emitMatch(index, prefix);
    cb();
};
// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function(f, cb) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === '/';
    if (f.length > this.maxLength) return cb();
    if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c)) c = 'DIR';
        // It exists, but maybe not how we need it
        if (!needDir || c === 'DIR') return cb(null, c);
        if (needDir && c === 'FILE') return cb();
    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
    }
    var exists;
    var stat = this.statCache[abs];
    if (stat !== undefined) {
        if (stat === false) return cb(null, stat);
        else {
            var type = stat.isDirectory() ? 'DIR' : 'FILE';
            if (needDir && type === 'FILE') return cb();
            else return cb(null, type, stat);
        }
    }
    var self = this;
    var statcb = inflight('stat\0' + abs, lstatcb_);
    if (statcb) self.fs.lstat(abs, statcb);
    function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
            // If it's a symlink, then treat it as the target, unless
            // the target does not exist, then treat it as a file.
            return self.fs.stat(abs, function(er, stat) {
                if (er) self._stat2(f, abs, null, lstat, cb);
                else self._stat2(f, abs, er, stat, cb);
            });
        } else {
            self._stat2(f, abs, er, lstat, cb);
        }
    }
};
Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
    if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false;
        return cb();
    }
    var needDir = f.slice(-1) === '/';
    this.statCache[abs] = stat;
    if (abs.slice(-1) === '/' && stat && !stat.isDirectory()) return cb(null, false, stat);
    var c = true;
    if (stat) c = stat.isDirectory() ? 'DIR' : 'FILE';
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === 'FILE') return cb();
    return cb(null, c, stat);
};
}}),
"[project]/node_modules/wrappy/wrappy.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy;
function wrappy(fn, cb) {
    if (fn && cb) return wrappy(fn)(cb);
    if (typeof fn !== 'function') throw new TypeError('need wrapper function');
    Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
    });
    return wrapper;
    "TURBOPACK unreachable";
    function wrapper() {
        var args = new Array(arguments.length);
        for(var i = 0; i < args.length; i++){
            args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb = args[args.length - 1];
        if (typeof ret === 'function' && ret !== cb) {
            Object.keys(cb).forEach(function(k) {
                ret[k] = cb[k];
            });
        }
        return ret;
    }
}
}}),
"[project]/node_modules/once/once.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var wrappy = __turbopack_context__.r("[project]/node_modules/wrappy/wrappy.js [app-client] (ecmascript)");
module.exports = wrappy(once);
module.exports.strict = wrappy(onceStrict);
once.proto = once(function() {
    Object.defineProperty(Function.prototype, 'once', {
        value: function() {
            return once(this);
        },
        configurable: true
    });
    Object.defineProperty(Function.prototype, 'onceStrict', {
        value: function() {
            return onceStrict(this);
        },
        configurable: true
    });
});
function once(fn) {
    var f = function() {
        if (f.called) return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
}
function onceStrict(fn) {
    var f = function() {
        if (f.called) throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || 'Function wrapped with `once`';
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
}
}}),
"[project]/node_modules/inflight/inflight.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var wrappy = __turbopack_context__.r("[project]/node_modules/wrappy/wrappy.js [app-client] (ecmascript)");
var reqs = Object.create(null);
var once = __turbopack_context__.r("[project]/node_modules/once/once.js [app-client] (ecmascript)");
module.exports = wrappy(inflight);
function inflight(key, cb) {
    if (reqs[key]) {
        reqs[key].push(cb);
        return null;
    } else {
        reqs[key] = [
            cb
        ];
        return makeres(key);
    }
}
function makeres(key) {
    return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        // XXX It's somewhat ambiguous whether a new callback added in this
        // pass should be queued for later execution if something in the
        // list of callbacks throws, or if it should just be discarded.
        // However, it's such an edge case that it hardly matters, and either
        // choice is likely as surprising as the other.
        // As it happens, we do go ahead and schedule it for later execution.
        try {
            for(var i = 0; i < len; i++){
                cbs[i].apply(null, args);
            }
        } finally{
            if (cbs.length > len) {
                // added more in the interim.
                // de-zalgo, just in case, but don't call again.
                cbs.splice(0, len);
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(function() {
                    RES.apply(null, args);
                });
            } else {
                delete reqs[key];
            }
        }
    });
}
function slice(args) {
    var length = args.length;
    var array = [];
    for(var i = 0; i < length; i++)array[i] = args[i];
    return array;
}
}}),
"[project]/node_modules/rimraf/rimraf.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
const assert = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/assert/assert.js [app-client] (ecmascript)");
const path = __turbopack_context__.r("[project]/node_modules/path/path.js [app-client] (ecmascript)");
const fs = (()=>{
    const e = new Error("Cannot find module 'fs'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
let glob = undefined;
try {
    glob = __turbopack_context__.r("[project]/node_modules/glob/glob.js [app-client] (ecmascript)");
} catch (_err) {
// treat glob as optional.
}
const defaultGlobOpts = {
    nosort: true,
    silent: true
};
// for EMFILE handling
let timeout = 0;
const isWindows = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform === "win32";
const defaults = (options)=>{
    const methods = [
        'unlink',
        'chmod',
        'stat',
        'lstat',
        'rmdir',
        'readdir'
    ];
    methods.forEach((m)=>{
        options[m] = options[m] || fs[m];
        m = m + 'Sync';
        options[m] = options[m] || fs[m];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
    options.emfileWait = options.emfileWait || 1000;
    if (options.glob === false) {
        options.disableGlob = true;
    }
    if (options.disableGlob !== true && glob === undefined) {
        throw Error('glob dependency not found, set `options.disableGlob = true` if intentional');
    }
    options.disableGlob = options.disableGlob || false;
    options.glob = options.glob || defaultGlobOpts;
};
const rimraf = (p, options, cb)=>{
    if (typeof options === 'function') {
        cb = options;
        options = {};
    }
    assert(p, 'rimraf: missing path');
    assert.equal(typeof p, 'string', 'rimraf: path should be a string');
    assert.equal(typeof cb, 'function', 'rimraf: callback function required');
    assert(options, 'rimraf: invalid options argument provided');
    assert.equal(typeof options, 'object', 'rimraf: options should be object');
    defaults(options);
    let busyTries = 0;
    let errState = null;
    let n = 0;
    const next = (er)=>{
        errState = errState || er;
        if (--n === 0) cb(errState);
    };
    const afterGlob = (er, results)=>{
        if (er) return cb(er);
        n = results.length;
        if (n === 0) return cb();
        results.forEach((p)=>{
            const CB = (er)=>{
                if (er) {
                    if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
                        busyTries++;
                        // try again, with the same exact callback as this one.
                        return setTimeout(()=>rimraf_(p, options, CB), busyTries * 100);
                    }
                    // this one won't happen if graceful-fs is used.
                    if (er.code === "EMFILE" && timeout < options.emfileWait) {
                        return setTimeout(()=>rimraf_(p, options, CB), timeout++);
                    }
                    // already gone
                    if (er.code === "ENOENT") er = null;
                }
                timeout = 0;
                next(er);
            };
            rimraf_(p, options, CB);
        });
    };
    if (options.disableGlob || !glob.hasMagic(p)) return afterGlob(null, [
        p
    ]);
    options.lstat(p, (er, stat)=>{
        if (!er) return afterGlob(null, [
            p
        ]);
        glob(p, options.glob, afterGlob);
    });
};
// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
const rimraf_ = (p, options, cb)=>{
    assert(p);
    assert(options);
    assert(typeof cb === 'function');
    // sunos lets the root user unlink directories, which is... weird.
    // so we have to lstat here and make sure it's not a dir.
    options.lstat(p, (er, st)=>{
        if (er && er.code === "ENOENT") return cb(null);
        // Windows can EPERM on stat.  Life is suffering.
        if ("TURBOPACK compile-time falsy", 0) {
            "TURBOPACK unreachable";
        }
        if (st && st.isDirectory()) return rmdir(p, options, er, cb);
        options.unlink(p, (er)=>{
            if (er) {
                if (er.code === "ENOENT") return cb(null);
                if (er.code === "EPERM") return ("TURBOPACK compile-time falsy", 0) ? ("TURBOPACK unreachable", undefined) : rmdir(p, options, er, cb);
                if (er.code === "EISDIR") return rmdir(p, options, er, cb);
            }
            return cb(er);
        });
    });
};
const fixWinEPERM = (p, options, er, cb)=>{
    assert(p);
    assert(options);
    assert(typeof cb === 'function');
    options.chmod(p, 0o666, (er2)=>{
        if (er2) cb(er2.code === "ENOENT" ? null : er);
        else options.stat(p, (er3, stats)=>{
            if (er3) cb(er3.code === "ENOENT" ? null : er);
            else if (stats.isDirectory()) rmdir(p, options, er, cb);
            else options.unlink(p, cb);
        });
    });
};
const fixWinEPERMSync = (p, options, er)=>{
    assert(p);
    assert(options);
    try {
        options.chmodSync(p, 0o666);
    } catch (er2) {
        if (er2.code === "ENOENT") return;
        else throw er;
    }
    let stats;
    try {
        stats = options.statSync(p);
    } catch (er3) {
        if (er3.code === "ENOENT") return;
        else throw er;
    }
    if (stats.isDirectory()) rmdirSync(p, options, er);
    else options.unlinkSync(p);
};
const rmdir = (p, options, originalEr, cb)=>{
    assert(p);
    assert(options);
    assert(typeof cb === 'function');
    // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
    // if we guessed wrong, and it's not a directory, then
    // raise the original error.
    options.rmdir(p, (er)=>{
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) rmkids(p, options, cb);
        else if (er && er.code === "ENOTDIR") cb(originalEr);
        else cb(er);
    });
};
const rmkids = (p, options, cb)=>{
    assert(p);
    assert(options);
    assert(typeof cb === 'function');
    options.readdir(p, (er, files)=>{
        if (er) return cb(er);
        let n = files.length;
        if (n === 0) return options.rmdir(p, cb);
        let errState;
        files.forEach((f)=>{
            rimraf(path.join(p, f), options, (er)=>{
                if (errState) return;
                if (er) return cb(errState = er);
                if (--n === 0) options.rmdir(p, cb);
            });
        });
    });
};
// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
const rimrafSync = (p, options)=>{
    options = options || {};
    defaults(options);
    assert(p, 'rimraf: missing path');
    assert.equal(typeof p, 'string', 'rimraf: path should be a string');
    assert(options, 'rimraf: missing options');
    assert.equal(typeof options, 'object', 'rimraf: options should be object');
    let results;
    if (options.disableGlob || !glob.hasMagic(p)) {
        results = [
            p
        ];
    } else {
        try {
            options.lstatSync(p);
            results = [
                p
            ];
        } catch (er) {
            results = glob.sync(p, options.glob);
        }
    }
    if (!results.length) return;
    for(let i = 0; i < results.length; i++){
        const p = results[i];
        let st;
        try {
            st = options.lstatSync(p);
        } catch (er) {
            if (er.code === "ENOENT") return;
            // Windows can EPERM on stat.  Life is suffering.
            if ("TURBOPACK compile-time falsy", 0) {
                "TURBOPACK unreachable";
            }
        }
        try {
            // sunos lets the root user unlink directories, which is... weird.
            if (st && st.isDirectory()) rmdirSync(p, options, null);
            else options.unlinkSync(p);
        } catch (er) {
            if (er.code === "ENOENT") return;
            if (er.code === "EPERM") return ("TURBOPACK compile-time falsy", 0) ? ("TURBOPACK unreachable", undefined) : rmdirSync(p, options, er);
            if (er.code !== "EISDIR") throw er;
            rmdirSync(p, options, er);
        }
    }
};
const rmdirSync = (p, options, originalEr)=>{
    assert(p);
    assert(options);
    try {
        options.rmdirSync(p);
    } catch (er) {
        if (er.code === "ENOENT") return;
        if (er.code === "ENOTDIR") throw originalEr;
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") rmkidsSync(p, options);
    }
};
const rmkidsSync = (p, options)=>{
    assert(p);
    assert(options);
    options.readdirSync(p).forEach((f)=>rimrafSync(path.join(p, f), options));
    // We only end up here once we got ENOTEMPTY at least once, and
    // at this point, we are guaranteed to have removed all the kids.
    // So, we know that it won't be ENOENT or ENOTDIR or anything else.
    // try really hard to delete stuff on windows, because it has a
    // PROFOUNDLY annoying habit of not closing handles promptly when
    // files are deleted, resulting in spurious ENOTEMPTY errors.
    const retries = ("TURBOPACK compile-time falsy", 0) ? ("TURBOPACK unreachable", undefined) : 1;
    let i = 0;
    do {
        let threw = true;
        try {
            const ret = options.rmdirSync(p, options);
            threw = false;
            return ret;
        } finally{
            if (++i < retries && threw) continue;
        }
    }while (true)
};
module.exports = rimraf;
rimraf.sync = rimrafSync;
}}),
"[project]/node_modules/detect-libc/lib/process.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Copyright 2017 Lovell Fuller and others.
// SPDX-License-Identifier: Apache-2.0
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
const isLinux = ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform === 'linux';
let report = null;
const getReport = ()=>{
    if (!report) {
        /* istanbul ignore next */ if (isLinux() && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].report) {
            "TURBOPACK unreachable";
        } else {
            report = {};
        }
    }
    return report;
};
module.exports = {
    isLinux,
    getReport
};
}}),
"[project]/node_modules/detect-libc/lib/filesystem.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Copyright 2017 Lovell Fuller and others.
// SPDX-License-Identifier: Apache-2.0
'use strict';
const fs = (()=>{
    const e = new Error("Cannot find module 'fs'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
/**
 * The path where we can find the ldd
 */ const LDD_PATH = '/usr/bin/ldd';
/**
 * Read the content of a file synchronous
 *
 * @param {string} path
 * @returns {string}
 */ const readFileSync = (path)=>fs.readFileSync(path, 'utf-8');
/**
 * Read the content of a file
 *
 * @param {string} path
 * @returns {Promise<string>}
 */ const readFile = (path)=>new Promise((resolve, reject)=>{
        fs.readFile(path, 'utf-8', (err, data)=>{
            if (err) {
                reject(err);
            } else {
                resolve(data);
            }
        });
    });
module.exports = {
    LDD_PATH,
    readFileSync,
    readFile
};
}}),
"[project]/node_modules/detect-libc/lib/detect-libc.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Copyright 2017 Lovell Fuller and others.
// SPDX-License-Identifier: Apache-2.0
'use strict';
const childProcess = (()=>{
    const e = new Error("Cannot find module 'child_process'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
const { isLinux, getReport } = __turbopack_context__.r("[project]/node_modules/detect-libc/lib/process.js [app-client] (ecmascript)");
const { LDD_PATH, readFile, readFileSync } = __turbopack_context__.r("[project]/node_modules/detect-libc/lib/filesystem.js [app-client] (ecmascript)");
let cachedFamilyFilesystem;
let cachedVersionFilesystem;
const command = 'getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true';
let commandOut = '';
const safeCommand = ()=>{
    if (!commandOut) {
        return new Promise((resolve)=>{
            childProcess.exec(command, (err, out)=>{
                commandOut = err ? ' ' : out;
                resolve(commandOut);
            });
        });
    }
    return commandOut;
};
const safeCommandSync = ()=>{
    if (!commandOut) {
        try {
            commandOut = childProcess.execSync(command, {
                encoding: 'utf8'
            });
        } catch (_err) {
            commandOut = ' ';
        }
    }
    return commandOut;
};
/**
 * A String constant containing the value `glibc`.
 * @type {string}
 * @public
 */ const GLIBC = 'glibc';
/**
 * A Regexp constant to get the GLIBC Version.
 * @type {string}
 */ const RE_GLIBC_VERSION = /LIBC[a-z0-9 \-).]*?(\d+\.\d+)/i;
/**
 * A String constant containing the value `musl`.
 * @type {string}
 * @public
 */ const MUSL = 'musl';
const isFileMusl = (f)=>f.includes('libc.musl-') || f.includes('ld-musl-');
const familyFromReport = ()=>{
    const report = getReport();
    if (report.header && report.header.glibcVersionRuntime) {
        return GLIBC;
    }
    if (Array.isArray(report.sharedObjects)) {
        if (report.sharedObjects.some(isFileMusl)) {
            return MUSL;
        }
    }
    return null;
};
const familyFromCommand = (out)=>{
    const [getconf, ldd1] = out.split(/[\r\n]+/);
    if (getconf && getconf.includes(GLIBC)) {
        return GLIBC;
    }
    if (ldd1 && ldd1.includes(MUSL)) {
        return MUSL;
    }
    return null;
};
const getFamilyFromLddContent = (content)=>{
    if (content.includes('musl')) {
        return MUSL;
    }
    if (content.includes('GNU C Library')) {
        return GLIBC;
    }
    return null;
};
const familyFromFilesystem = async ()=>{
    if (cachedFamilyFilesystem !== undefined) {
        return cachedFamilyFilesystem;
    }
    cachedFamilyFilesystem = null;
    try {
        const lddContent = await readFile(LDD_PATH);
        cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
    } catch (e) {}
    return cachedFamilyFilesystem;
};
const familyFromFilesystemSync = ()=>{
    if (cachedFamilyFilesystem !== undefined) {
        return cachedFamilyFilesystem;
    }
    cachedFamilyFilesystem = null;
    try {
        const lddContent = readFileSync(LDD_PATH);
        cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
    } catch (e) {}
    return cachedFamilyFilesystem;
};
/**
 * Resolves with the libc family when it can be determined, `null` otherwise.
 * @returns {Promise<?string>}
 */ const family = async ()=>{
    let family = null;
    if (isLinux()) {
        family = await familyFromFilesystem();
        if (!family) {
            family = familyFromReport();
        }
        if (!family) {
            const out = await safeCommand();
            family = familyFromCommand(out);
        }
    }
    return family;
};
/**
 * Returns the libc family when it can be determined, `null` otherwise.
 * @returns {?string}
 */ const familySync = ()=>{
    let family = null;
    if (isLinux()) {
        family = familyFromFilesystemSync();
        if (!family) {
            family = familyFromReport();
        }
        if (!family) {
            const out = safeCommandSync();
            family = familyFromCommand(out);
        }
    }
    return family;
};
/**
 * Resolves `true` only when the platform is Linux and the libc family is not `glibc`.
 * @returns {Promise<boolean>}
 */ const isNonGlibcLinux = async ()=>isLinux() && await family() !== GLIBC;
/**
 * Returns `true` only when the platform is Linux and the libc family is not `glibc`.
 * @returns {boolean}
 */ const isNonGlibcLinuxSync = ()=>isLinux() && familySync() !== GLIBC;
const versionFromFilesystem = async ()=>{
    if (cachedVersionFilesystem !== undefined) {
        return cachedVersionFilesystem;
    }
    cachedVersionFilesystem = null;
    try {
        const lddContent = await readFile(LDD_PATH);
        const versionMatch = lddContent.match(RE_GLIBC_VERSION);
        if (versionMatch) {
            cachedVersionFilesystem = versionMatch[1];
        }
    } catch (e) {}
    return cachedVersionFilesystem;
};
const versionFromFilesystemSync = ()=>{
    if (cachedVersionFilesystem !== undefined) {
        return cachedVersionFilesystem;
    }
    cachedVersionFilesystem = null;
    try {
        const lddContent = readFileSync(LDD_PATH);
        const versionMatch = lddContent.match(RE_GLIBC_VERSION);
        if (versionMatch) {
            cachedVersionFilesystem = versionMatch[1];
        }
    } catch (e) {}
    return cachedVersionFilesystem;
};
const versionFromReport = ()=>{
    const report = getReport();
    if (report.header && report.header.glibcVersionRuntime) {
        return report.header.glibcVersionRuntime;
    }
    return null;
};
const versionSuffix = (s)=>s.trim().split(/\s+/)[1];
const versionFromCommand = (out)=>{
    const [getconf, ldd1, ldd2] = out.split(/[\r\n]+/);
    if (getconf && getconf.includes(GLIBC)) {
        return versionSuffix(getconf);
    }
    if (ldd1 && ldd2 && ldd1.includes(MUSL)) {
        return versionSuffix(ldd2);
    }
    return null;
};
/**
 * Resolves with the libc version when it can be determined, `null` otherwise.
 * @returns {Promise<?string>}
 */ const version = async ()=>{
    let version = null;
    if (isLinux()) {
        version = await versionFromFilesystem();
        if (!version) {
            version = versionFromReport();
        }
        if (!version) {
            const out = await safeCommand();
            version = versionFromCommand(out);
        }
    }
    return version;
};
/**
 * Returns the libc version when it can be determined, `null` otherwise.
 * @returns {?string}
 */ const versionSync = ()=>{
    let version = null;
    if (isLinux()) {
        version = versionFromFilesystemSync();
        if (!version) {
            version = versionFromReport();
        }
        if (!version) {
            const out = safeCommandSync();
            version = versionFromCommand(out);
        }
    }
    return version;
};
module.exports = {
    GLIBC,
    MUSL,
    family,
    familySync,
    isNonGlibcLinux,
    isNonGlibcLinuxSync,
    version,
    versionSync
};
}}),
"[project]/node_modules/are-we-there-yet/lib/tracker-base.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var EventEmitter = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)").EventEmitter;
var util = __turbopack_context__.r("[project]/node_modules/util/util.js [app-client] (ecmascript)");
var trackerId = 0;
var TrackerBase = module.exports = function(name) {
    EventEmitter.call(this);
    this.id = ++trackerId;
    this.name = name;
};
util.inherits(TrackerBase, EventEmitter);
}}),
"[project]/node_modules/are-we-there-yet/lib/tracker.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var util = __turbopack_context__.r("[project]/node_modules/util/util.js [app-client] (ecmascript)");
var TrackerBase = __turbopack_context__.r("[project]/node_modules/are-we-there-yet/lib/tracker-base.js [app-client] (ecmascript)");
var Tracker = module.exports = function(name, todo) {
    TrackerBase.call(this, name);
    this.workDone = 0;
    this.workTodo = todo || 0;
};
util.inherits(Tracker, TrackerBase);
Tracker.prototype.completed = function() {
    return this.workTodo === 0 ? 0 : this.workDone / this.workTodo;
};
Tracker.prototype.addWork = function(work) {
    this.workTodo += work;
    this.emit('change', this.name, this.completed(), this);
};
Tracker.prototype.completeWork = function(work) {
    this.workDone += work;
    if (this.workDone > this.workTodo) {
        this.workDone = this.workTodo;
    }
    this.emit('change', this.name, this.completed(), this);
};
Tracker.prototype.finish = function() {
    this.workTodo = this.workDone = 1;
    this.emit('change', this.name, 1, this);
};
}}),
"[project]/node_modules/are-we-there-yet/lib/tracker-stream.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var util = __turbopack_context__.r("[project]/node_modules/util/util.js [app-client] (ecmascript)");
var stream = __turbopack_context__.r("[project]/node_modules/readable-stream/readable-browser.js [app-client] (ecmascript)");
var delegate = __turbopack_context__.r("[project]/node_modules/delegates/index.js [app-client] (ecmascript)");
var Tracker = __turbopack_context__.r("[project]/node_modules/are-we-there-yet/lib/tracker.js [app-client] (ecmascript)");
var TrackerStream = module.exports = function(name, size, options) {
    stream.Transform.call(this, options);
    this.tracker = new Tracker(name, size);
    this.name = name;
    this.id = this.tracker.id;
    this.tracker.on('change', delegateChange(this));
};
util.inherits(TrackerStream, stream.Transform);
function delegateChange(trackerStream) {
    return function(name, completion, tracker) {
        trackerStream.emit('change', name, completion, trackerStream);
    };
}
TrackerStream.prototype._transform = function(data, encoding, cb) {
    this.tracker.completeWork(data.length ? data.length : 1);
    this.push(data);
    cb();
};
TrackerStream.prototype._flush = function(cb) {
    this.tracker.finish();
    cb();
};
delegate(TrackerStream.prototype, 'tracker').method('completed').method('addWork').method('finish');
}}),
"[project]/node_modules/are-we-there-yet/lib/tracker-group.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var util = __turbopack_context__.r("[project]/node_modules/util/util.js [app-client] (ecmascript)");
var TrackerBase = __turbopack_context__.r("[project]/node_modules/are-we-there-yet/lib/tracker-base.js [app-client] (ecmascript)");
var Tracker = __turbopack_context__.r("[project]/node_modules/are-we-there-yet/lib/tracker.js [app-client] (ecmascript)");
var TrackerStream = __turbopack_context__.r("[project]/node_modules/are-we-there-yet/lib/tracker-stream.js [app-client] (ecmascript)");
var TrackerGroup = module.exports = function(name) {
    TrackerBase.call(this, name);
    this.parentGroup = null;
    this.trackers = [];
    this.completion = {};
    this.weight = {};
    this.totalWeight = 0;
    this.finished = false;
    this.bubbleChange = bubbleChange(this);
};
util.inherits(TrackerGroup, TrackerBase);
function bubbleChange(trackerGroup) {
    return function(name, completed, tracker) {
        trackerGroup.completion[tracker.id] = completed;
        if (trackerGroup.finished) {
            return;
        }
        trackerGroup.emit('change', name || trackerGroup.name, trackerGroup.completed(), trackerGroup);
    };
}
TrackerGroup.prototype.nameInTree = function() {
    var names = [];
    var from = this;
    while(from){
        names.unshift(from.name);
        from = from.parentGroup;
    }
    return names.join('/');
};
TrackerGroup.prototype.addUnit = function(unit, weight) {
    if (unit.addUnit) {
        var toTest = this;
        while(toTest){
            if (unit === toTest) {
                throw new Error('Attempted to add tracker group ' + unit.name + ' to tree that already includes it ' + this.nameInTree(this));
            }
            toTest = toTest.parentGroup;
        }
        unit.parentGroup = this;
    }
    this.weight[unit.id] = weight || 1;
    this.totalWeight += this.weight[unit.id];
    this.trackers.push(unit);
    this.completion[unit.id] = unit.completed();
    unit.on('change', this.bubbleChange);
    if (!this.finished) {
        this.emit('change', unit.name, this.completion[unit.id], unit);
    }
    return unit;
};
TrackerGroup.prototype.completed = function() {
    if (this.trackers.length === 0) {
        return 0;
    }
    var valPerWeight = 1 / this.totalWeight;
    var completed = 0;
    for(var ii = 0; ii < this.trackers.length; ii++){
        var trackerId = this.trackers[ii].id;
        completed += valPerWeight * this.weight[trackerId] * this.completion[trackerId];
    }
    return completed;
};
TrackerGroup.prototype.newGroup = function(name, weight) {
    return this.addUnit(new TrackerGroup(name), weight);
};
TrackerGroup.prototype.newItem = function(name, todo, weight) {
    return this.addUnit(new Tracker(name, todo), weight);
};
TrackerGroup.prototype.newStream = function(name, todo, weight) {
    return this.addUnit(new TrackerStream(name, todo), weight);
};
TrackerGroup.prototype.finish = function() {
    this.finished = true;
    if (!this.trackers.length) {
        this.addUnit(new Tracker(), 1, true);
    }
    for(var ii = 0; ii < this.trackers.length; ii++){
        var tracker = this.trackers[ii];
        tracker.finish();
        tracker.removeListener('change', this.bubbleChange);
    }
    this.emit('change', this.name, 1, this);
};
var buffer = '                                  ';
TrackerGroup.prototype.debug = function(depth) {
    depth = depth || 0;
    var indent = depth ? buffer.substr(0, depth) : '';
    var output = indent + (this.name || 'top') + ': ' + this.completed() + '\n';
    this.trackers.forEach(function(tracker) {
        if (tracker instanceof TrackerGroup) {
            output += tracker.debug(depth + 1);
        } else {
            output += indent + ' ' + tracker.name + ': ' + tracker.completed() + '\n';
        }
    });
    return output;
};
}}),
"[project]/node_modules/are-we-there-yet/lib/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
exports.TrackerGroup = __turbopack_context__.r("[project]/node_modules/are-we-there-yet/lib/tracker-group.js [app-client] (ecmascript)");
exports.Tracker = __turbopack_context__.r("[project]/node_modules/are-we-there-yet/lib/tracker.js [app-client] (ecmascript)");
exports.TrackerStream = __turbopack_context__.r("[project]/node_modules/are-we-there-yet/lib/tracker-stream.js [app-client] (ecmascript)");
}}),
"[project]/node_modules/util-deprecate/browser.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Module exports.
 */ module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */ function deprecate(fn, msg) {
    if (config('noDeprecation')) {
        return fn;
    }
    var warned = false;
    function deprecated() {
        if (!warned) {
            if (config('throwDeprecation')) {
                throw new Error(msg);
            } else if (config('traceDeprecation')) {
                console.trace(msg);
            } else {
                console.warn(msg);
            }
            warned = true;
        }
        return fn.apply(this, arguments);
    }
    return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */ function config(name) {
    // accessing global.localStorage can trigger a DOMException in sandboxed iframes
    try {
        if (!global.localStorage) return false;
    } catch (_) {
        return false;
    }
    var val = global.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === 'true';
}
}}),
"[project]/node_modules/safe-buffer/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ var buffer = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src){
        dst[key] = src[key];
    }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer;
} else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number');
    }
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === 'string') {
            buf.fill(fill, encoding);
        } else {
            buf.fill(fill);
        }
    } else {
        buf.fill(0);
    }
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    return buffer.SlowBuffer(size);
};
}}),
"[project]/node_modules/string_decoder/lib/string_decoder.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
/*<replacement>*/ var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-client] (ecmascript)").Buffer;
/*</replacement>*/ var isEncoding = Buffer.isEncoding || function(encoding) {
    encoding = '' + encoding;
    switch(encoding && encoding.toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
            return true;
        default:
            return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc) return 'utf8';
    var retried;
    while(true){
        switch(enc){
            case 'utf8':
            case 'utf-8':
                return 'utf8';
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                return 'utf16le';
            case 'latin1':
            case 'binary':
                return 'latin1';
            case 'base64':
            case 'ascii':
            case 'hex':
                return enc;
            default:
                if (retried) return; // undefined
                enc = ('' + enc).toLowerCase();
                retried = true;
        }
    }
}
;
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
    return nenc || enc;
}
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case 'utf16le':
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
        case 'utf8':
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
        case 'base64':
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
        default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return '';
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return '';
        i = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || '';
};
StringDecoder.prototype.end = utf8End;
// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;
    else if (byte >> 5 === 0x06) return 2;
    else if (byte >> 4 === 0x0E) return 3;
    else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return '\ufffd';
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return '\ufffd';
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return '\ufffd';
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString('utf8', i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString('utf8', i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + '\ufffd';
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString('utf16le', i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString('utf16le', i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString('utf16le', 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString('base64', i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString('base64', i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : '';
}
}}),
"[project]/node_modules/delegates/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Expose `Delegator`.
 */ module.exports = Delegator;
/**
 * Initialize a delegator.
 *
 * @param {Object} proto
 * @param {String} target
 * @api public
 */ function Delegator(proto, target) {
    if (!(this instanceof Delegator)) return new Delegator(proto, target);
    this.proto = proto;
    this.target = target;
    this.methods = [];
    this.getters = [];
    this.setters = [];
    this.fluents = [];
}
/**
 * Delegate method `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */ Delegator.prototype.method = function(name) {
    var proto = this.proto;
    var target = this.target;
    this.methods.push(name);
    proto[name] = function() {
        return this[target][name].apply(this[target], arguments);
    };
    return this;
};
/**
 * Delegator accessor `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */ Delegator.prototype.access = function(name) {
    return this.getter(name).setter(name);
};
/**
 * Delegator getter `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */ Delegator.prototype.getter = function(name) {
    var proto = this.proto;
    var target = this.target;
    this.getters.push(name);
    proto.__defineGetter__(name, function() {
        return this[target][name];
    });
    return this;
};
/**
 * Delegator setter `name`.
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */ Delegator.prototype.setter = function(name) {
    var proto = this.proto;
    var target = this.target;
    this.setters.push(name);
    proto.__defineSetter__(name, function(val) {
        return this[target][name] = val;
    });
    return this;
};
/**
 * Delegator fluent accessor
 *
 * @param {String} name
 * @return {Delegator} self
 * @api public
 */ Delegator.prototype.fluent = function(name) {
    var proto = this.proto;
    var target = this.target;
    this.fluents.push(name);
    proto[name] = function(val) {
        if ('undefined' != typeof val) {
            this[target][name] = val;
            return this;
        } else {
            return this[target][name];
        }
    };
    return this;
};
}}),
"[project]/node_modules/console-control-strings/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
// These tables borrowed from `ansi`
var prefix = '\x1b[';
exports.up = function up(num) {
    return prefix + (num || '') + 'A';
};
exports.down = function down(num) {
    return prefix + (num || '') + 'B';
};
exports.forward = function forward(num) {
    return prefix + (num || '') + 'C';
};
exports.back = function back(num) {
    return prefix + (num || '') + 'D';
};
exports.nextLine = function nextLine(num) {
    return prefix + (num || '') + 'E';
};
exports.previousLine = function previousLine(num) {
    return prefix + (num || '') + 'F';
};
exports.horizontalAbsolute = function horizontalAbsolute(num) {
    if (num == null) throw new Error('horizontalAboslute requires a column to position to');
    return prefix + num + 'G';
};
exports.eraseData = function eraseData() {
    return prefix + 'J';
};
exports.eraseLine = function eraseLine() {
    return prefix + 'K';
};
exports.goto = function(x, y) {
    return prefix + y + ';' + x + 'H';
};
exports.gotoSOL = function() {
    return '\r';
};
exports.beep = function() {
    return '\x07';
};
exports.hideCursor = function hideCursor() {
    return prefix + '?25l';
};
exports.showCursor = function showCursor() {
    return prefix + '?25h';
};
var colors = {
    reset: 0,
    // styles
    bold: 1,
    italic: 3,
    underline: 4,
    inverse: 7,
    // resets
    stopBold: 22,
    stopItalic: 23,
    stopUnderline: 24,
    stopInverse: 27,
    // colors
    white: 37,
    black: 30,
    blue: 34,
    cyan: 36,
    green: 32,
    magenta: 35,
    red: 31,
    yellow: 33,
    bgWhite: 47,
    bgBlack: 40,
    bgBlue: 44,
    bgCyan: 46,
    bgGreen: 42,
    bgMagenta: 45,
    bgRed: 41,
    bgYellow: 43,
    grey: 90,
    brightBlack: 90,
    brightRed: 91,
    brightGreen: 92,
    brightYellow: 93,
    brightBlue: 94,
    brightMagenta: 95,
    brightCyan: 96,
    brightWhite: 97,
    bgGrey: 100,
    bgBrightBlack: 100,
    bgBrightRed: 101,
    bgBrightGreen: 102,
    bgBrightYellow: 103,
    bgBrightBlue: 104,
    bgBrightMagenta: 105,
    bgBrightCyan: 106,
    bgBrightWhite: 107
};
exports.color = function color(colorWith) {
    if (arguments.length !== 1 || !Array.isArray(colorWith)) {
        colorWith = Array.prototype.slice.call(arguments);
    }
    return prefix + colorWith.map(colorNameToCode).join(';') + 'm';
};
function colorNameToCode(color) {
    if (colors[color] != null) return colors[color];
    throw new Error('Unknown color or style name: ' + color);
}
}}),
"[project]/node_modules/ansi-regex/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = ({ onlyFirst = false } = {})=>{
    const pattern = [
        '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
        '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
    ].join('|');
    return new RegExp(pattern, onlyFirst ? undefined : 'g');
};
}}),
"[project]/node_modules/strip-ansi/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const ansiRegex = __turbopack_context__.r("[project]/node_modules/ansi-regex/index.js [app-client] (ecmascript)");
module.exports = (string)=>typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
}}),
"[project]/node_modules/is-fullwidth-code-point/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* eslint-disable yoda */ 'use strict';
const isFullwidthCodePoint = (codePoint)=>{
    if (Number.isNaN(codePoint)) {
        return false;
    }
    // Code points are derived from:
    // http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
    if (codePoint >= 0x1100 && (codePoint <= 0x115F || // Hangul Jamo
    codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
    codePoint === 0x232A || 0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F || 0x3250 <= codePoint && codePoint <= 0x4DBF || 0x4E00 <= codePoint && codePoint <= 0xA4C6 || 0xA960 <= codePoint && codePoint <= 0xA97C || 0xAC00 <= codePoint && codePoint <= 0xD7A3 || 0xF900 <= codePoint && codePoint <= 0xFAFF || 0xFE10 <= codePoint && codePoint <= 0xFE19 || 0xFE30 <= codePoint && codePoint <= 0xFE6B || 0xFF01 <= codePoint && codePoint <= 0xFF60 || 0xFFE0 <= codePoint && codePoint <= 0xFFE6 || 0x1B000 <= codePoint && codePoint <= 0x1B001 || 0x1F200 <= codePoint && codePoint <= 0x1F251 || 0x20000 <= codePoint && codePoint <= 0x3FFFD)) {
        return true;
    }
    return false;
};
module.exports = isFullwidthCodePoint;
module.exports.default = isFullwidthCodePoint;
}}),
"[project]/node_modules/emoji-regex/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
module.exports = function() {
    // https://mths.be/emoji
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};
}}),
"[project]/node_modules/string-width/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const stripAnsi = __turbopack_context__.r("[project]/node_modules/strip-ansi/index.js [app-client] (ecmascript)");
const isFullwidthCodePoint = __turbopack_context__.r("[project]/node_modules/is-fullwidth-code-point/index.js [app-client] (ecmascript)");
const emojiRegex = __turbopack_context__.r("[project]/node_modules/emoji-regex/index.js [app-client] (ecmascript)");
const stringWidth = (string)=>{
    if (typeof string !== 'string' || string.length === 0) {
        return 0;
    }
    string = stripAnsi(string);
    if (string.length === 0) {
        return 0;
    }
    string = string.replace(emojiRegex(), '  ');
    let width = 0;
    for(let i = 0; i < string.length; i++){
        const code = string.codePointAt(i);
        // Ignore control characters
        if (code <= 0x1F || code >= 0x7F && code <= 0x9F) {
            continue;
        }
        // Ignore combining characters
        if (code >= 0x300 && code <= 0x36F) {
            continue;
        }
        // Surrogates
        if (code > 0xFFFF) {
            i++;
        }
        width += isFullwidthCodePoint(code) ? 2 : 1;
    }
    return width;
};
module.exports = stringWidth;
// TODO: remove this in the next major version
module.exports.default = stringWidth;
}}),
"[project]/node_modules/wide-align/align.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var stringWidth = __turbopack_context__.r("[project]/node_modules/string-width/index.js [app-client] (ecmascript)");
exports.center = alignCenter;
exports.left = alignLeft;
exports.right = alignRight;
// lodash's way of generating pad characters.
function createPadding(width) {
    var result = '';
    var string = ' ';
    var n = width;
    do {
        if (n % 2) {
            result += string;
        }
        n = Math.floor(n / 2);
        string += string;
    }while (n)
    return result;
}
function alignLeft(str, width) {
    var trimmed = str.trimRight();
    if (trimmed.length === 0 && str.length >= width) return str;
    var padding = '';
    var strWidth = stringWidth(trimmed);
    if (strWidth < width) {
        padding = createPadding(width - strWidth);
    }
    return trimmed + padding;
}
function alignRight(str, width) {
    var trimmed = str.trimLeft();
    if (trimmed.length === 0 && str.length >= width) return str;
    var padding = '';
    var strWidth = stringWidth(trimmed);
    if (strWidth < width) {
        padding = createPadding(width - strWidth);
    }
    return padding + trimmed;
}
function alignCenter(str, width) {
    var trimmed = str.trim();
    if (trimmed.length === 0 && str.length >= width) return str;
    var padLeft = '';
    var padRight = '';
    var strWidth = stringWidth(trimmed);
    if (strWidth < width) {
        var padLeftBy = parseInt((width - strWidth) / 2, 10);
        padLeft = createPadding(padLeftBy);
        padRight = createPadding(width - (strWidth + padLeftBy));
    }
    return padLeft + trimmed + padRight;
}
}}),
"[project]/node_modules/aproba/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = validate;
function isArguments(thingy) {
    return thingy != null && typeof thingy === 'object' && thingy.hasOwnProperty('callee');
}
const types = {
    '*': {
        label: 'any',
        check: ()=>true
    },
    A: {
        label: 'array',
        check: (_)=>Array.isArray(_) || isArguments(_)
    },
    S: {
        label: 'string',
        check: (_)=>typeof _ === 'string'
    },
    N: {
        label: 'number',
        check: (_)=>typeof _ === 'number'
    },
    F: {
        label: 'function',
        check: (_)=>typeof _ === 'function'
    },
    O: {
        label: 'object',
        check: (_)=>typeof _ === 'object' && _ != null && !types.A.check(_) && !types.E.check(_)
    },
    B: {
        label: 'boolean',
        check: (_)=>typeof _ === 'boolean'
    },
    E: {
        label: 'error',
        check: (_)=>_ instanceof Error
    },
    Z: {
        label: 'null',
        check: (_)=>_ == null
    }
};
function addSchema(schema, arity) {
    const group = arity[schema.length] = arity[schema.length] || [];
    if (group.indexOf(schema) === -1) group.push(schema);
}
function validate(rawSchemas, args) {
    if (arguments.length !== 2) throw wrongNumberOfArgs([
        'SA'
    ], arguments.length);
    if (!rawSchemas) throw missingRequiredArg(0, 'rawSchemas');
    if (!args) throw missingRequiredArg(1, 'args');
    if (!types.S.check(rawSchemas)) throw invalidType(0, [
        'string'
    ], rawSchemas);
    if (!types.A.check(args)) throw invalidType(1, [
        'array'
    ], args);
    const schemas = rawSchemas.split('|');
    const arity = {};
    schemas.forEach((schema)=>{
        for(let ii = 0; ii < schema.length; ++ii){
            const type = schema[ii];
            if (!types[type]) throw unknownType(ii, type);
        }
        if (/E.*E/.test(schema)) throw moreThanOneError(schema);
        addSchema(schema, arity);
        if (/E/.test(schema)) {
            addSchema(schema.replace(/E.*$/, 'E'), arity);
            addSchema(schema.replace(/E/, 'Z'), arity);
            if (schema.length === 1) addSchema('', arity);
        }
    });
    let matching = arity[args.length];
    if (!matching) {
        throw wrongNumberOfArgs(Object.keys(arity), args.length);
    }
    for(let ii = 0; ii < args.length; ++ii){
        let newMatching = matching.filter((schema)=>{
            const type = schema[ii];
            const typeCheck = types[type].check;
            return typeCheck(args[ii]);
        });
        if (!newMatching.length) {
            const labels = matching.map((_)=>types[_[ii]].label).filter((_)=>_ != null);
            throw invalidType(ii, labels, args[ii]);
        }
        matching = newMatching;
    }
}
function missingRequiredArg(num) {
    return newException('EMISSINGARG', 'Missing required argument #' + (num + 1));
}
function unknownType(num, type) {
    return newException('EUNKNOWNTYPE', 'Unknown type ' + type + ' in argument #' + (num + 1));
}
function invalidType(num, expectedTypes, value) {
    let valueType;
    Object.keys(types).forEach((typeCode)=>{
        if (types[typeCode].check(value)) valueType = types[typeCode].label;
    });
    return newException('EINVALIDTYPE', 'Argument #' + (num + 1) + ': Expected ' + englishList(expectedTypes) + ' but got ' + valueType);
}
function englishList(list) {
    return list.join(', ').replace(/, ([^,]+)$/, ' or $1');
}
function wrongNumberOfArgs(expected, got) {
    const english = englishList(expected);
    const args = expected.every((ex)=>ex.length === 1) ? 'argument' : 'arguments';
    return newException('EWRONGARGCOUNT', 'Expected ' + english + ' ' + args + ' but got ' + got);
}
function moreThanOneError(schema) {
    return newException('ETOOMANYERRORTYPES', 'Only one error type per argument signature is allowed, more than one found in "' + schema + '"');
}
function newException(code, msg) {
    const err = new Error(msg);
    err.code = code;
    /* istanbul ignore else */ if (Error.captureStackTrace) Error.captureStackTrace(err, validate);
    return err;
}
}}),
"[project]/node_modules/gauge/wide-truncate.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var stringWidth = __turbopack_context__.r("[project]/node_modules/string-width/index.js [app-client] (ecmascript)");
var stripAnsi = __turbopack_context__.r("[project]/node_modules/strip-ansi/index.js [app-client] (ecmascript)");
module.exports = wideTruncate;
function wideTruncate(str, target) {
    if (stringWidth(str) === 0) return str;
    if (target <= 0) return '';
    if (stringWidth(str) <= target) return str;
    // We compute the number of bytes of ansi sequences here and add
    // that to our initial truncation to ensure that we don't slice one
    // that we want to keep in half.
    var noAnsi = stripAnsi(str);
    var ansiSize = str.length + noAnsi.length;
    var truncated = str.slice(0, target + ansiSize);
    // we have to shrink the result to account for our ansi sequence buffer
    // (if an ansi sequence was truncated) and double width characters.
    while(stringWidth(truncated) > target){
        truncated = truncated.slice(0, -1);
    }
    return truncated;
}
}}),
"[project]/node_modules/gauge/error.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var util = __turbopack_context__.r("[project]/node_modules/util/util.js [app-client] (ecmascript)");
var User = exports.User = function User(msg) {
    var err = new Error(msg);
    Error.captureStackTrace(err, User);
    err.code = 'EGAUGE';
    return err;
};
exports.MissingTemplateValue = function MissingTemplateValue(item, values) {
    var err = new User(util.format('Missing template value "%s"', item.type));
    Error.captureStackTrace(err, MissingTemplateValue);
    err.template = item;
    err.values = values;
    return err;
};
exports.Internal = function Internal(msg) {
    var err = new Error(msg);
    Error.captureStackTrace(err, Internal);
    err.code = 'EGAUGEINTERNAL';
    return err;
};
}}),
"[project]/node_modules/gauge/template-item.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var stringWidth = __turbopack_context__.r("[project]/node_modules/string-width/index.js [app-client] (ecmascript)");
module.exports = TemplateItem;
function isPercent(num) {
    if (typeof num !== 'string') return false;
    return num.slice(-1) === '%';
}
function percent(num) {
    return Number(num.slice(0, -1)) / 100;
}
function TemplateItem(values, outputLength) {
    this.overallOutputLength = outputLength;
    this.finished = false;
    this.type = null;
    this.value = null;
    this.length = null;
    this.maxLength = null;
    this.minLength = null;
    this.kerning = null;
    this.align = 'left';
    this.padLeft = 0;
    this.padRight = 0;
    this.index = null;
    this.first = null;
    this.last = null;
    if (typeof values === 'string') {
        this.value = values;
    } else {
        for(var prop in values)this[prop] = values[prop];
    }
    // Realize percents
    if (isPercent(this.length)) {
        this.length = Math.round(this.overallOutputLength * percent(this.length));
    }
    if (isPercent(this.minLength)) {
        this.minLength = Math.round(this.overallOutputLength * percent(this.minLength));
    }
    if (isPercent(this.maxLength)) {
        this.maxLength = Math.round(this.overallOutputLength * percent(this.maxLength));
    }
    return this;
}
TemplateItem.prototype = {};
TemplateItem.prototype.getBaseLength = function() {
    var length = this.length;
    if (length == null && typeof this.value === 'string' && this.maxLength == null && this.minLength == null) {
        length = stringWidth(this.value);
    }
    return length;
};
TemplateItem.prototype.getLength = function() {
    var length = this.getBaseLength();
    if (length == null) return null;
    return length + this.padLeft + this.padRight;
};
TemplateItem.prototype.getMaxLength = function() {
    if (this.maxLength == null) return null;
    return this.maxLength + this.padLeft + this.padRight;
};
TemplateItem.prototype.getMinLength = function() {
    if (this.minLength == null) return null;
    return this.minLength + this.padLeft + this.padRight;
};
}}),
"[project]/node_modules/gauge/render-template.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var align = __turbopack_context__.r("[project]/node_modules/wide-align/align.js [app-client] (ecmascript)");
var validate = __turbopack_context__.r("[project]/node_modules/aproba/index.js [app-client] (ecmascript)");
var wideTruncate = __turbopack_context__.r("[project]/node_modules/gauge/wide-truncate.js [app-client] (ecmascript)");
var error = __turbopack_context__.r("[project]/node_modules/gauge/error.js [app-client] (ecmascript)");
var TemplateItem = __turbopack_context__.r("[project]/node_modules/gauge/template-item.js [app-client] (ecmascript)");
function renderValueWithValues(values) {
    return function(item) {
        return renderValue(item, values);
    };
}
var renderTemplate = module.exports = function(width, template, values) {
    var items = prepareItems(width, template, values);
    var rendered = items.map(renderValueWithValues(values)).join('');
    return align.left(wideTruncate(rendered, width), width);
};
function preType(item) {
    var cappedTypeName = item.type[0].toUpperCase() + item.type.slice(1);
    return 'pre' + cappedTypeName;
}
function postType(item) {
    var cappedTypeName = item.type[0].toUpperCase() + item.type.slice(1);
    return 'post' + cappedTypeName;
}
function hasPreOrPost(item, values) {
    if (!item.type) return;
    return values[preType(item)] || values[postType(item)];
}
function generatePreAndPost(baseItem, parentValues) {
    var item = Object.assign({}, baseItem);
    var values = Object.create(parentValues);
    var template = [];
    var pre = preType(item);
    var post = postType(item);
    if (values[pre]) {
        template.push({
            value: values[pre]
        });
        values[pre] = null;
    }
    item.minLength = null;
    item.length = null;
    item.maxLength = null;
    template.push(item);
    values[item.type] = values[item.type];
    if (values[post]) {
        template.push({
            value: values[post]
        });
        values[post] = null;
    }
    return function($1, $2, length) {
        return renderTemplate(length, template, values);
    };
}
function prepareItems(width, template, values) {
    function cloneAndObjectify(item, index, arr) {
        var cloned = new TemplateItem(item, width);
        var type = cloned.type;
        if (cloned.value == null) {
            if (!(type in values)) {
                if (cloned.default == null) {
                    throw new error.MissingTemplateValue(cloned, values);
                } else {
                    cloned.value = cloned.default;
                }
            } else {
                cloned.value = values[type];
            }
        }
        if (cloned.value == null || cloned.value === '') return null;
        cloned.index = index;
        cloned.first = index === 0;
        cloned.last = index === arr.length - 1;
        if (hasPreOrPost(cloned, values)) cloned.value = generatePreAndPost(cloned, values);
        return cloned;
    }
    var output = template.map(cloneAndObjectify).filter(function(item) {
        return item != null;
    });
    var remainingSpace = width;
    var variableCount = output.length;
    function consumeSpace(length) {
        if (length > remainingSpace) length = remainingSpace;
        remainingSpace -= length;
    }
    function finishSizing(item, length) {
        if (item.finished) throw new error.Internal('Tried to finish template item that was already finished');
        if (length === Infinity) throw new error.Internal('Length of template item cannot be infinity');
        if (length != null) item.length = length;
        item.minLength = null;
        item.maxLength = null;
        --variableCount;
        item.finished = true;
        if (item.length == null) item.length = item.getBaseLength();
        if (item.length == null) throw new error.Internal('Finished template items must have a length');
        consumeSpace(item.getLength());
    }
    output.forEach(function(item) {
        if (!item.kerning) return;
        var prevPadRight = item.first ? 0 : output[item.index - 1].padRight;
        if (!item.first && prevPadRight < item.kerning) item.padLeft = item.kerning - prevPadRight;
        if (!item.last) item.padRight = item.kerning;
    });
    // Finish any that have a fixed (literal or intuited) length
    output.forEach(function(item) {
        if (item.getBaseLength() == null) return;
        finishSizing(item);
    });
    var resized = 0;
    var resizing;
    var hunkSize;
    do {
        resizing = false;
        hunkSize = Math.round(remainingSpace / variableCount);
        output.forEach(function(item) {
            if (item.finished) return;
            if (!item.maxLength) return;
            if (item.getMaxLength() < hunkSize) {
                finishSizing(item, item.maxLength);
                resizing = true;
            }
        });
    }while (resizing && resized++ < output.length)
    if (resizing) throw new error.Internal('Resize loop iterated too many times while determining maxLength');
    resized = 0;
    do {
        resizing = false;
        hunkSize = Math.round(remainingSpace / variableCount);
        output.forEach(function(item) {
            if (item.finished) return;
            if (!item.minLength) return;
            if (item.getMinLength() >= hunkSize) {
                finishSizing(item, item.minLength);
                resizing = true;
            }
        });
    }while (resizing && resized++ < output.length)
    if (resizing) throw new error.Internal('Resize loop iterated too many times while determining minLength');
    hunkSize = Math.round(remainingSpace / variableCount);
    output.forEach(function(item) {
        if (item.finished) return;
        finishSizing(item, hunkSize);
    });
    return output;
}
function renderFunction(item, values, length) {
    validate('OON', arguments);
    if (item.type) {
        return item.value(values, values[item.type + 'Theme'] || {}, length);
    } else {
        return item.value(values, {}, length);
    }
}
function renderValue(item, values) {
    var length = item.getBaseLength();
    var value = typeof item.value === 'function' ? renderFunction(item, values, length) : item.value;
    if (value == null || value === '') return '';
    var alignWith = align[item.align] || align.left;
    var leftPadding = item.padLeft ? align.left('', item.padLeft) : '';
    var rightPadding = item.padRight ? align.right('', item.padRight) : '';
    var truncated = wideTruncate(String(value), length);
    var aligned = alignWith(truncated, length);
    return leftPadding + aligned + rightPadding;
}
}}),
"[project]/node_modules/gauge/plumbing.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var consoleControl = __turbopack_context__.r("[project]/node_modules/console-control-strings/index.js [app-client] (ecmascript)");
var renderTemplate = __turbopack_context__.r("[project]/node_modules/gauge/render-template.js [app-client] (ecmascript)");
var validate = __turbopack_context__.r("[project]/node_modules/aproba/index.js [app-client] (ecmascript)");
var Plumbing = module.exports = function(theme, template, width) {
    if (!width) width = 80;
    validate('OAN', [
        theme,
        template,
        width
    ]);
    this.showing = false;
    this.theme = theme;
    this.width = width;
    this.template = template;
};
Plumbing.prototype = {};
Plumbing.prototype.setTheme = function(theme) {
    validate('O', [
        theme
    ]);
    this.theme = theme;
};
Plumbing.prototype.setTemplate = function(template) {
    validate('A', [
        template
    ]);
    this.template = template;
};
Plumbing.prototype.setWidth = function(width) {
    validate('N', [
        width
    ]);
    this.width = width;
};
Plumbing.prototype.hide = function() {
    return consoleControl.gotoSOL() + consoleControl.eraseLine();
};
Plumbing.prototype.hideCursor = consoleControl.hideCursor;
Plumbing.prototype.showCursor = consoleControl.showCursor;
Plumbing.prototype.show = function(status) {
    var values = Object.create(this.theme);
    for(var key in status){
        values[key] = status[key];
    }
    return renderTemplate(this.width, this.template, values).trim() + consoleControl.color('reset') + consoleControl.eraseLine() + consoleControl.gotoSOL();
};
}}),
"[project]/node_modules/gauge/has-color.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var colorSupport = __turbopack_context__.r("[project]/node_modules/color-support/browser.js [app-client] (ecmascript)");
module.exports = colorSupport().hasBasic;
}}),
"[project]/node_modules/gauge/spin.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = function spin(spinstr, spun) {
    return spinstr[spun % spinstr.length];
};
}}),
"[project]/node_modules/gauge/progress-bar.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var validate = __turbopack_context__.r("[project]/node_modules/aproba/index.js [app-client] (ecmascript)");
var renderTemplate = __turbopack_context__.r("[project]/node_modules/gauge/render-template.js [app-client] (ecmascript)");
var wideTruncate = __turbopack_context__.r("[project]/node_modules/gauge/wide-truncate.js [app-client] (ecmascript)");
var stringWidth = __turbopack_context__.r("[project]/node_modules/string-width/index.js [app-client] (ecmascript)");
module.exports = function(theme, width, completed) {
    validate('ONN', [
        theme,
        width,
        completed
    ]);
    if (completed < 0) completed = 0;
    if (completed > 1) completed = 1;
    if (width <= 0) return '';
    var sofar = Math.round(width * completed);
    var rest = width - sofar;
    var template = [
        {
            type: 'complete',
            value: repeat(theme.complete, sofar),
            length: sofar
        },
        {
            type: 'remaining',
            value: repeat(theme.remaining, rest),
            length: rest
        }
    ];
    return renderTemplate(width, template, theme);
};
// lodash's way of repeating
function repeat(string, width) {
    var result = '';
    var n = width;
    do {
        if (n % 2) {
            result += string;
        }
        n = Math.floor(n / 2);
        /* eslint no-self-assign: 0 */ string += string;
    }while (n && stringWidth(result) < width)
    return wideTruncate(result, width);
}
}}),
"[project]/node_modules/gauge/base-theme.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var spin = __turbopack_context__.r("[project]/node_modules/gauge/spin.js [app-client] (ecmascript)");
var progressBar = __turbopack_context__.r("[project]/node_modules/gauge/progress-bar.js [app-client] (ecmascript)");
module.exports = {
    activityIndicator: function(values, theme, width) {
        if (values.spun == null) return;
        return spin(theme, values.spun);
    },
    progressbar: function(values, theme, width) {
        if (values.completed == null) return;
        return progressBar(theme, width, values.completed);
    }
};
}}),
"[project]/node_modules/gauge/theme-set.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
var objectAssign = __turbopack_context__.r("[project]/node_modules/next/dist/build/polyfills/object-assign.js [app-client] (ecmascript)");
module.exports = function() {
    return ThemeSetProto.newThemeSet();
};
var ThemeSetProto = {};
ThemeSetProto.baseTheme = __turbopack_context__.r("[project]/node_modules/gauge/base-theme.js [app-client] (ecmascript)");
ThemeSetProto.newTheme = function(parent, theme) {
    if (!theme) {
        theme = parent;
        parent = this.baseTheme;
    }
    return objectAssign({}, parent, theme);
};
ThemeSetProto.getThemeNames = function() {
    return Object.keys(this.themes);
};
ThemeSetProto.addTheme = function(name, parent, theme) {
    this.themes[name] = this.newTheme(parent, theme);
};
ThemeSetProto.addToAllThemes = function(theme) {
    var themes = this.themes;
    Object.keys(themes).forEach(function(name) {
        objectAssign(themes[name], theme);
    });
    objectAssign(this.baseTheme, theme);
};
ThemeSetProto.getTheme = function(name) {
    if (!this.themes[name]) throw this.newMissingThemeError(name);
    return this.themes[name];
};
ThemeSetProto.setDefault = function(opts, name) {
    if (name == null) {
        name = opts;
        opts = {};
    }
    var platform = opts.platform == null ? 'fallback' : opts.platform;
    var hasUnicode = !!opts.hasUnicode;
    var hasColor = !!opts.hasColor;
    if (!this.defaults[platform]) this.defaults[platform] = {
        true: {},
        false: {}
    };
    this.defaults[platform][hasUnicode][hasColor] = name;
};
ThemeSetProto.getDefault = function(opts) {
    if (!opts) opts = {};
    var platformName = opts.platform || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform;
    var platform = this.defaults[platformName] || this.defaults.fallback;
    var hasUnicode = !!opts.hasUnicode;
    var hasColor = !!opts.hasColor;
    if (!platform) throw this.newMissingDefaultThemeError(platformName, hasUnicode, hasColor);
    if (!platform[hasUnicode][hasColor]) {
        if (hasUnicode && hasColor && platform[!hasUnicode][hasColor]) {
            hasUnicode = false;
        } else if (hasUnicode && hasColor && platform[hasUnicode][!hasColor]) {
            hasColor = false;
        } else if (hasUnicode && hasColor && platform[!hasUnicode][!hasColor]) {
            hasUnicode = false;
            hasColor = false;
        } else if (hasUnicode && !hasColor && platform[!hasUnicode][hasColor]) {
            hasUnicode = false;
        } else if (!hasUnicode && hasColor && platform[hasUnicode][!hasColor]) {
            hasColor = false;
        } else if (platform === this.defaults.fallback) {
            throw this.newMissingDefaultThemeError(platformName, hasUnicode, hasColor);
        }
    }
    if (platform[hasUnicode][hasColor]) {
        return this.getTheme(platform[hasUnicode][hasColor]);
    } else {
        return this.getDefault(objectAssign({}, opts, {
            platform: 'fallback'
        }));
    }
};
ThemeSetProto.newMissingThemeError = function newMissingThemeError(name) {
    var err = new Error('Could not find a gauge theme named "' + name + '"');
    Error.captureStackTrace.call(err, newMissingThemeError);
    err.theme = name;
    err.code = 'EMISSINGTHEME';
    return err;
};
ThemeSetProto.newMissingDefaultThemeError = function newMissingDefaultThemeError(platformName, hasUnicode, hasColor) {
    var err = new Error('Could not find a gauge theme for your platform/unicode/color use combo:\n' + '    platform = ' + platformName + '\n' + '    hasUnicode = ' + hasUnicode + '\n' + '    hasColor = ' + hasColor);
    Error.captureStackTrace.call(err, newMissingDefaultThemeError);
    err.platform = platformName;
    err.hasUnicode = hasUnicode;
    err.hasColor = hasColor;
    err.code = 'EMISSINGTHEME';
    return err;
};
ThemeSetProto.newThemeSet = function() {
    var themeset = function(opts) {
        return themeset.getDefault(opts);
    };
    return objectAssign(themeset, ThemeSetProto, {
        themes: objectAssign({}, this.themes),
        baseTheme: objectAssign({}, this.baseTheme),
        defaults: JSON.parse(JSON.stringify(this.defaults || {}))
    });
};
}}),
"[project]/node_modules/gauge/themes.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var color = __turbopack_context__.r("[project]/node_modules/console-control-strings/index.js [app-client] (ecmascript)").color;
var ThemeSet = __turbopack_context__.r("[project]/node_modules/gauge/theme-set.js [app-client] (ecmascript)");
var themes = module.exports = new ThemeSet();
themes.addTheme('ASCII', {
    preProgressbar: '[',
    postProgressbar: ']',
    progressbarTheme: {
        complete: '#',
        remaining: '.'
    },
    activityIndicatorTheme: '-\\|/',
    preSubsection: '>'
});
themes.addTheme('colorASCII', themes.getTheme('ASCII'), {
    progressbarTheme: {
        preComplete: color('bgBrightWhite', 'brightWhite'),
        complete: '#',
        postComplete: color('reset'),
        preRemaining: color('bgBrightBlack', 'brightBlack'),
        remaining: '.',
        postRemaining: color('reset')
    }
});
themes.addTheme('brailleSpinner', {
    preProgressbar: '⸨',
    postProgressbar: '⸩',
    progressbarTheme: {
        complete: '#',
        remaining: '⠂'
    },
    activityIndicatorTheme: '⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏',
    preSubsection: '>'
});
themes.addTheme('colorBrailleSpinner', themes.getTheme('brailleSpinner'), {
    progressbarTheme: {
        preComplete: color('bgBrightWhite', 'brightWhite'),
        complete: '#',
        postComplete: color('reset'),
        preRemaining: color('bgBrightBlack', 'brightBlack'),
        remaining: '⠂',
        postRemaining: color('reset')
    }
});
themes.setDefault({}, 'ASCII');
themes.setDefault({
    hasColor: true
}, 'colorASCII');
themes.setDefault({
    platform: 'darwin',
    hasUnicode: true
}, 'brailleSpinner');
themes.setDefault({
    platform: 'darwin',
    hasUnicode: true,
    hasColor: true
}, 'colorBrailleSpinner');
themes.setDefault({
    platform: 'linux',
    hasUnicode: true
}, 'brailleSpinner');
themes.setDefault({
    platform: 'linux',
    hasUnicode: true,
    hasColor: true
}, 'colorBrailleSpinner');
}}),
"[project]/node_modules/gauge/set-interval.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
// this exists so we can replace it during testing
module.exports = setInterval;
}}),
"[project]/node_modules/gauge/process.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
// this exists so we can replace it during testing
module.exports = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
}}),
"[project]/node_modules/gauge/set-immediate.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var process = __turbopack_context__.r("[project]/node_modules/gauge/process.js [app-client] (ecmascript)");
try {
    module.exports = setImmediate;
} catch (ex) {
    module.exports = process.nextTick;
}
}}),
"[project]/node_modules/gauge/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var Plumbing = __turbopack_context__.r("[project]/node_modules/gauge/plumbing.js [app-client] (ecmascript)");
var hasUnicode = __turbopack_context__.r("[project]/node_modules/has-unicode/index.js [app-client] (ecmascript)");
var hasColor = __turbopack_context__.r("[project]/node_modules/gauge/has-color.js [app-client] (ecmascript)");
var onExit = __turbopack_context__.r("[project]/node_modules/signal-exit/index.js [app-client] (ecmascript)");
var defaultThemes = __turbopack_context__.r("[project]/node_modules/gauge/themes.js [app-client] (ecmascript)");
var setInterval = __turbopack_context__.r("[project]/node_modules/gauge/set-interval.js [app-client] (ecmascript)");
var process = __turbopack_context__.r("[project]/node_modules/gauge/process.js [app-client] (ecmascript)");
var setImmediate = __turbopack_context__.r("[project]/node_modules/gauge/set-immediate.js [app-client] (ecmascript)");
module.exports = Gauge;
function callWith(obj, method) {
    return function() {
        return method.call(obj);
    };
}
function Gauge(arg1, arg2) {
    var options, writeTo;
    if (arg1 && arg1.write) {
        writeTo = arg1;
        options = arg2 || {};
    } else if (arg2 && arg2.write) {
        writeTo = arg2;
        options = arg1 || {};
    } else {
        writeTo = process.stderr;
        options = arg1 || arg2 || {};
    }
    this._status = {
        spun: 0,
        section: '',
        subsection: ''
    };
    this._paused = false // are we paused for back pressure?
    ;
    this._disabled = true // are all progress bar updates disabled?
    ;
    this._showing = false // do we WANT the progress bar on screen
    ;
    this._onScreen = false // IS the progress bar on screen
    ;
    this._needsRedraw = false // should we print something at next tick?
    ;
    this._hideCursor = options.hideCursor == null ? true : options.hideCursor;
    this._fixedFramerate = options.fixedFramerate == null ? !/^v0\.8\./.test(process.version) : options.fixedFramerate;
    this._lastUpdateAt = null;
    this._updateInterval = options.updateInterval == null ? 50 : options.updateInterval;
    this._themes = options.themes || defaultThemes;
    this._theme = options.theme;
    var theme = this._computeTheme(options.theme);
    var template = options.template || [
        {
            type: 'progressbar',
            length: 20
        },
        {
            type: 'activityIndicator',
            kerning: 1,
            length: 1
        },
        {
            type: 'section',
            kerning: 1,
            default: ''
        },
        {
            type: 'subsection',
            kerning: 1,
            default: ''
        }
    ];
    this.setWriteTo(writeTo, options.tty);
    var PlumbingClass = options.Plumbing || Plumbing;
    this._gauge = new PlumbingClass(theme, template, this.getWidth());
    this._$$doRedraw = callWith(this, this._doRedraw);
    this._$$handleSizeChange = callWith(this, this._handleSizeChange);
    this._cleanupOnExit = options.cleanupOnExit == null || options.cleanupOnExit;
    this._removeOnExit = null;
    if (options.enabled || options.enabled == null && this._tty && this._tty.isTTY) {
        this.enable();
    } else {
        this.disable();
    }
}
Gauge.prototype = {};
Gauge.prototype.isEnabled = function() {
    return !this._disabled;
};
Gauge.prototype.setTemplate = function(template) {
    this._gauge.setTemplate(template);
    if (this._showing) this._requestRedraw();
};
Gauge.prototype._computeTheme = function(theme) {
    if (!theme) theme = {};
    if (typeof theme === 'string') {
        theme = this._themes.getTheme(theme);
    } else if (theme && (Object.keys(theme).length === 0 || theme.hasUnicode != null || theme.hasColor != null)) {
        var useUnicode = theme.hasUnicode == null ? hasUnicode() : theme.hasUnicode;
        var useColor = theme.hasColor == null ? hasColor : theme.hasColor;
        theme = this._themes.getDefault({
            hasUnicode: useUnicode,
            hasColor: useColor,
            platform: theme.platform
        });
    }
    return theme;
};
Gauge.prototype.setThemeset = function(themes) {
    this._themes = themes;
    this.setTheme(this._theme);
};
Gauge.prototype.setTheme = function(theme) {
    this._gauge.setTheme(this._computeTheme(theme));
    if (this._showing) this._requestRedraw();
    this._theme = theme;
};
Gauge.prototype._requestRedraw = function() {
    this._needsRedraw = true;
    if (!this._fixedFramerate) this._doRedraw();
};
Gauge.prototype.getWidth = function() {
    return (this._tty && this._tty.columns || 80) - 1;
};
Gauge.prototype.setWriteTo = function(writeTo, tty) {
    var enabled = !this._disabled;
    if (enabled) this.disable();
    this._writeTo = writeTo;
    this._tty = tty || writeTo === process.stderr && process.stdout.isTTY && process.stdout || writeTo.isTTY && writeTo || this._tty;
    if (this._gauge) this._gauge.setWidth(this.getWidth());
    if (enabled) this.enable();
};
Gauge.prototype.enable = function() {
    if (!this._disabled) return;
    this._disabled = false;
    if (this._tty) this._enableEvents();
    if (this._showing) this.show();
};
Gauge.prototype.disable = function() {
    if (this._disabled) return;
    if (this._showing) {
        this._lastUpdateAt = null;
        this._showing = false;
        this._doRedraw();
        this._showing = true;
    }
    this._disabled = true;
    if (this._tty) this._disableEvents();
};
Gauge.prototype._enableEvents = function() {
    if (this._cleanupOnExit) {
        this._removeOnExit = onExit(callWith(this, this.disable));
    }
    this._tty.on('resize', this._$$handleSizeChange);
    if (this._fixedFramerate) {
        this.redrawTracker = setInterval(this._$$doRedraw, this._updateInterval);
        if (this.redrawTracker.unref) this.redrawTracker.unref();
    }
};
Gauge.prototype._disableEvents = function() {
    this._tty.removeListener('resize', this._$$handleSizeChange);
    if (this._fixedFramerate) clearInterval(this.redrawTracker);
    if (this._removeOnExit) this._removeOnExit();
};
Gauge.prototype.hide = function(cb) {
    if (this._disabled) return cb && process.nextTick(cb);
    if (!this._showing) return cb && process.nextTick(cb);
    this._showing = false;
    this._doRedraw();
    cb && setImmediate(cb);
};
Gauge.prototype.show = function(section, completed) {
    this._showing = true;
    if (typeof section === 'string') {
        this._status.section = section;
    } else if (typeof section === 'object') {
        var sectionKeys = Object.keys(section);
        for(var ii = 0; ii < sectionKeys.length; ++ii){
            var key = sectionKeys[ii];
            this._status[key] = section[key];
        }
    }
    if (completed != null) this._status.completed = completed;
    if (this._disabled) return;
    this._requestRedraw();
};
Gauge.prototype.pulse = function(subsection) {
    this._status.subsection = subsection || '';
    this._status.spun++;
    if (this._disabled) return;
    if (!this._showing) return;
    this._requestRedraw();
};
Gauge.prototype._handleSizeChange = function() {
    this._gauge.setWidth(this._tty.columns - 1);
    this._requestRedraw();
};
Gauge.prototype._doRedraw = function() {
    if (this._disabled || this._paused) return;
    if (!this._fixedFramerate) {
        var now = Date.now();
        if (this._lastUpdateAt && now - this._lastUpdateAt < this._updateInterval) return;
        this._lastUpdateAt = now;
    }
    if (!this._showing && this._onScreen) {
        this._onScreen = false;
        var result = this._gauge.hide();
        if (this._hideCursor) {
            result += this._gauge.showCursor();
        }
        return this._writeTo.write(result);
    }
    if (!this._showing && !this._onScreen) return;
    if (this._showing && !this._onScreen) {
        this._onScreen = true;
        this._needsRedraw = true;
        if (this._hideCursor) {
            this._writeTo.write(this._gauge.hideCursor());
        }
    }
    if (!this._needsRedraw) return;
    if (!this._writeTo.write(this._gauge.show(this._status))) {
        this._paused = true;
        this._writeTo.on('drain', callWith(this, function() {
            this._paused = false;
            this._doRedraw();
        }));
    }
};
}}),
"[project]/node_modules/has-unicode/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
var os = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/os-browserify/browser.js [app-client] (ecmascript)");
var hasUnicode = module.exports = function() {
    // Recent Win32 platforms (>XP) CAN support unicode in the console but
    // don't have to, and in non-english locales often use traditional local
    // code pages. There's no way, short of windows system calls or execing
    // the chcp command line program to figure this out. As such, we default
    // this to false and encourage your users to override it via config if
    // appropriate.
    if (os.type() == "Windows_NT") {
        return false;
    }
    var isUTF8 = /UTF-?8$/i;
    var ctype = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.LC_ALL || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.LC_CTYPE || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.LANG;
    return isUTF8.test(ctype);
};
}}),
"[project]/node_modules/color-support/browser.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = colorSupport({
    alwaysReturn: true
}, colorSupport);
function colorSupport(options, obj) {
    obj = obj || {};
    options = options || {};
    obj.level = 0;
    obj.hasBasic = false;
    obj.has256 = false;
    obj.has16m = false;
    if (!options.alwaysReturn) {
        return false;
    }
    return obj;
}
}}),
"[project]/node_modules/signal-exit/signals.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// This is not the set of all possible signals.
//
// It IS, however, the set of all signals that trigger
// an exit on either Linux or BSD systems.  Linux is a
// superset of the signal names supported on BSD, and
// the unknown signals just fail to register, so we can
// catch that easily enough.
//
// Don't bother with SIGKILL.  It's uncatchable, which
// means that we can't fire any callbacks anyway.
//
// If a user does happen to register a handler on a non-
// fatal signal like SIGWINCH or something, and then
// exit, it'll end up firing `process.emit('exit')`, so
// the handler will be fired anyway.
//
// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised
// artificially, inherently leave the process in a
// state from which it is not safe to try and enter JS
// listeners.
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
module.exports = [
    'SIGABRT',
    'SIGALRM',
    'SIGHUP',
    'SIGINT',
    'SIGTERM'
];
if ("TURBOPACK compile-time truthy", 1) {
    module.exports.push('SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT');
}
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
}
}}),
"[project]/node_modules/signal-exit/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Note: since nyc uses this module to output coverage, any lines
// that are in the direct sync flow of nyc's outputCoverage are
// ignored, since we can never get coverage for them.
// grab a reference to node's real process object right away
var process = global.process;
const processOk = function(process) {
    return process && typeof process === 'object' && typeof process.removeListener === 'function' && typeof process.emit === 'function' && typeof process.reallyExit === 'function' && typeof process.listeners === 'function' && typeof process.kill === 'function' && typeof process.pid === 'number' && typeof process.on === 'function';
};
// some kind of non-node environment, just no-op
/* istanbul ignore if */ if (!processOk(process)) {
    module.exports = function() {
        return function() {};
    };
} else {
    var assert = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/assert/assert.js [app-client] (ecmascript)");
    var signals = __turbopack_context__.r("[project]/node_modules/signal-exit/signals.js [app-client] (ecmascript)");
    var isWin = /^win/i.test(process.platform);
    var EE = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)");
    /* istanbul ignore if */ if (typeof EE !== 'function') {
        EE = EE.EventEmitter;
    }
    var emitter;
    if (process.__signal_exit_emitter__) {
        emitter = process.__signal_exit_emitter__;
    } else {
        emitter = process.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
    }
    // Because this emitter is a global, we have to check to see if a
    // previous version of this library failed to enable infinite listeners.
    // I know what you're about to say.  But literally everything about
    // signal-exit is a compromise with evil.  Get used to it.
    if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
    }
    module.exports = function(cb, opts) {
        /* istanbul ignore if */ if (!processOk(global.process)) {
            return function() {};
        }
        assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler');
        if (loaded === false) {
            load();
        }
        var ev = 'exit';
        if (opts && opts.alwaysLast) {
            ev = 'afterexit';
        }
        var remove = function() {
            emitter.removeListener(ev, cb);
            if (emitter.listeners('exit').length === 0 && emitter.listeners('afterexit').length === 0) {
                unload();
            }
        };
        emitter.on(ev, cb);
        return remove;
    };
    var unload = function unload() {
        if (!loaded || !processOk(global.process)) {
            return;
        }
        loaded = false;
        signals.forEach(function(sig) {
            try {
                process.removeListener(sig, sigListeners[sig]);
            } catch (er) {}
        });
        process.emit = originalProcessEmit;
        process.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
    };
    module.exports.unload = unload;
    var emit = function emit(event, code, signal) {
        /* istanbul ignore if */ if (emitter.emitted[event]) {
            return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
    };
    // { <signal>: <listener fn>, ... }
    var sigListeners = {};
    signals.forEach(function(sig) {
        sigListeners[sig] = function listener() {
            /* istanbul ignore if */ if (!processOk(global.process)) {
                return;
            }
            // If there are no other listeners, an exit is coming!
            // Simplest way: remove us and then re-send the signal.
            // We know that this will kill the process, so we can
            // safely emit now.
            var listeners = process.listeners(sig);
            if (listeners.length === emitter.count) {
                unload();
                emit('exit', null, sig);
                /* istanbul ignore next */ emit('afterexit', null, sig);
                /* istanbul ignore next */ if (isWin && sig === 'SIGHUP') {
                    // "SIGHUP" throws an `ENOSYS` error on Windows,
                    // so use a supported signal instead
                    sig = 'SIGINT';
                }
                /* istanbul ignore next */ process.kill(process.pid, sig);
            }
        };
    });
    module.exports.signals = function() {
        return signals;
    };
    var loaded = false;
    var load = function load() {
        if (loaded || !processOk(global.process)) {
            return;
        }
        loaded = true;
        // This is the number of onSignalExit's that are in play.
        // It's important so that we can count the correct number of
        // listeners on signals, and don't wait for the other one to
        // handle it instead of us.
        emitter.count += 1;
        signals = signals.filter(function(sig) {
            try {
                process.on(sig, sigListeners[sig]);
                return true;
            } catch (er) {
                return false;
            }
        });
        process.emit = processEmit;
        process.reallyExit = processReallyExit;
    };
    module.exports.load = load;
    var originalProcessReallyExit = process.reallyExit;
    var processReallyExit = function processReallyExit(code) {
        /* istanbul ignore if */ if (!processOk(global.process)) {
            return;
        }
        process.exitCode = code || /* istanbul ignore next */ 0;
        emit('exit', process.exitCode, null);
        /* istanbul ignore next */ emit('afterexit', process.exitCode, null);
        /* istanbul ignore next */ originalProcessReallyExit.call(process, process.exitCode);
    };
    var originalProcessEmit = process.emit;
    var processEmit = function processEmit(ev, arg) {
        if (ev === 'exit' && processOk(global.process)) {
            /* istanbul ignore else */ if (arg !== undefined) {
                process.exitCode = arg;
            }
            var ret = originalProcessEmit.apply(this, arguments);
            /* istanbul ignore next */ emit('exit', process.exitCode, null);
            /* istanbul ignore next */ emit('afterexit', process.exitCode, null);
            /* istanbul ignore next */ return ret;
        } else {
            return originalProcessEmit.apply(this, arguments);
        }
    };
}
}}),
"[project]/node_modules/set-blocking/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
module.exports = function(blocking) {
    [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].stdout,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].stderr
    ].forEach(function(stream) {
        if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === 'function') {
            stream._handle.setBlocking(blocking);
        }
    });
};
}}),
"[project]/node_modules/npmlog/log.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
var Progress = __turbopack_context__.r("[project]/node_modules/are-we-there-yet/lib/index.js [app-client] (ecmascript)");
var Gauge = __turbopack_context__.r("[project]/node_modules/gauge/index.js [app-client] (ecmascript)");
var EE = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)").EventEmitter;
var log = exports = module.exports = new EE();
var util = __turbopack_context__.r("[project]/node_modules/util/util.js [app-client] (ecmascript)");
var setBlocking = __turbopack_context__.r("[project]/node_modules/set-blocking/index.js [app-client] (ecmascript)");
var consoleControl = __turbopack_context__.r("[project]/node_modules/console-control-strings/index.js [app-client] (ecmascript)");
setBlocking(true);
var stream = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].stderr;
Object.defineProperty(log, 'stream', {
    set: function(newStream) {
        stream = newStream;
        if (this.gauge) {
            this.gauge.setWriteTo(stream, stream);
        }
    },
    get: function() {
        return stream;
    }
});
// by default, decide based on tty-ness.
var colorEnabled;
log.useColor = function() {
    return colorEnabled != null ? colorEnabled : stream.isTTY;
};
log.enableColor = function() {
    colorEnabled = true;
    this.gauge.setTheme({
        hasColor: colorEnabled,
        hasUnicode: unicodeEnabled
    });
};
log.disableColor = function() {
    colorEnabled = false;
    this.gauge.setTheme({
        hasColor: colorEnabled,
        hasUnicode: unicodeEnabled
    });
};
// default level
log.level = 'info';
log.gauge = new Gauge(stream, {
    enabled: false,
    theme: {
        hasColor: log.useColor()
    },
    template: [
        {
            type: 'progressbar',
            length: 20
        },
        {
            type: 'activityIndicator',
            kerning: 1,
            length: 1
        },
        {
            type: 'section',
            default: ''
        },
        ':',
        {
            type: 'logline',
            kerning: 1,
            default: ''
        }
    ]
});
log.tracker = new Progress.TrackerGroup();
// we track this separately as we may need to temporarily disable the
// display of the status bar for our own loggy purposes.
log.progressEnabled = log.gauge.isEnabled();
var unicodeEnabled;
log.enableUnicode = function() {
    unicodeEnabled = true;
    this.gauge.setTheme({
        hasColor: this.useColor(),
        hasUnicode: unicodeEnabled
    });
};
log.disableUnicode = function() {
    unicodeEnabled = false;
    this.gauge.setTheme({
        hasColor: this.useColor(),
        hasUnicode: unicodeEnabled
    });
};
log.setGaugeThemeset = function(themes) {
    this.gauge.setThemeset(themes);
};
log.setGaugeTemplate = function(template) {
    this.gauge.setTemplate(template);
};
log.enableProgress = function() {
    if (this.progressEnabled) {
        return;
    }
    this.progressEnabled = true;
    this.tracker.on('change', this.showProgress);
    if (this._paused) {
        return;
    }
    this.gauge.enable();
};
log.disableProgress = function() {
    if (!this.progressEnabled) {
        return;
    }
    this.progressEnabled = false;
    this.tracker.removeListener('change', this.showProgress);
    this.gauge.disable();
};
var trackerConstructors = [
    'newGroup',
    'newItem',
    'newStream'
];
var mixinLog = function(tracker) {
    // mixin the public methods from log into the tracker
    // (except: conflicts and one's we handle specially)
    Object.keys(log).forEach(function(P) {
        if (P[0] === '_') {
            return;
        }
        if (trackerConstructors.filter(function(C) {
            return C === P;
        }).length) {
            return;
        }
        if (tracker[P]) {
            return;
        }
        if (typeof log[P] !== 'function') {
            return;
        }
        var func = log[P];
        tracker[P] = function() {
            return func.apply(log, arguments);
        };
    });
    // if the new tracker is a group, make sure any subtrackers get
    // mixed in too
    if (tracker instanceof Progress.TrackerGroup) {
        trackerConstructors.forEach(function(C) {
            var func = tracker[C];
            tracker[C] = function() {
                return mixinLog(func.apply(tracker, arguments));
            };
        });
    }
    return tracker;
};
// Add tracker constructors to the top level log object
trackerConstructors.forEach(function(C) {
    log[C] = function() {
        return mixinLog(this.tracker[C].apply(this.tracker, arguments));
    };
});
log.clearProgress = function(cb) {
    if (!this.progressEnabled) {
        return cb && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(cb);
    }
    this.gauge.hide(cb);
};
log.showProgress = (function(name, completed) {
    if (!this.progressEnabled) {
        return;
    }
    var values = {};
    if (name) {
        values.section = name;
    }
    var last = log.record[log.record.length - 1];
    if (last) {
        values.subsection = last.prefix;
        var disp = log.disp[last.level] || last.level;
        var logline = this._format(disp, log.style[last.level]);
        if (last.prefix) {
            logline += ' ' + this._format(last.prefix, this.prefixStyle);
        }
        logline += ' ' + last.message.split(/\r?\n/)[0];
        values.logline = logline;
    }
    values.completed = completed || this.tracker.completed();
    this.gauge.show(values);
}).bind(log) // bind for use in tracker's on-change listener
;
// temporarily stop emitting, but don't drop
log.pause = function() {
    this._paused = true;
    if (this.progressEnabled) {
        this.gauge.disable();
    }
};
log.resume = function() {
    if (!this._paused) {
        return;
    }
    this._paused = false;
    var b = this._buffer;
    this._buffer = [];
    b.forEach(function(m) {
        this.emitLog(m);
    }, this);
    if (this.progressEnabled) {
        this.gauge.enable();
    }
};
log._buffer = [];
var id = 0;
log.record = [];
log.maxRecordSize = 10000;
log.log = (function(lvl, prefix, message) {
    var l = this.levels[lvl];
    if (l === undefined) {
        return this.emit('error', new Error(util.format('Undefined log level: %j', lvl)));
    }
    var a = new Array(arguments.length - 2);
    var stack = null;
    for(var i = 2; i < arguments.length; i++){
        var arg = a[i - 2] = arguments[i];
        // resolve stack traces to a plain string.
        if (typeof arg === 'object' && arg instanceof Error && arg.stack) {
            Object.defineProperty(arg, 'stack', {
                value: stack = arg.stack + '',
                enumerable: true,
                writable: true
            });
        }
    }
    if (stack) {
        a.unshift(stack + '\n');
    }
    message = util.format.apply(util, a);
    var m = {
        id: id++,
        level: lvl,
        prefix: String(prefix || ''),
        message: message,
        messageRaw: a
    };
    this.emit('log', m);
    this.emit('log.' + lvl, m);
    if (m.prefix) {
        this.emit(m.prefix, m);
    }
    this.record.push(m);
    var mrs = this.maxRecordSize;
    var n = this.record.length - mrs;
    if (n > mrs / 10) {
        var newSize = Math.floor(mrs * 0.9);
        this.record = this.record.slice(-1 * newSize);
    }
    this.emitLog(m);
}).bind(log);
log.emitLog = function(m) {
    if (this._paused) {
        this._buffer.push(m);
        return;
    }
    if (this.progressEnabled) {
        this.gauge.pulse(m.prefix);
    }
    var l = this.levels[m.level];
    if (l === undefined) {
        return;
    }
    if (l < this.levels[this.level]) {
        return;
    }
    if (l > 0 && !isFinite(l)) {
        return;
    }
    // If 'disp' is null or undefined, use the lvl as a default
    // Allows: '', 0 as valid disp
    var disp = log.disp[m.level] != null ? log.disp[m.level] : m.level;
    this.clearProgress();
    m.message.split(/\r?\n/).forEach(function(line) {
        if (this.heading) {
            this.write(this.heading, this.headingStyle);
            this.write(' ');
        }
        this.write(disp, log.style[m.level]);
        var p = m.prefix || '';
        if (p) {
            this.write(' ');
        }
        this.write(p, this.prefixStyle);
        this.write(' ' + line + '\n');
    }, this);
    this.showProgress();
};
log._format = function(msg, style) {
    if (!stream) {
        return;
    }
    var output = '';
    if (this.useColor()) {
        style = style || {};
        var settings = [];
        if (style.fg) {
            settings.push(style.fg);
        }
        if (style.bg) {
            settings.push('bg' + style.bg[0].toUpperCase() + style.bg.slice(1));
        }
        if (style.bold) {
            settings.push('bold');
        }
        if (style.underline) {
            settings.push('underline');
        }
        if (style.inverse) {
            settings.push('inverse');
        }
        if (settings.length) {
            output += consoleControl.color(settings);
        }
        if (style.beep) {
            output += consoleControl.beep();
        }
    }
    output += msg;
    if (this.useColor()) {
        output += consoleControl.color('reset');
    }
    return output;
};
log.write = function(msg, style) {
    if (!stream) {
        return;
    }
    stream.write(this._format(msg, style));
};
log.addLevel = function(lvl, n, style, disp) {
    // If 'disp' is null or undefined, use the lvl as a default
    if (disp == null) {
        disp = lvl;
    }
    this.levels[lvl] = n;
    this.style[lvl] = style;
    if (!this[lvl]) {
        this[lvl] = (function() {
            var a = new Array(arguments.length + 1);
            a[0] = lvl;
            for(var i = 0; i < arguments.length; i++){
                a[i + 1] = arguments[i];
            }
            return this.log.apply(this, a);
        }).bind(this);
    }
    this.disp[lvl] = disp;
};
log.prefixStyle = {
    fg: 'magenta'
};
log.headingStyle = {
    fg: 'white',
    bg: 'black'
};
log.style = {};
log.levels = {};
log.disp = {};
log.addLevel('silly', -Infinity, {
    inverse: true
}, 'sill');
log.addLevel('verbose', 1000, {
    fg: 'blue',
    bg: 'black'
}, 'verb');
log.addLevel('info', 2000, {
    fg: 'green'
});
log.addLevel('timing', 2500, {
    fg: 'green',
    bg: 'black'
});
log.addLevel('http', 3000, {
    fg: 'green',
    bg: 'black'
});
log.addLevel('notice', 3500, {
    fg: 'blue',
    bg: 'black'
});
log.addLevel('warn', 4000, {
    fg: 'black',
    bg: 'yellow'
}, 'WARN');
log.addLevel('error', 5000, {
    fg: 'red',
    bg: 'black'
}, 'ERR!');
log.addLevel('silent', Infinity);
// allow 'error' prefix
log.on('error', function() {});
}}),
"[project]/node_modules/make-dir/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
const fs = (()=>{
    const e = new Error("Cannot find module 'fs'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
const path = __turbopack_context__.r("[project]/node_modules/path/path.js [app-client] (ecmascript)");
const { promisify } = __turbopack_context__.r("[project]/node_modules/util/util.js [app-client] (ecmascript)");
const semver = __turbopack_context__.r("[project]/node_modules/make-dir/node_modules/semver/semver.js [app-client] (ecmascript)");
const useNativeRecursiveOption = semver.satisfies(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].version, '>=10.12.0');
// https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088
const checkPath = (pth)=>{
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
};
const processOptions = (options)=>{
    // https://github.com/sindresorhus/make-dir/issues/18
    const defaults = {
        mode: 0o777,
        fs
    };
    return {
        ...defaults,
        ...options
    };
};
const permissionError = (pth)=>{
    // This replicates the exception of `fs.mkdir` with native the
    // `recusive` option when run on an invalid drive under Windows.
    const error = new Error(`operation not permitted, mkdir '${pth}'`);
    error.code = 'EPERM';
    error.errno = -4048;
    error.path = pth;
    error.syscall = 'mkdir';
    return error;
};
const makeDir = async (input, options)=>{
    checkPath(input);
    options = processOptions(options);
    const mkdir = promisify(options.fs.mkdir);
    const stat = promisify(options.fs.stat);
    if (useNativeRecursiveOption && options.fs.mkdir === fs.mkdir) {
        const pth = path.resolve(input);
        await mkdir(pth, {
            mode: options.mode,
            recursive: true
        });
        return pth;
    }
    const make = async (pth)=>{
        try {
            await mkdir(pth, options.mode);
            return pth;
        } catch (error) {
            if (error.code === 'EPERM') {
                throw error;
            }
            if (error.code === 'ENOENT') {
                if (path.dirname(pth) === pth) {
                    throw permissionError(pth);
                }
                if (error.message.includes('null bytes')) {
                    throw error;
                }
                await make(path.dirname(pth));
                return make(pth);
            }
            try {
                const stats = await stat(pth);
                if (!stats.isDirectory()) {
                    throw new Error('The path is not a directory');
                }
            } catch (_) {
                throw error;
            }
            return pth;
        }
    };
    return make(path.resolve(input));
};
module.exports = makeDir;
module.exports.sync = (input, options)=>{
    checkPath(input);
    options = processOptions(options);
    if (useNativeRecursiveOption && options.fs.mkdirSync === fs.mkdirSync) {
        const pth = path.resolve(input);
        fs.mkdirSync(pth, {
            mode: options.mode,
            recursive: true
        });
        return pth;
    }
    const make = (pth)=>{
        try {
            options.fs.mkdirSync(pth, options.mode);
        } catch (error) {
            if (error.code === 'EPERM') {
                throw error;
            }
            if (error.code === 'ENOENT') {
                if (path.dirname(pth) === pth) {
                    throw permissionError(pth);
                }
                if (error.message.includes('null bytes')) {
                    throw error;
                }
                make(path.dirname(pth));
                return make(pth);
            }
            try {
                if (!options.fs.statSync(pth).isDirectory()) {
                    throw new Error('The path is not a directory');
                }
            } catch (_) {
                throw error;
            }
        }
        return pth;
    };
    return make(path.resolve(input));
};
}}),
"[project]/node_modules/node-fetch/browser.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// ref: https://github.com/tc39/proposal-global
var getGlobal = function() {
    // the only reliable means to get the global object is
    // `Function('return this')()`
    // However, this causes CSP violations in Chrome apps.
    if (typeof self !== 'undefined') {
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof global !== 'undefined') {
        return global;
    }
    throw new Error('unable to locate global object');
};
var globalObject = getGlobal();
module.exports = exports = globalObject.fetch;
// Needed for TypeScript and Webpack.
if (globalObject.fetch) {
    exports.default = globalObject.fetch.bind(globalObject);
}
exports.Headers = globalObject.Headers;
exports.Request = globalObject.Request;
exports.Response = globalObject.Response;
}}),
"[project]/node_modules/minipass/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
'use strict';
const proc = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] : {
    stdout: null,
    stderr: null
};
const EE = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)");
const Stream = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)");
const stringdecoder = __turbopack_context__.r("[project]/node_modules/string_decoder/lib/string_decoder.js [app-client] (ecmascript)");
const SD = stringdecoder.StringDecoder;
const EOF = Symbol('EOF');
const MAYBE_EMIT_END = Symbol('maybeEmitEnd');
const EMITTED_END = Symbol('emittedEnd');
const EMITTING_END = Symbol('emittingEnd');
const EMITTED_ERROR = Symbol('emittedError');
const CLOSED = Symbol('closed');
const READ = Symbol('read');
const FLUSH = Symbol('flush');
const FLUSHCHUNK = Symbol('flushChunk');
const ENCODING = Symbol('encoding');
const DECODER = Symbol('decoder');
const FLOWING = Symbol('flowing');
const PAUSED = Symbol('paused');
const RESUME = Symbol('resume');
const BUFFER = Symbol('buffer');
const PIPES = Symbol('pipes');
const BUFFERLENGTH = Symbol('bufferLength');
const BUFFERPUSH = Symbol('bufferPush');
const BUFFERSHIFT = Symbol('bufferShift');
const OBJECTMODE = Symbol('objectMode');
// internal event when stream is destroyed
const DESTROYED = Symbol('destroyed');
// internal event when stream has an error
const ERROR = Symbol('error');
const EMITDATA = Symbol('emitData');
const EMITEND = Symbol('emitEnd');
const EMITEND2 = Symbol('emitEnd2');
const ASYNC = Symbol('async');
const ABORT = Symbol('abort');
const ABORTED = Symbol('aborted');
const SIGNAL = Symbol('signal');
const defer = (fn)=>Promise.resolve().then(fn);
// TODO remove when Node v8 support drops
const doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1';
const ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');
const ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented');
// events that mean 'the stream is over'
// these are treated specially, and re-emitted
// if they are listened for after emitting.
const isEndish = (ev)=>ev === 'end' || ev === 'finish' || ev === 'prefinish';
const isArrayBuffer = (b)=>b instanceof ArrayBuffer || typeof b === 'object' && b.constructor && b.constructor.name === 'ArrayBuffer' && b.byteLength >= 0;
const isArrayBufferView = (b)=>!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(b) && ArrayBuffer.isView(b);
class Pipe {
    constructor(src, dest, opts){
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = ()=>src[RESUME]();
        dest.on('drain', this.ondrain);
    }
    unpipe() {
        this.dest.removeListener('drain', this.ondrain);
    }
    // istanbul ignore next - only here for the prototype
    proxyErrors() {}
    end() {
        this.unpipe();
        if (this.opts.end) this.dest.end();
    }
}
class PipeProxyErrors extends Pipe {
    unpipe() {
        this.src.removeListener('error', this.proxyErrors);
        super.unpipe();
    }
    constructor(src, dest, opts){
        super(src, dest, opts);
        this.proxyErrors = (er)=>dest.emit('error', er);
        src.on('error', this.proxyErrors);
    }
}
class Minipass extends Stream {
    constructor(options){
        super();
        this[FLOWING] = false;
        // whether we're explicitly paused
        this[PAUSED] = false;
        this[PIPES] = [];
        this[BUFFER] = [];
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE]) this[ENCODING] = null;
        else this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === 'buffer') this[ENCODING] = null;
        this[ASYNC] = options && !!options.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
        if (options && options.debugExposeBuffer === true) {
            Object.defineProperty(this, 'buffer', {
                get: ()=>this[BUFFER]
            });
        }
        if (options && options.debugExposePipes === true) {
            Object.defineProperty(this, 'pipes', {
                get: ()=>this[PIPES]
            });
        }
        this[SIGNAL] = options && options.signal;
        this[ABORTED] = false;
        if (this[SIGNAL]) {
            this[SIGNAL].addEventListener('abort', ()=>this[ABORT]());
            if (this[SIGNAL].aborted) {
                this[ABORT]();
            }
        }
    }
    get bufferLength() {
        return this[BUFFERLENGTH];
    }
    get encoding() {
        return this[ENCODING];
    }
    set encoding(enc) {
        if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');
        if (this[ENCODING] !== enc) {
            this[DECODER] = enc ? new SD(enc) : null;
            if (this[BUFFER].length) this[BUFFER] = this[BUFFER].map((chunk)=>this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
    }
    setEncoding(enc) {
        this.encoding = enc;
    }
    get objectMode() {
        return this[OBJECTMODE];
    }
    set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
    }
    get ['async']() {
        return this[ASYNC];
    }
    set ['async'](a) {
        this[ASYNC] = this[ASYNC] || !!a;
    }
    // drop everything and get out of the flow completely
    [ABORT]() {
        this[ABORTED] = true;
        this.emit('abort', this[SIGNAL].reason);
        this.destroy(this[SIGNAL].reason);
    }
    get aborted() {
        return this[ABORTED];
    }
    set aborted(_) {}
    write(chunk, encoding, cb) {
        if (this[ABORTED]) return false;
        if (this[EOF]) throw new Error('write after end');
        if (this[DESTROYED]) {
            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), {
                code: 'ERR_STREAM_DESTROYED'
            }));
            return true;
        }
        if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';
        if (!encoding) encoding = 'utf8';
        const fn = this[ASYNC] ? defer : (f)=>f();
        // convert array buffers and typed array views into buffers
        // at some point in the future, we may want to do the opposite!
        // leave strings and buffers as-is
        // anything else switches us into object mode
        if (!this[OBJECTMODE] && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(chunk)) {
            if (isArrayBufferView(chunk)) chunk = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            else if (isArrayBuffer(chunk)) chunk = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(chunk);
            else if (typeof chunk !== 'string') // use the setter so we throw if we have encoding set
            this.objectMode = true;
        }
        // handle object mode up front, since it's simpler
        // this yields better performance, fewer checks later.
        if (this[OBJECTMODE]) {
            /* istanbul ignore if - maybe impossible? */ if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
            if (this.flowing) this.emit('data', chunk);
            else this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0) this.emit('readable');
            if (cb) fn(cb);
            return this.flowing;
        }
        // at this point the chunk is a buffer or string
        // don't buffer it up or send it to the decoder
        if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0) this.emit('readable');
            if (cb) fn(cb);
            return this.flowing;
        }
        // fast-path writing strings of same encoding to a stream with
        // an empty buffer, skipping the buffer/decoder dance
        if (typeof chunk === 'string' && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
            chunk = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(chunk, encoding);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk);
        // Note: flushing CAN potentially switch us into not-flowing mode
        if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
        if (this.flowing) this.emit('data', chunk);
        else this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0) this.emit('readable');
        if (cb) fn(cb);
        return this.flowing;
    }
    read(n) {
        if (this[DESTROYED]) return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
            this[MAYBE_EMIT_END]();
            return null;
        }
        if (this[OBJECTMODE]) n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
            if (this.encoding) this[BUFFER] = [
                this[BUFFER].join('')
            ];
            else this[BUFFER] = [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat(this[BUFFER], this[BUFFERLENGTH])
            ];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [READ](n, chunk) {
        if (n === chunk.length || n === null) this[BUFFERSHIFT]();
        else {
            this[BUFFER][0] = chunk.slice(n);
            chunk = chunk.slice(0, n);
            this[BUFFERLENGTH] -= n;
        }
        this.emit('data', chunk);
        if (!this[BUFFER].length && !this[EOF]) this.emit('drain');
        return chunk;
    }
    end(chunk, encoding, cb) {
        if (typeof chunk === 'function') cb = chunk, chunk = null;
        if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';
        if (chunk) this.write(chunk, encoding);
        if (cb) this.once('end', cb);
        this[EOF] = true;
        this.writable = false;
        // if we haven't written anything, then go ahead and emit,
        // even if we're not reading.
        // we'll re-emit if a new 'end' listener is added anyway.
        // This makes MP more suitable to write-only use cases.
        if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
        return this;
    }
    // don't let the internal resume be overwritten
    [RESUME]() {
        if (this[DESTROYED]) return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit('resume');
        if (this[BUFFER].length) this[FLUSH]();
        else if (this[EOF]) this[MAYBE_EMIT_END]();
        else this.emit('drain');
    }
    resume() {
        return this[RESUME]();
    }
    pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
    }
    get destroyed() {
        return this[DESTROYED];
    }
    get flowing() {
        return this[FLOWING];
    }
    get paused() {
        return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
        else this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
    }
    [BUFFERSHIFT]() {
        if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
        else this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
    }
    [FLUSH](noDrain) {
        do {}while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length)
        if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain');
    }
    [FLUSHCHUNK](chunk) {
        this.emit('data', chunk);
        return this.flowing;
    }
    pipe(dest, opts) {
        if (this[DESTROYED]) return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
        else opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        // piping an ended stream ends immediately
        if (ended) {
            if (opts.end) dest.end();
        } else {
            this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
            if (this[ASYNC]) defer(()=>this[RESUME]());
            else this[RESUME]();
        }
        return dest;
    }
    unpipe(dest) {
        const p = this[PIPES].find((p)=>p.dest === dest);
        if (p) {
            this[PIPES].splice(this[PIPES].indexOf(p), 1);
            p.unpipe();
        }
    }
    addListener(ev, fn) {
        return this.on(ev, fn);
    }
    on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === 'data' && !this[PIPES].length && !this.flowing) this[RESUME]();
        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) super.emit('readable');
        else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
        } else if (ev === 'error' && this[EMITTED_ERROR]) {
            if (this[ASYNC]) defer(()=>fn.call(this, this[EMITTED_ERROR]));
            else fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
    }
    get emittedEnd() {
        return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
            this[EMITTING_END] = true;
            this.emit('end');
            this.emit('prefinish');
            this.emit('finish');
            if (this[CLOSED]) this.emit('close');
            this[EMITTING_END] = false;
        }
    }
    emit(ev, data, ...extra) {
        // error and close are only events allowed after calling destroy()
        if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED]) return;
        else if (ev === 'data') {
            return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? defer(()=>this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === 'end') {
            return this[EMITEND]();
        } else if (ev === 'close') {
            this[CLOSED] = true;
            // don't emit close before 'end' and 'finish'
            if (!this[EMITTED_END] && !this[DESTROYED]) return;
            const ret = super.emit('close');
            this.removeAllListeners('close');
            return ret;
        } else if (ev === 'error') {
            this[EMITTED_ERROR] = data;
            super.emit(ERROR, data);
            const ret = !this[SIGNAL] || this.listeners('error').length ? super.emit('error', data) : false;
            this[MAYBE_EMIT_END]();
            return ret;
        } else if (ev === 'resume') {
            const ret = super.emit('resume');
            this[MAYBE_EMIT_END]();
            return ret;
        } else if (ev === 'finish' || ev === 'prefinish') {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
        }
        // Some other unknown event
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITDATA](data) {
        for (const p of this[PIPES]){
            if (p.dest.write(data) === false) this.pause();
        }
        const ret = super.emit('data', data);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITEND]() {
        if (this[EMITTED_END]) return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC]) defer(()=>this[EMITEND2]());
        else this[EMITEND2]();
    }
    [EMITEND2]() {
        if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
                for (const p of this[PIPES]){
                    p.dest.write(data);
                }
                super.emit('data', data);
            }
        }
        for (const p of this[PIPES]){
            p.end();
        }
        const ret = super.emit('end');
        this.removeAllListeners('end');
        return ret;
    }
    // const all = await stream.collect()
    collect() {
        const buf = [];
        if (!this[OBJECTMODE]) buf.dataLength = 0;
        // set the promise first, in case an error is raised
        // by triggering the flow here.
        const p = this.promise();
        this.on('data', (c)=>{
            buf.push(c);
            if (!this[OBJECTMODE]) buf.dataLength += c.length;
        });
        return p.then(()=>buf);
    }
    // const data = await stream.concat()
    concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this.collect().then((buf)=>this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this[ENCODING] ? buf.join('') : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat(buf, buf.dataLength));
    }
    // stream.promise().then(() => done, er => emitted error)
    promise() {
        return new Promise((resolve, reject)=>{
            this.on(DESTROYED, ()=>reject(new Error('stream destroyed')));
            this.on('error', (er)=>reject(er));
            this.on('end', ()=>resolve());
        });
    }
    // for await (let chunk of stream)
    [ASYNCITERATOR]() {
        let stopped = false;
        const stop = ()=>{
            this.pause();
            stopped = true;
            return Promise.resolve({
                done: true
            });
        };
        const next = ()=>{
            if (stopped) return stop();
            const res = this.read();
            if (res !== null) return Promise.resolve({
                done: false,
                value: res
            });
            if (this[EOF]) return stop();
            let resolve = null;
            let reject = null;
            const onerr = (er)=>{
                this.removeListener('data', ondata);
                this.removeListener('end', onend);
                this.removeListener(DESTROYED, ondestroy);
                stop();
                reject(er);
            };
            const ondata = (value)=>{
                this.removeListener('error', onerr);
                this.removeListener('end', onend);
                this.removeListener(DESTROYED, ondestroy);
                this.pause();
                resolve({
                    value: value,
                    done: !!this[EOF]
                });
            };
            const onend = ()=>{
                this.removeListener('error', onerr);
                this.removeListener('data', ondata);
                this.removeListener(DESTROYED, ondestroy);
                stop();
                resolve({
                    done: true
                });
            };
            const ondestroy = ()=>onerr(new Error('stream destroyed'));
            return new Promise((res, rej)=>{
                reject = rej;
                resolve = res;
                this.once(DESTROYED, ondestroy);
                this.once('error', onerr);
                this.once('end', onend);
                this.once('data', ondata);
            });
        };
        return {
            next,
            throw: stop,
            return: stop,
            [ASYNCITERATOR] () {
                return this;
            }
        };
    }
    // for (let chunk of stream)
    [ITERATOR]() {
        let stopped = false;
        const stop = ()=>{
            this.pause();
            this.removeListener(ERROR, stop);
            this.removeListener(DESTROYED, stop);
            this.removeListener('end', stop);
            stopped = true;
            return {
                done: true
            };
        };
        const next = ()=>{
            if (stopped) return stop();
            const value = this.read();
            return value === null ? stop() : {
                value
            };
        };
        this.once('end', stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
            next,
            throw: stop,
            return: stop,
            [ITERATOR] () {
                return this;
            }
        };
    }
    destroy(er) {
        if (this[DESTROYED]) {
            if (er) this.emit('error', er);
            else this.emit(DESTROYED);
            return this;
        }
        this[DESTROYED] = true;
        // throw away all buffered data, it's never coming out
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === 'function' && !this[CLOSED]) this.close();
        if (er) this.emit('error', er);
        else this.emit(DESTROYED);
        return this;
    }
    static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && // readable
        (typeof s.pipe === 'function' || typeof s.write === 'function' && typeof s.end === 'function'));
    }
}
exports.Minipass = Minipass;
}}),
"[project]/node_modules/minizlib/node_modules/minipass/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
'use strict';
const proc = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] : {
    stdout: null,
    stderr: null
};
const EE = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)");
const Stream = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)");
const SD = __turbopack_context__.r("[project]/node_modules/string_decoder/lib/string_decoder.js [app-client] (ecmascript)").StringDecoder;
const EOF = Symbol('EOF');
const MAYBE_EMIT_END = Symbol('maybeEmitEnd');
const EMITTED_END = Symbol('emittedEnd');
const EMITTING_END = Symbol('emittingEnd');
const EMITTED_ERROR = Symbol('emittedError');
const CLOSED = Symbol('closed');
const READ = Symbol('read');
const FLUSH = Symbol('flush');
const FLUSHCHUNK = Symbol('flushChunk');
const ENCODING = Symbol('encoding');
const DECODER = Symbol('decoder');
const FLOWING = Symbol('flowing');
const PAUSED = Symbol('paused');
const RESUME = Symbol('resume');
const BUFFERLENGTH = Symbol('bufferLength');
const BUFFERPUSH = Symbol('bufferPush');
const BUFFERSHIFT = Symbol('bufferShift');
const OBJECTMODE = Symbol('objectMode');
const DESTROYED = Symbol('destroyed');
const EMITDATA = Symbol('emitData');
const EMITEND = Symbol('emitEnd');
const EMITEND2 = Symbol('emitEnd2');
const ASYNC = Symbol('async');
const defer = (fn)=>Promise.resolve().then(fn);
// TODO remove when Node v8 support drops
const doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1';
const ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');
const ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented');
// events that mean 'the stream is over'
// these are treated specially, and re-emitted
// if they are listened for after emitting.
const isEndish = (ev)=>ev === 'end' || ev === 'finish' || ev === 'prefinish';
const isArrayBuffer = (b)=>b instanceof ArrayBuffer || typeof b === 'object' && b.constructor && b.constructor.name === 'ArrayBuffer' && b.byteLength >= 0;
const isArrayBufferView = (b)=>!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(b) && ArrayBuffer.isView(b);
class Pipe {
    constructor(src, dest, opts){
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = ()=>src[RESUME]();
        dest.on('drain', this.ondrain);
    }
    unpipe() {
        this.dest.removeListener('drain', this.ondrain);
    }
    // istanbul ignore next - only here for the prototype
    proxyErrors() {}
    end() {
        this.unpipe();
        if (this.opts.end) this.dest.end();
    }
}
class PipeProxyErrors extends Pipe {
    unpipe() {
        this.src.removeListener('error', this.proxyErrors);
        super.unpipe();
    }
    constructor(src, dest, opts){
        super(src, dest, opts);
        this.proxyErrors = (er)=>dest.emit('error', er);
        src.on('error', this.proxyErrors);
    }
}
module.exports = class Minipass extends Stream {
    constructor(options){
        super();
        this[FLOWING] = false;
        // whether we're explicitly paused
        this[PAUSED] = false;
        this.pipes = [];
        this.buffer = [];
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE]) this[ENCODING] = null;
        else this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === 'buffer') this[ENCODING] = null;
        this[ASYNC] = options && !!options.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
    }
    get bufferLength() {
        return this[BUFFERLENGTH];
    }
    get encoding() {
        return this[ENCODING];
    }
    set encoding(enc) {
        if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');
        if (this[ENCODING] !== enc) {
            this[DECODER] = enc ? new SD(enc) : null;
            if (this.buffer.length) this.buffer = this.buffer.map((chunk)=>this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
    }
    setEncoding(enc) {
        this.encoding = enc;
    }
    get objectMode() {
        return this[OBJECTMODE];
    }
    set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
    }
    get ['async']() {
        return this[ASYNC];
    }
    set ['async'](a) {
        this[ASYNC] = this[ASYNC] || !!a;
    }
    write(chunk, encoding, cb) {
        if (this[EOF]) throw new Error('write after end');
        if (this[DESTROYED]) {
            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), {
                code: 'ERR_STREAM_DESTROYED'
            }));
            return true;
        }
        if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';
        if (!encoding) encoding = 'utf8';
        const fn = this[ASYNC] ? defer : (f)=>f();
        // convert array buffers and typed array views into buffers
        // at some point in the future, we may want to do the opposite!
        // leave strings and buffers as-is
        // anything else switches us into object mode
        if (!this[OBJECTMODE] && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(chunk)) {
            if (isArrayBufferView(chunk)) chunk = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            else if (isArrayBuffer(chunk)) chunk = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(chunk);
            else if (typeof chunk !== 'string') // use the setter so we throw if we have encoding set
            this.objectMode = true;
        }
        // handle object mode up front, since it's simpler
        // this yields better performance, fewer checks later.
        if (this[OBJECTMODE]) {
            /* istanbul ignore if - maybe impossible? */ if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
            if (this.flowing) this.emit('data', chunk);
            else this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0) this.emit('readable');
            if (cb) fn(cb);
            return this.flowing;
        }
        // at this point the chunk is a buffer or string
        // don't buffer it up or send it to the decoder
        if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0) this.emit('readable');
            if (cb) fn(cb);
            return this.flowing;
        }
        // fast-path writing strings of same encoding to a stream with
        // an empty buffer, skipping the buffer/decoder dance
        if (typeof chunk === 'string' && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
            chunk = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(chunk, encoding);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk);
        // Note: flushing CAN potentially switch us into not-flowing mode
        if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
        if (this.flowing) this.emit('data', chunk);
        else this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0) this.emit('readable');
        if (cb) fn(cb);
        return this.flowing;
    }
    read(n) {
        if (this[DESTROYED]) return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
            this[MAYBE_EMIT_END]();
            return null;
        }
        if (this[OBJECTMODE]) n = null;
        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
            if (this.encoding) this.buffer = [
                this.buffer.join('')
            ];
            else this.buffer = [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat(this.buffer, this[BUFFERLENGTH])
            ];
        }
        const ret = this[READ](n || null, this.buffer[0]);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [READ](n, chunk) {
        if (n === chunk.length || n === null) this[BUFFERSHIFT]();
        else {
            this.buffer[0] = chunk.slice(n);
            chunk = chunk.slice(0, n);
            this[BUFFERLENGTH] -= n;
        }
        this.emit('data', chunk);
        if (!this.buffer.length && !this[EOF]) this.emit('drain');
        return chunk;
    }
    end(chunk, encoding, cb) {
        if (typeof chunk === 'function') cb = chunk, chunk = null;
        if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';
        if (chunk) this.write(chunk, encoding);
        if (cb) this.once('end', cb);
        this[EOF] = true;
        this.writable = false;
        // if we haven't written anything, then go ahead and emit,
        // even if we're not reading.
        // we'll re-emit if a new 'end' listener is added anyway.
        // This makes MP more suitable to write-only use cases.
        if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
        return this;
    }
    // don't let the internal resume be overwritten
    [RESUME]() {
        if (this[DESTROYED]) return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit('resume');
        if (this.buffer.length) this[FLUSH]();
        else if (this[EOF]) this[MAYBE_EMIT_END]();
        else this.emit('drain');
    }
    resume() {
        return this[RESUME]();
    }
    pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
    }
    get destroyed() {
        return this[DESTROYED];
    }
    get flowing() {
        return this[FLOWING];
    }
    get paused() {
        return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
        else this[BUFFERLENGTH] += chunk.length;
        this.buffer.push(chunk);
    }
    [BUFFERSHIFT]() {
        if (this.buffer.length) {
            if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
            else this[BUFFERLENGTH] -= this.buffer[0].length;
        }
        return this.buffer.shift();
    }
    [FLUSH](noDrain) {
        do {}while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))
        if (!noDrain && !this.buffer.length && !this[EOF]) this.emit('drain');
    }
    [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit('data', chunk), this.flowing) : false;
    }
    pipe(dest, opts) {
        if (this[DESTROYED]) return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
        else opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        // piping an ended stream ends immediately
        if (ended) {
            if (opts.end) dest.end();
        } else {
            this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
            if (this[ASYNC]) defer(()=>this[RESUME]());
            else this[RESUME]();
        }
        return dest;
    }
    unpipe(dest) {
        const p = this.pipes.find((p)=>p.dest === dest);
        if (p) {
            this.pipes.splice(this.pipes.indexOf(p), 1);
            p.unpipe();
        }
    }
    addListener(ev, fn) {
        return this.on(ev, fn);
    }
    on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === 'data' && !this.pipes.length && !this.flowing) this[RESUME]();
        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) super.emit('readable');
        else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
        } else if (ev === 'error' && this[EMITTED_ERROR]) {
            if (this[ASYNC]) defer(()=>fn.call(this, this[EMITTED_ERROR]));
            else fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
    }
    get emittedEnd() {
        return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
            this[EMITTING_END] = true;
            this.emit('end');
            this.emit('prefinish');
            this.emit('finish');
            if (this[CLOSED]) this.emit('close');
            this[EMITTING_END] = false;
        }
    }
    emit(ev, data, ...extra) {
        // error and close are only events allowed after calling destroy()
        if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED]) return;
        else if (ev === 'data') {
            return !data ? false : this[ASYNC] ? defer(()=>this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === 'end') {
            return this[EMITEND]();
        } else if (ev === 'close') {
            this[CLOSED] = true;
            // don't emit close before 'end' and 'finish'
            if (!this[EMITTED_END] && !this[DESTROYED]) return;
            const ret = super.emit('close');
            this.removeAllListeners('close');
            return ret;
        } else if (ev === 'error') {
            this[EMITTED_ERROR] = data;
            const ret = super.emit('error', data);
            this[MAYBE_EMIT_END]();
            return ret;
        } else if (ev === 'resume') {
            const ret = super.emit('resume');
            this[MAYBE_EMIT_END]();
            return ret;
        } else if (ev === 'finish' || ev === 'prefinish') {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
        }
        // Some other unknown event
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITDATA](data) {
        for (const p of this.pipes){
            if (p.dest.write(data) === false) this.pause();
        }
        const ret = super.emit('data', data);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITEND]() {
        if (this[EMITTED_END]) return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC]) defer(()=>this[EMITEND2]());
        else this[EMITEND2]();
    }
    [EMITEND2]() {
        if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
                for (const p of this.pipes){
                    p.dest.write(data);
                }
                super.emit('data', data);
            }
        }
        for (const p of this.pipes){
            p.end();
        }
        const ret = super.emit('end');
        this.removeAllListeners('end');
        return ret;
    }
    // const all = await stream.collect()
    collect() {
        const buf = [];
        if (!this[OBJECTMODE]) buf.dataLength = 0;
        // set the promise first, in case an error is raised
        // by triggering the flow here.
        const p = this.promise();
        this.on('data', (c)=>{
            buf.push(c);
            if (!this[OBJECTMODE]) buf.dataLength += c.length;
        });
        return p.then(()=>buf);
    }
    // const data = await stream.concat()
    concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this.collect().then((buf)=>this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this[ENCODING] ? buf.join('') : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat(buf, buf.dataLength));
    }
    // stream.promise().then(() => done, er => emitted error)
    promise() {
        return new Promise((resolve, reject)=>{
            this.on(DESTROYED, ()=>reject(new Error('stream destroyed')));
            this.on('error', (er)=>reject(er));
            this.on('end', ()=>resolve());
        });
    }
    // for await (let chunk of stream)
    [ASYNCITERATOR]() {
        const next = ()=>{
            const res = this.read();
            if (res !== null) return Promise.resolve({
                done: false,
                value: res
            });
            if (this[EOF]) return Promise.resolve({
                done: true
            });
            let resolve = null;
            let reject = null;
            const onerr = (er)=>{
                this.removeListener('data', ondata);
                this.removeListener('end', onend);
                reject(er);
            };
            const ondata = (value)=>{
                this.removeListener('error', onerr);
                this.removeListener('end', onend);
                this.pause();
                resolve({
                    value: value,
                    done: !!this[EOF]
                });
            };
            const onend = ()=>{
                this.removeListener('error', onerr);
                this.removeListener('data', ondata);
                resolve({
                    done: true
                });
            };
            const ondestroy = ()=>onerr(new Error('stream destroyed'));
            return new Promise((res, rej)=>{
                reject = rej;
                resolve = res;
                this.once(DESTROYED, ondestroy);
                this.once('error', onerr);
                this.once('end', onend);
                this.once('data', ondata);
            });
        };
        return {
            next
        };
    }
    // for (let chunk of stream)
    [ITERATOR]() {
        const next = ()=>{
            const value = this.read();
            const done = value === null;
            return {
                value,
                done
            };
        };
        return {
            next
        };
    }
    destroy(er) {
        if (this[DESTROYED]) {
            if (er) this.emit('error', er);
            else this.emit(DESTROYED);
            return this;
        }
        this[DESTROYED] = true;
        // throw away all buffered data, it's never coming out
        this.buffer.length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === 'function' && !this[CLOSED]) this.close();
        if (er) this.emit('error', er);
        else this.emit(DESTROYED);
        return this;
    }
    static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === 'function' || typeof s.write === 'function' && typeof s.end === 'function' // writable
        ));
    }
};
}}),
"[project]/node_modules/fs-minipass/node_modules/minipass/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
'use strict';
const proc = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] : {
    stdout: null,
    stderr: null
};
const EE = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)");
const Stream = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)");
const SD = __turbopack_context__.r("[project]/node_modules/string_decoder/lib/string_decoder.js [app-client] (ecmascript)").StringDecoder;
const EOF = Symbol('EOF');
const MAYBE_EMIT_END = Symbol('maybeEmitEnd');
const EMITTED_END = Symbol('emittedEnd');
const EMITTING_END = Symbol('emittingEnd');
const EMITTED_ERROR = Symbol('emittedError');
const CLOSED = Symbol('closed');
const READ = Symbol('read');
const FLUSH = Symbol('flush');
const FLUSHCHUNK = Symbol('flushChunk');
const ENCODING = Symbol('encoding');
const DECODER = Symbol('decoder');
const FLOWING = Symbol('flowing');
const PAUSED = Symbol('paused');
const RESUME = Symbol('resume');
const BUFFERLENGTH = Symbol('bufferLength');
const BUFFERPUSH = Symbol('bufferPush');
const BUFFERSHIFT = Symbol('bufferShift');
const OBJECTMODE = Symbol('objectMode');
const DESTROYED = Symbol('destroyed');
const EMITDATA = Symbol('emitData');
const EMITEND = Symbol('emitEnd');
const EMITEND2 = Symbol('emitEnd2');
const ASYNC = Symbol('async');
const defer = (fn)=>Promise.resolve().then(fn);
// TODO remove when Node v8 support drops
const doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1';
const ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');
const ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented');
// events that mean 'the stream is over'
// these are treated specially, and re-emitted
// if they are listened for after emitting.
const isEndish = (ev)=>ev === 'end' || ev === 'finish' || ev === 'prefinish';
const isArrayBuffer = (b)=>b instanceof ArrayBuffer || typeof b === 'object' && b.constructor && b.constructor.name === 'ArrayBuffer' && b.byteLength >= 0;
const isArrayBufferView = (b)=>!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(b) && ArrayBuffer.isView(b);
class Pipe {
    constructor(src, dest, opts){
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = ()=>src[RESUME]();
        dest.on('drain', this.ondrain);
    }
    unpipe() {
        this.dest.removeListener('drain', this.ondrain);
    }
    // istanbul ignore next - only here for the prototype
    proxyErrors() {}
    end() {
        this.unpipe();
        if (this.opts.end) this.dest.end();
    }
}
class PipeProxyErrors extends Pipe {
    unpipe() {
        this.src.removeListener('error', this.proxyErrors);
        super.unpipe();
    }
    constructor(src, dest, opts){
        super(src, dest, opts);
        this.proxyErrors = (er)=>dest.emit('error', er);
        src.on('error', this.proxyErrors);
    }
}
module.exports = class Minipass extends Stream {
    constructor(options){
        super();
        this[FLOWING] = false;
        // whether we're explicitly paused
        this[PAUSED] = false;
        this.pipes = [];
        this.buffer = [];
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE]) this[ENCODING] = null;
        else this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === 'buffer') this[ENCODING] = null;
        this[ASYNC] = options && !!options.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
    }
    get bufferLength() {
        return this[BUFFERLENGTH];
    }
    get encoding() {
        return this[ENCODING];
    }
    set encoding(enc) {
        if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');
        if (this[ENCODING] !== enc) {
            this[DECODER] = enc ? new SD(enc) : null;
            if (this.buffer.length) this.buffer = this.buffer.map((chunk)=>this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
    }
    setEncoding(enc) {
        this.encoding = enc;
    }
    get objectMode() {
        return this[OBJECTMODE];
    }
    set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
    }
    get ['async']() {
        return this[ASYNC];
    }
    set ['async'](a) {
        this[ASYNC] = this[ASYNC] || !!a;
    }
    write(chunk, encoding, cb) {
        if (this[EOF]) throw new Error('write after end');
        if (this[DESTROYED]) {
            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), {
                code: 'ERR_STREAM_DESTROYED'
            }));
            return true;
        }
        if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';
        if (!encoding) encoding = 'utf8';
        const fn = this[ASYNC] ? defer : (f)=>f();
        // convert array buffers and typed array views into buffers
        // at some point in the future, we may want to do the opposite!
        // leave strings and buffers as-is
        // anything else switches us into object mode
        if (!this[OBJECTMODE] && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(chunk)) {
            if (isArrayBufferView(chunk)) chunk = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            else if (isArrayBuffer(chunk)) chunk = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(chunk);
            else if (typeof chunk !== 'string') // use the setter so we throw if we have encoding set
            this.objectMode = true;
        }
        // handle object mode up front, since it's simpler
        // this yields better performance, fewer checks later.
        if (this[OBJECTMODE]) {
            /* istanbul ignore if - maybe impossible? */ if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
            if (this.flowing) this.emit('data', chunk);
            else this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0) this.emit('readable');
            if (cb) fn(cb);
            return this.flowing;
        }
        // at this point the chunk is a buffer or string
        // don't buffer it up or send it to the decoder
        if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0) this.emit('readable');
            if (cb) fn(cb);
            return this.flowing;
        }
        // fast-path writing strings of same encoding to a stream with
        // an empty buffer, skipping the buffer/decoder dance
        if (typeof chunk === 'string' && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
            chunk = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(chunk, encoding);
        }
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk);
        // Note: flushing CAN potentially switch us into not-flowing mode
        if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
        if (this.flowing) this.emit('data', chunk);
        else this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0) this.emit('readable');
        if (cb) fn(cb);
        return this.flowing;
    }
    read(n) {
        if (this[DESTROYED]) return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
            this[MAYBE_EMIT_END]();
            return null;
        }
        if (this[OBJECTMODE]) n = null;
        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
            if (this.encoding) this.buffer = [
                this.buffer.join('')
            ];
            else this.buffer = [
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat(this.buffer, this[BUFFERLENGTH])
            ];
        }
        const ret = this[READ](n || null, this.buffer[0]);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [READ](n, chunk) {
        if (n === chunk.length || n === null) this[BUFFERSHIFT]();
        else {
            this.buffer[0] = chunk.slice(n);
            chunk = chunk.slice(0, n);
            this[BUFFERLENGTH] -= n;
        }
        this.emit('data', chunk);
        if (!this.buffer.length && !this[EOF]) this.emit('drain');
        return chunk;
    }
    end(chunk, encoding, cb) {
        if (typeof chunk === 'function') cb = chunk, chunk = null;
        if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';
        if (chunk) this.write(chunk, encoding);
        if (cb) this.once('end', cb);
        this[EOF] = true;
        this.writable = false;
        // if we haven't written anything, then go ahead and emit,
        // even if we're not reading.
        // we'll re-emit if a new 'end' listener is added anyway.
        // This makes MP more suitable to write-only use cases.
        if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
        return this;
    }
    // don't let the internal resume be overwritten
    [RESUME]() {
        if (this[DESTROYED]) return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit('resume');
        if (this.buffer.length) this[FLUSH]();
        else if (this[EOF]) this[MAYBE_EMIT_END]();
        else this.emit('drain');
    }
    resume() {
        return this[RESUME]();
    }
    pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
    }
    get destroyed() {
        return this[DESTROYED];
    }
    get flowing() {
        return this[FLOWING];
    }
    get paused() {
        return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
        else this[BUFFERLENGTH] += chunk.length;
        this.buffer.push(chunk);
    }
    [BUFFERSHIFT]() {
        if (this.buffer.length) {
            if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
            else this[BUFFERLENGTH] -= this.buffer[0].length;
        }
        return this.buffer.shift();
    }
    [FLUSH](noDrain) {
        do {}while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))
        if (!noDrain && !this.buffer.length && !this[EOF]) this.emit('drain');
    }
    [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit('data', chunk), this.flowing) : false;
    }
    pipe(dest, opts) {
        if (this[DESTROYED]) return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
        else opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        // piping an ended stream ends immediately
        if (ended) {
            if (opts.end) dest.end();
        } else {
            this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
            if (this[ASYNC]) defer(()=>this[RESUME]());
            else this[RESUME]();
        }
        return dest;
    }
    unpipe(dest) {
        const p = this.pipes.find((p)=>p.dest === dest);
        if (p) {
            this.pipes.splice(this.pipes.indexOf(p), 1);
            p.unpipe();
        }
    }
    addListener(ev, fn) {
        return this.on(ev, fn);
    }
    on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === 'data' && !this.pipes.length && !this.flowing) this[RESUME]();
        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) super.emit('readable');
        else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
        } else if (ev === 'error' && this[EMITTED_ERROR]) {
            if (this[ASYNC]) defer(()=>fn.call(this, this[EMITTED_ERROR]));
            else fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
    }
    get emittedEnd() {
        return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
            this[EMITTING_END] = true;
            this.emit('end');
            this.emit('prefinish');
            this.emit('finish');
            if (this[CLOSED]) this.emit('close');
            this[EMITTING_END] = false;
        }
    }
    emit(ev, data, ...extra) {
        // error and close are only events allowed after calling destroy()
        if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED]) return;
        else if (ev === 'data') {
            return !data ? false : this[ASYNC] ? defer(()=>this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === 'end') {
            return this[EMITEND]();
        } else if (ev === 'close') {
            this[CLOSED] = true;
            // don't emit close before 'end' and 'finish'
            if (!this[EMITTED_END] && !this[DESTROYED]) return;
            const ret = super.emit('close');
            this.removeAllListeners('close');
            return ret;
        } else if (ev === 'error') {
            this[EMITTED_ERROR] = data;
            const ret = super.emit('error', data);
            this[MAYBE_EMIT_END]();
            return ret;
        } else if (ev === 'resume') {
            const ret = super.emit('resume');
            this[MAYBE_EMIT_END]();
            return ret;
        } else if (ev === 'finish' || ev === 'prefinish') {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
        }
        // Some other unknown event
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITDATA](data) {
        for (const p of this.pipes){
            if (p.dest.write(data) === false) this.pause();
        }
        const ret = super.emit('data', data);
        this[MAYBE_EMIT_END]();
        return ret;
    }
    [EMITEND]() {
        if (this[EMITTED_END]) return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC]) defer(()=>this[EMITEND2]());
        else this[EMITEND2]();
    }
    [EMITEND2]() {
        if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
                for (const p of this.pipes){
                    p.dest.write(data);
                }
                super.emit('data', data);
            }
        }
        for (const p of this.pipes){
            p.end();
        }
        const ret = super.emit('end');
        this.removeAllListeners('end');
        return ret;
    }
    // const all = await stream.collect()
    collect() {
        const buf = [];
        if (!this[OBJECTMODE]) buf.dataLength = 0;
        // set the promise first, in case an error is raised
        // by triggering the flow here.
        const p = this.promise();
        this.on('data', (c)=>{
            buf.push(c);
            if (!this[OBJECTMODE]) buf.dataLength += c.length;
        });
        return p.then(()=>buf);
    }
    // const data = await stream.concat()
    concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this.collect().then((buf)=>this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this[ENCODING] ? buf.join('') : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat(buf, buf.dataLength));
    }
    // stream.promise().then(() => done, er => emitted error)
    promise() {
        return new Promise((resolve, reject)=>{
            this.on(DESTROYED, ()=>reject(new Error('stream destroyed')));
            this.on('error', (er)=>reject(er));
            this.on('end', ()=>resolve());
        });
    }
    // for await (let chunk of stream)
    [ASYNCITERATOR]() {
        const next = ()=>{
            const res = this.read();
            if (res !== null) return Promise.resolve({
                done: false,
                value: res
            });
            if (this[EOF]) return Promise.resolve({
                done: true
            });
            let resolve = null;
            let reject = null;
            const onerr = (er)=>{
                this.removeListener('data', ondata);
                this.removeListener('end', onend);
                reject(er);
            };
            const ondata = (value)=>{
                this.removeListener('error', onerr);
                this.removeListener('end', onend);
                this.pause();
                resolve({
                    value: value,
                    done: !!this[EOF]
                });
            };
            const onend = ()=>{
                this.removeListener('error', onerr);
                this.removeListener('data', ondata);
                resolve({
                    done: true
                });
            };
            const ondestroy = ()=>onerr(new Error('stream destroyed'));
            return new Promise((res, rej)=>{
                reject = rej;
                resolve = res;
                this.once(DESTROYED, ondestroy);
                this.once('error', onerr);
                this.once('end', onend);
                this.once('data', ondata);
            });
        };
        return {
            next
        };
    }
    // for (let chunk of stream)
    [ITERATOR]() {
        const next = ()=>{
            const value = this.read();
            const done = value === null;
            return {
                value,
                done
            };
        };
        return {
            next
        };
    }
    destroy(er) {
        if (this[DESTROYED]) {
            if (er) this.emit('error', er);
            else this.emit(DESTROYED);
            return this;
        }
        this[DESTROYED] = true;
        // throw away all buffered data, it's never coming out
        this.buffer.length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === 'function' && !this[CLOSED]) this.close();
        if (er) this.emit('error', er);
        else this.emit(DESTROYED);
        return this;
    }
    static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === 'function' || typeof s.write === 'function' && typeof s.end === 'function' // writable
        ));
    }
};
}}),
"[project]/node_modules/minizlib/constants.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// Update with any zlib constants that are added or changed in the future.
// Node v6 didn't export this, so we just hard code the version and rely
// on all the other hard-coded values from zlib v4736.  When node v6
// support drops, we can just export the realZlibConstants object.
const realZlibConstants = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/browserify-zlib/index.js [app-client] (ecmascript)").constants || /* istanbul ignore next */ {
    ZLIB_VERNUM: 4736
};
module.exports = Object.freeze(Object.assign(Object.create(null), {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
}, realZlibConstants));
}}),
"[project]/node_modules/minizlib/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const assert = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/assert/assert.js [app-client] (ecmascript)");
const Buffer = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)").Buffer;
const realZlib = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/browserify-zlib/index.js [app-client] (ecmascript)");
const constants = exports.constants = __turbopack_context__.r("[project]/node_modules/minizlib/constants.js [app-client] (ecmascript)");
const Minipass = __turbopack_context__.r("[project]/node_modules/minizlib/node_modules/minipass/index.js [app-client] (ecmascript)");
const OriginalBufferConcat = Buffer.concat;
const _superWrite = Symbol('_superWrite');
class ZlibError extends Error {
    constructor(err){
        super('zlib: ' + err.message);
        this.code = err.code;
        this.errno = err.errno;
        /* istanbul ignore if */ if (!this.code) this.code = 'ZLIB_ERROR';
        this.message = 'zlib: ' + err.message;
        Error.captureStackTrace(this, this.constructor);
    }
    get name() {
        return 'ZlibError';
    }
}
// the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.
const _opts = Symbol('opts');
const _flushFlag = Symbol('flushFlag');
const _finishFlushFlag = Symbol('finishFlushFlag');
const _fullFlushFlag = Symbol('fullFlushFlag');
const _handle = Symbol('handle');
const _onError = Symbol('onError');
const _sawError = Symbol('sawError');
const _level = Symbol('level');
const _strategy = Symbol('strategy');
const _ended = Symbol('ended');
const _defaultFullFlush = Symbol('_defaultFullFlush');
class ZlibBase extends Minipass {
    constructor(opts, mode){
        if (!opts || typeof opts !== 'object') throw new TypeError('invalid options for ZlibBase constructor');
        super(opts);
        this[_sawError] = false;
        this[_ended] = false;
        this[_opts] = opts;
        this[_flushFlag] = opts.flush;
        this[_finishFlushFlag] = opts.finishFlush;
        // this will throw if any options are invalid for the class selected
        try {
            this[_handle] = new realZlib[mode](opts);
        } catch (er) {
            // make sure that all errors get decorated properly
            throw new ZlibError(er);
        }
        this[_onError] = (err)=>{
            // no sense raising multiple errors, since we abort on the first one.
            if (this[_sawError]) return;
            this[_sawError] = true;
            // there is no way to cleanly recover.
            // continuing only obscures problems.
            this.close();
            this.emit('error', err);
        };
        this[_handle].on('error', (er)=>this[_onError](new ZlibError(er)));
        this.once('end', ()=>this.close);
    }
    close() {
        if (this[_handle]) {
            this[_handle].close();
            this[_handle] = null;
            this.emit('close');
        }
    }
    reset() {
        if (!this[_sawError]) {
            assert(this[_handle], 'zlib binding closed');
            return this[_handle].reset();
        }
    }
    flush(flushFlag) {
        if (this.ended) return;
        if (typeof flushFlag !== 'number') flushFlag = this[_fullFlushFlag];
        this.write(Object.assign(Buffer.alloc(0), {
            [_flushFlag]: flushFlag
        }));
    }
    end(chunk, encoding, cb) {
        if (chunk) this.write(chunk, encoding);
        this.flush(this[_finishFlushFlag]);
        this[_ended] = true;
        return super.end(null, null, cb);
    }
    get ended() {
        return this[_ended];
    }
    write(chunk, encoding, cb) {
        // process the chunk using the sync process
        // then super.write() all the outputted chunks
        if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';
        if (typeof chunk === 'string') chunk = Buffer.from(chunk, encoding);
        if (this[_sawError]) return;
        assert(this[_handle], 'zlib binding closed');
        // _processChunk tries to .close() the native handle after it's done, so we
        // intercept that by temporarily making it a no-op.
        const nativeHandle = this[_handle]._handle;
        const originalNativeClose = nativeHandle.close;
        nativeHandle.close = ()=>{};
        const originalClose = this[_handle].close;
        this[_handle].close = ()=>{};
        // It also calls `Buffer.concat()` at the end, which may be convenient
        // for some, but which we are not interested in as it slows us down.
        Buffer.concat = (args)=>args;
        let result;
        try {
            const flushFlag = typeof chunk[_flushFlag] === 'number' ? chunk[_flushFlag] : this[_flushFlag];
            result = this[_handle]._processChunk(chunk, flushFlag);
            // if we don't throw, reset it back how it was
            Buffer.concat = OriginalBufferConcat;
        } catch (err) {
            // or if we do, put Buffer.concat() back before we emit error
            // Error events call into user code, which may call Buffer.concat()
            Buffer.concat = OriginalBufferConcat;
            this[_onError](new ZlibError(err));
        } finally{
            if (this[_handle]) {
                // Core zlib resets `_handle` to null after attempting to close the
                // native handle. Our no-op handler prevented actual closure, but we
                // need to restore the `._handle` property.
                this[_handle]._handle = nativeHandle;
                nativeHandle.close = originalNativeClose;
                this[_handle].close = originalClose;
                // `_processChunk()` adds an 'error' listener. If we don't remove it
                // after each call, these handlers start piling up.
                this[_handle].removeAllListeners('error');
            // make sure OUR error listener is still attached tho
            }
        }
        if (this[_handle]) this[_handle].on('error', (er)=>this[_onError](new ZlibError(er)));
        let writeReturn;
        if (result) {
            if (Array.isArray(result) && result.length > 0) {
                // The first buffer is always `handle._outBuffer`, which would be
                // re-used for later invocations; so, we always have to copy that one.
                writeReturn = this[_superWrite](Buffer.from(result[0]));
                for(let i = 1; i < result.length; i++){
                    writeReturn = this[_superWrite](result[i]);
                }
            } else {
                writeReturn = this[_superWrite](Buffer.from(result));
            }
        }
        if (cb) cb();
        return writeReturn;
    }
    [_superWrite](data) {
        return super.write(data);
    }
}
class Zlib extends ZlibBase {
    constructor(opts, mode){
        opts = opts || {};
        opts.flush = opts.flush || constants.Z_NO_FLUSH;
        opts.finishFlush = opts.finishFlush || constants.Z_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants.Z_FULL_FLUSH;
        this[_level] = opts.level;
        this[_strategy] = opts.strategy;
    }
    params(level, strategy) {
        if (this[_sawError]) return;
        if (!this[_handle]) throw new Error('cannot switch params when binding is closed');
        // no way to test this without also not supporting params at all
        /* istanbul ignore if */ if (!this[_handle].params) throw new Error('not supported in this implementation');
        if (this[_level] !== level || this[_strategy] !== strategy) {
            this.flush(constants.Z_SYNC_FLUSH);
            assert(this[_handle], 'zlib binding closed');
            // .params() calls .flush(), but the latter is always async in the
            // core zlib. We override .flush() temporarily to intercept that and
            // flush synchronously.
            const origFlush = this[_handle].flush;
            this[_handle].flush = (flushFlag, cb)=>{
                this.flush(flushFlag);
                cb();
            };
            try {
                this[_handle].params(level, strategy);
            } finally{
                this[_handle].flush = origFlush;
            }
            /* istanbul ignore else */ if (this[_handle]) {
                this[_level] = level;
                this[_strategy] = strategy;
            }
        }
    }
}
// minimal 2-byte header
class Deflate extends Zlib {
    constructor(opts){
        super(opts, 'Deflate');
    }
}
class Inflate extends Zlib {
    constructor(opts){
        super(opts, 'Inflate');
    }
}
// gzip - bigger header, same deflate compression
const _portable = Symbol('_portable');
class Gzip extends Zlib {
    constructor(opts){
        super(opts, 'Gzip');
        this[_portable] = opts && !!opts.portable;
    }
    [_superWrite](data) {
        if (!this[_portable]) return super[_superWrite](data);
        // we'll always get the header emitted in one first chunk
        // overwrite the OS indicator byte with 0xFF
        this[_portable] = false;
        data[9] = 255;
        return super[_superWrite](data);
    }
}
class Gunzip extends Zlib {
    constructor(opts){
        super(opts, 'Gunzip');
    }
}
// raw - no header
class DeflateRaw extends Zlib {
    constructor(opts){
        super(opts, 'DeflateRaw');
    }
}
class InflateRaw extends Zlib {
    constructor(opts){
        super(opts, 'InflateRaw');
    }
}
// auto-detect header.
class Unzip extends Zlib {
    constructor(opts){
        super(opts, 'Unzip');
    }
}
class Brotli extends ZlibBase {
    constructor(opts, mode){
        opts = opts || {};
        opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;
        opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;
    }
}
class BrotliCompress extends Brotli {
    constructor(opts){
        super(opts, 'BrotliCompress');
    }
}
class BrotliDecompress extends Brotli {
    constructor(opts){
        super(opts, 'BrotliDecompress');
    }
}
exports.Deflate = Deflate;
exports.Inflate = Inflate;
exports.Gzip = Gzip;
exports.Gunzip = Gunzip;
exports.DeflateRaw = DeflateRaw;
exports.InflateRaw = InflateRaw;
exports.Unzip = Unzip;
/* istanbul ignore else */ if (typeof realZlib.BrotliCompress === 'function') {
    exports.BrotliCompress = BrotliCompress;
    exports.BrotliDecompress = BrotliDecompress;
} else {
    exports.BrotliCompress = exports.BrotliDecompress = class {
        constructor(){
            throw new Error('Brotli is not supported in this version of Node.js');
        }
    };
}
}}),
"[project]/node_modules/yallist/iterator.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function*() {
        for(let walker = this.head; walker; walker = walker.next){
            yield walker.value;
        }
    };
};
}}),
"[project]/node_modules/yallist/yallist.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = Yallist;
Yallist.Node = Node;
Yallist.create = Yallist;
function Yallist(list) {
    var self = this;
    if (!(self instanceof Yallist)) {
        self = new Yallist();
    }
    self.tail = null;
    self.head = null;
    self.length = 0;
    if (list && typeof list.forEach === 'function') {
        list.forEach(function(item) {
            self.push(item);
        });
    } else if (arguments.length > 0) {
        for(var i = 0, l = arguments.length; i < l; i++){
            self.push(arguments[i]);
        }
    }
    return self;
}
Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
        throw new Error('removing node which does not belong to this list');
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
        next.prev = prev;
    }
    if (prev) {
        prev.next = next;
    }
    if (node === this.head) {
        this.head = next;
    }
    if (node === this.tail) {
        this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
};
Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
        return;
    }
    if (node.list) {
        node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
        head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
        this.tail = node;
    }
    this.length++;
};
Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
        return;
    }
    if (node.list) {
        node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
        tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
        this.head = node;
    }
    this.length++;
};
Yallist.prototype.push = function() {
    for(var i = 0, l = arguments.length; i < l; i++){
        push(this, arguments[i]);
    }
    return this.length;
};
Yallist.prototype.unshift = function() {
    for(var i = 0, l = arguments.length; i < l; i++){
        unshift(this, arguments[i]);
    }
    return this.length;
};
Yallist.prototype.pop = function() {
    if (!this.tail) {
        return undefined;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
        this.tail.next = null;
    } else {
        this.head = null;
    }
    this.length--;
    return res;
};
Yallist.prototype.shift = function() {
    if (!this.head) {
        return undefined;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
        this.head.prev = null;
    } else {
        this.tail = null;
    }
    this.length--;
    return res;
};
Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for(var walker = this.head, i = 0; walker !== null; i++){
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
    }
};
Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for(var walker = this.tail, i = this.length - 1; walker !== null; i--){
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
    }
};
Yallist.prototype.get = function(n) {
    for(var i = 0, walker = this.head; walker !== null && i < n; i++){
        // abort out of the list early if we hit a cycle
        walker = walker.next;
    }
    if (i === n && walker !== null) {
        return walker.value;
    }
};
Yallist.prototype.getReverse = function(n) {
    for(var i = 0, walker = this.tail; walker !== null && i < n; i++){
        // abort out of the list early if we hit a cycle
        walker = walker.prev;
    }
    if (i === n && walker !== null) {
        return walker.value;
    }
};
Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for(var walker = this.head; walker !== null;){
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
    }
    return res;
};
Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for(var walker = this.tail; walker !== null;){
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
    }
    return res;
};
Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
        acc = initial;
    } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
    } else {
        throw new TypeError('Reduce of empty list with no initial value');
    }
    for(var i = 0; walker !== null; i++){
        acc = fn(acc, walker.value, i);
        walker = walker.next;
    }
    return acc;
};
Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
        acc = initial;
    } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
    } else {
        throw new TypeError('Reduce of empty list with no initial value');
    }
    for(var i = this.length - 1; walker !== null; i--){
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
    }
    return acc;
};
Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for(var i = 0, walker = this.head; walker !== null; i++){
        arr[i] = walker.value;
        walker = walker.next;
    }
    return arr;
};
Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for(var i = 0, walker = this.tail; walker !== null; i++){
        arr[i] = walker.value;
        walker = walker.prev;
    }
    return arr;
};
Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
        to += this.length;
    }
    from = from || 0;
    if (from < 0) {
        from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
        return ret;
    }
    if (from < 0) {
        from = 0;
    }
    if (to > this.length) {
        to = this.length;
    }
    for(var i = 0, walker = this.head; walker !== null && i < from; i++){
        walker = walker.next;
    }
    for(; walker !== null && i < to; i++, walker = walker.next){
        ret.push(walker.value);
    }
    return ret;
};
Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
        to += this.length;
    }
    from = from || 0;
    if (from < 0) {
        from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
        return ret;
    }
    if (from < 0) {
        from = 0;
    }
    if (to > this.length) {
        to = this.length;
    }
    for(var i = this.length, walker = this.tail; walker !== null && i > to; i--){
        walker = walker.prev;
    }
    for(; walker !== null && i > from; i--, walker = walker.prev){
        ret.push(walker.value);
    }
    return ret;
};
Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
        start = this.length - 1;
    }
    if (start < 0) {
        start = this.length + start;
    }
    for(var i = 0, walker = this.head; walker !== null && i < start; i++){
        walker = walker.next;
    }
    var ret = [];
    for(var i = 0; walker && i < deleteCount; i++){
        ret.push(walker.value);
        walker = this.removeNode(walker);
    }
    if (walker === null) {
        walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
    }
    for(var i = 0; i < nodes.length; i++){
        walker = insert(this, walker, nodes[i]);
    }
    return ret;
};
Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for(var walker = head; walker !== null; walker = walker.prev){
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
};
function insert(self, node, value) {
    var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
    if (inserted.next === null) {
        self.tail = inserted;
    }
    if (inserted.prev === null) {
        self.head = inserted;
    }
    self.length++;
    return inserted;
}
function push(self, item) {
    self.tail = new Node(item, self.tail, null, self);
    if (!self.head) {
        self.head = self.tail;
    }
    self.length++;
}
function unshift(self, item) {
    self.head = new Node(item, null, self.head, self);
    if (!self.tail) {
        self.tail = self.head;
    }
    self.length++;
}
function Node(value, prev, next, list) {
    if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
        prev.next = this;
        this.prev = prev;
    } else {
        this.prev = null;
    }
    if (next) {
        next.prev = this;
        this.next = next;
    } else {
        this.next = null;
    }
}
try {
    // add if support for Symbol.iterator is present
    __turbopack_context__.r("[project]/node_modules/yallist/iterator.js [app-client] (ecmascript)")(Yallist);
} catch (er) {}
}}),
"[project]/node_modules/fs-minipass/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
'use strict';
const MiniPass = __turbopack_context__.r("[project]/node_modules/fs-minipass/node_modules/minipass/index.js [app-client] (ecmascript)");
const EE = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)").EventEmitter;
const fs = (()=>{
    const e = new Error("Cannot find module 'fs'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
let writev = fs.writev;
/* istanbul ignore next */ if (!writev) {
    // This entire block can be removed if support for earlier than Node.js
    // 12.9.0 is not needed.
    const binding = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].binding('fs');
    const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
    writev = (fd, iovec, pos, cb)=>{
        const done = (er, bw)=>cb(er, bw, iovec);
        const req = new FSReqWrap();
        req.oncomplete = done;
        binding.writeBuffers(fd, iovec, pos, req);
    };
}
const _autoClose = Symbol('_autoClose');
const _close = Symbol('_close');
const _ended = Symbol('_ended');
const _fd = Symbol('_fd');
const _finished = Symbol('_finished');
const _flags = Symbol('_flags');
const _flush = Symbol('_flush');
const _handleChunk = Symbol('_handleChunk');
const _makeBuf = Symbol('_makeBuf');
const _mode = Symbol('_mode');
const _needDrain = Symbol('_needDrain');
const _onerror = Symbol('_onerror');
const _onopen = Symbol('_onopen');
const _onread = Symbol('_onread');
const _onwrite = Symbol('_onwrite');
const _open = Symbol('_open');
const _path = Symbol('_path');
const _pos = Symbol('_pos');
const _queue = Symbol('_queue');
const _read = Symbol('_read');
const _readSize = Symbol('_readSize');
const _reading = Symbol('_reading');
const _remain = Symbol('_remain');
const _size = Symbol('_size');
const _write = Symbol('_write');
const _writing = Symbol('_writing');
const _defaultFlag = Symbol('_defaultFlag');
const _errored = Symbol('_errored');
class ReadStream extends MiniPass {
    constructor(path, opt){
        opt = opt || {};
        super(opt);
        this.readable = true;
        this.writable = false;
        if (typeof path !== 'string') throw new TypeError('path must be a string');
        this[_errored] = false;
        this[_fd] = typeof opt.fd === 'number' ? opt.fd : null;
        this[_path] = path;
        this[_readSize] = opt.readSize || 16 * 1024 * 1024;
        this[_reading] = false;
        this[_size] = typeof opt.size === 'number' ? opt.size : Infinity;
        this[_remain] = this[_size];
        this[_autoClose] = typeof opt.autoClose === 'boolean' ? opt.autoClose : true;
        if (typeof this[_fd] === 'number') this[_read]();
        else this[_open]();
    }
    get fd() {
        return this[_fd];
    }
    get path() {
        return this[_path];
    }
    write() {
        throw new TypeError('this is a readable stream');
    }
    end() {
        throw new TypeError('this is a readable stream');
    }
    [_open]() {
        fs.open(this[_path], 'r', (er, fd)=>this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
        if (er) this[_onerror](er);
        else {
            this[_fd] = fd;
            this.emit('open', fd);
            this[_read]();
        }
    }
    [_makeBuf]() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].allocUnsafe(Math.min(this[_readSize], this[_remain]));
    }
    [_read]() {
        if (!this[_reading]) {
            this[_reading] = true;
            const buf = this[_makeBuf]();
            /* istanbul ignore if */ if (buf.length === 0) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(()=>this[_onread](null, 0, buf));
            fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf)=>this[_onread](er, br, buf));
        }
    }
    [_onread](er, br, buf) {
        this[_reading] = false;
        if (er) this[_onerror](er);
        else if (this[_handleChunk](br, buf)) this[_read]();
    }
    [_close]() {
        if (this[_autoClose] && typeof this[_fd] === 'number') {
            const fd = this[_fd];
            this[_fd] = null;
            fs.close(fd, (er)=>er ? this.emit('error', er) : this.emit('close'));
        }
    }
    [_onerror](er) {
        this[_reading] = true;
        this[_close]();
        this.emit('error', er);
    }
    [_handleChunk](br, buf) {
        let ret = false;
        // no effect if infinite
        this[_remain] -= br;
        if (br > 0) ret = super.write(br < buf.length ? buf.slice(0, br) : buf);
        if (br === 0 || this[_remain] <= 0) {
            ret = false;
            this[_close]();
            super.end();
        }
        return ret;
    }
    emit(ev, data) {
        switch(ev){
            case 'prefinish':
            case 'finish':
                break;
            case 'drain':
                if (typeof this[_fd] === 'number') this[_read]();
                break;
            case 'error':
                if (this[_errored]) return;
                this[_errored] = true;
                return super.emit(ev, data);
            default:
                return super.emit(ev, data);
        }
    }
}
class ReadStreamSync extends ReadStream {
    [_open]() {
        let threw = true;
        try {
            this[_onopen](null, fs.openSync(this[_path], 'r'));
            threw = false;
        } finally{
            if (threw) this[_close]();
        }
    }
    [_read]() {
        let threw = true;
        try {
            if (!this[_reading]) {
                this[_reading] = true;
                do {
                    const buf = this[_makeBuf]();
                    /* istanbul ignore next */ const br = buf.length === 0 ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null);
                    if (!this[_handleChunk](br, buf)) break;
                }while (true)
                this[_reading] = false;
            }
            threw = false;
        } finally{
            if (threw) this[_close]();
        }
    }
    [_close]() {
        if (this[_autoClose] && typeof this[_fd] === 'number') {
            const fd = this[_fd];
            this[_fd] = null;
            fs.closeSync(fd);
            this.emit('close');
        }
    }
}
class WriteStream extends EE {
    constructor(path, opt){
        opt = opt || {};
        super(opt);
        this.readable = false;
        this.writable = true;
        this[_errored] = false;
        this[_writing] = false;
        this[_ended] = false;
        this[_needDrain] = false;
        this[_queue] = [];
        this[_path] = path;
        this[_fd] = typeof opt.fd === 'number' ? opt.fd : null;
        this[_mode] = opt.mode === undefined ? 0o666 : opt.mode;
        this[_pos] = typeof opt.start === 'number' ? opt.start : null;
        this[_autoClose] = typeof opt.autoClose === 'boolean' ? opt.autoClose : true;
        // truncating makes no sense when writing into the middle
        const defaultFlag = this[_pos] !== null ? 'r+' : 'w';
        this[_defaultFlag] = opt.flags === undefined;
        this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;
        if (this[_fd] === null) this[_open]();
    }
    emit(ev, data) {
        if (ev === 'error') {
            if (this[_errored]) return;
            this[_errored] = true;
        }
        return super.emit(ev, data);
    }
    get fd() {
        return this[_fd];
    }
    get path() {
        return this[_path];
    }
    [_onerror](er) {
        this[_close]();
        this[_writing] = true;
        this.emit('error', er);
    }
    [_open]() {
        fs.open(this[_path], this[_flags], this[_mode], (er, fd)=>this[_onopen](er, fd));
    }
    [_onopen](er, fd) {
        if (this[_defaultFlag] && this[_flags] === 'r+' && er && er.code === 'ENOENT') {
            this[_flags] = 'w';
            this[_open]();
        } else if (er) this[_onerror](er);
        else {
            this[_fd] = fd;
            this.emit('open', fd);
            this[_flush]();
        }
    }
    end(buf, enc) {
        if (buf) this.write(buf, enc);
        this[_ended] = true;
        // synthetic after-write logic, where drain/finish live
        if (!this[_writing] && !this[_queue].length && typeof this[_fd] === 'number') this[_onwrite](null, 0);
        return this;
    }
    write(buf, enc) {
        if (typeof buf === 'string') buf = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(buf, enc);
        if (this[_ended]) {
            this.emit('error', new Error('write() after end()'));
            return false;
        }
        if (this[_fd] === null || this[_writing] || this[_queue].length) {
            this[_queue].push(buf);
            this[_needDrain] = true;
            return false;
        }
        this[_writing] = true;
        this[_write](buf);
        return true;
    }
    [_write](buf) {
        fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw)=>this[_onwrite](er, bw));
    }
    [_onwrite](er, bw) {
        if (er) this[_onerror](er);
        else {
            if (this[_pos] !== null) this[_pos] += bw;
            if (this[_queue].length) this[_flush]();
            else {
                this[_writing] = false;
                if (this[_ended] && !this[_finished]) {
                    this[_finished] = true;
                    this[_close]();
                    this.emit('finish');
                } else if (this[_needDrain]) {
                    this[_needDrain] = false;
                    this.emit('drain');
                }
            }
        }
    }
    [_flush]() {
        if (this[_queue].length === 0) {
            if (this[_ended]) this[_onwrite](null, 0);
        } else if (this[_queue].length === 1) this[_write](this[_queue].pop());
        else {
            const iovec = this[_queue];
            this[_queue] = [];
            writev(this[_fd], iovec, this[_pos], (er, bw)=>this[_onwrite](er, bw));
        }
    }
    [_close]() {
        if (this[_autoClose] && typeof this[_fd] === 'number') {
            const fd = this[_fd];
            this[_fd] = null;
            fs.close(fd, (er)=>er ? this.emit('error', er) : this.emit('close'));
        }
    }
}
class WriteStreamSync extends WriteStream {
    [_open]() {
        let fd;
        // only wrap in a try{} block if we know we'll retry, to avoid
        // the rethrow obscuring the error's source frame in most cases.
        if (this[_defaultFlag] && this[_flags] === 'r+') {
            try {
                fd = fs.openSync(this[_path], this[_flags], this[_mode]);
            } catch (er) {
                if (er.code === 'ENOENT') {
                    this[_flags] = 'w';
                    return this[_open]();
                } else throw er;
            }
        } else fd = fs.openSync(this[_path], this[_flags], this[_mode]);
        this[_onopen](null, fd);
    }
    [_close]() {
        if (this[_autoClose] && typeof this[_fd] === 'number') {
            const fd = this[_fd];
            this[_fd] = null;
            fs.closeSync(fd);
            this.emit('close');
        }
    }
    [_write](buf) {
        // throw the original, but try to close if it fails
        let threw = true;
        try {
            this[_onwrite](null, fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));
            threw = false;
        } finally{
            if (threw) try {
                this[_close]();
            } catch (_) {}
        }
    }
}
exports.ReadStream = ReadStream;
exports.ReadStreamSync = ReadStreamSync;
exports.WriteStream = WriteStream;
exports.WriteStreamSync = WriteStreamSync;
}}),
"[project]/node_modules/process/browser.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function() {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}
function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len){
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for(var i = 1; i < arguments.length; i++){
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error('process.binding is not supported');
};
process.cwd = function() {
    return '/';
};
process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() {
    return 0;
};
}}),
"[project]/node_modules/mkdirp/lib/opts-arg.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const { promisify } = __turbopack_context__.r("[project]/node_modules/util/util.js [app-client] (ecmascript)");
const fs = (()=>{
    const e = new Error("Cannot find module 'fs'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
const optsArg = (opts)=>{
    if (!opts) opts = {
        mode: 0o777,
        fs
    };
    else if (typeof opts === 'object') opts = {
        mode: 0o777,
        fs,
        ...opts
    };
    else if (typeof opts === 'number') opts = {
        mode: opts,
        fs
    };
    else if (typeof opts === 'string') opts = {
        mode: parseInt(opts, 8),
        fs
    };
    else throw new TypeError('invalid options argument');
    opts.mkdir = opts.mkdir || opts.fs.mkdir || fs.mkdir;
    opts.mkdirAsync = promisify(opts.mkdir);
    opts.stat = opts.stat || opts.fs.stat || fs.stat;
    opts.statAsync = promisify(opts.stat);
    opts.statSync = opts.statSync || opts.fs.statSync || fs.statSync;
    opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs.mkdirSync;
    return opts;
};
module.exports = optsArg;
}}),
"[project]/node_modules/mkdirp/lib/path-arg.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
const platform = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.__TESTING_MKDIRP_PLATFORM__ || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform;
const { resolve, parse } = __turbopack_context__.r("[project]/node_modules/path/path.js [app-client] (ecmascript)");
const pathArg = (path)=>{
    if (/\0/.test(path)) {
        // simulate same failure that node raises
        throw Object.assign(new TypeError('path must be a string without null bytes'), {
            path,
            code: 'ERR_INVALID_ARG_VALUE'
        });
    }
    path = resolve(path);
    if (platform === 'win32') {
        const badWinChars = /[*|"<>?:]/;
        const { root } = parse(path);
        if (badWinChars.test(path.substr(root.length))) {
            throw Object.assign(new Error('Illegal characters in path.'), {
                path,
                code: 'EINVAL'
            });
        }
    }
    return path;
};
module.exports = pathArg;
}}),
"[project]/node_modules/mkdirp/lib/find-made.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const { dirname } = __turbopack_context__.r("[project]/node_modules/path/path.js [app-client] (ecmascript)");
const findMade = (opts, parent, path = undefined)=>{
    // we never want the 'made' return value to be a root directory
    if (path === parent) return Promise.resolve();
    return opts.statAsync(parent).then((st)=>st.isDirectory() ? path : undefined, (er)=>er.code === 'ENOENT' ? findMade(opts, dirname(parent), parent) : undefined);
};
const findMadeSync = (opts, parent, path = undefined)=>{
    if (path === parent) return undefined;
    try {
        return opts.statSync(parent).isDirectory() ? path : undefined;
    } catch (er) {
        return er.code === 'ENOENT' ? findMadeSync(opts, dirname(parent), parent) : undefined;
    }
};
module.exports = {
    findMade,
    findMadeSync
};
}}),
"[project]/node_modules/mkdirp/lib/mkdirp-manual.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const { dirname } = __turbopack_context__.r("[project]/node_modules/path/path.js [app-client] (ecmascript)");
const mkdirpManual = (path, opts, made)=>{
    opts.recursive = false;
    const parent = dirname(path);
    if (parent === path) {
        return opts.mkdirAsync(path, opts).catch((er)=>{
            // swallowed by recursive implementation on posix systems
            // any other error is a failure
            if (er.code !== 'EISDIR') throw er;
        });
    }
    return opts.mkdirAsync(path, opts).then(()=>made || path, (er)=>{
        if (er.code === 'ENOENT') return mkdirpManual(parent, opts).then((made)=>mkdirpManual(path, opts, made));
        if (er.code !== 'EEXIST' && er.code !== 'EROFS') throw er;
        return opts.statAsync(path).then((st)=>{
            if (st.isDirectory()) return made;
            else throw er;
        }, ()=>{
            throw er;
        });
    });
};
const mkdirpManualSync = (path, opts, made)=>{
    const parent = dirname(path);
    opts.recursive = false;
    if (parent === path) {
        try {
            return opts.mkdirSync(path, opts);
        } catch (er) {
            // swallowed by recursive implementation on posix systems
            // any other error is a failure
            if (er.code !== 'EISDIR') throw er;
            else return;
        }
    }
    try {
        opts.mkdirSync(path, opts);
        return made || path;
    } catch (er) {
        if (er.code === 'ENOENT') return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made));
        if (er.code !== 'EEXIST' && er.code !== 'EROFS') throw er;
        try {
            if (!opts.statSync(path).isDirectory()) throw er;
        } catch (_) {
            throw er;
        }
    }
};
module.exports = {
    mkdirpManual,
    mkdirpManualSync
};
}}),
"[project]/node_modules/mkdirp/lib/mkdirp-native.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const { dirname } = __turbopack_context__.r("[project]/node_modules/path/path.js [app-client] (ecmascript)");
const { findMade, findMadeSync } = __turbopack_context__.r("[project]/node_modules/mkdirp/lib/find-made.js [app-client] (ecmascript)");
const { mkdirpManual, mkdirpManualSync } = __turbopack_context__.r("[project]/node_modules/mkdirp/lib/mkdirp-manual.js [app-client] (ecmascript)");
const mkdirpNative = (path, opts)=>{
    opts.recursive = true;
    const parent = dirname(path);
    if (parent === path) return opts.mkdirAsync(path, opts);
    return findMade(opts, path).then((made)=>opts.mkdirAsync(path, opts).then(()=>made).catch((er)=>{
            if (er.code === 'ENOENT') return mkdirpManual(path, opts);
            else throw er;
        }));
};
const mkdirpNativeSync = (path, opts)=>{
    opts.recursive = true;
    const parent = dirname(path);
    if (parent === path) return opts.mkdirSync(path, opts);
    const made = findMadeSync(opts, path);
    try {
        opts.mkdirSync(path, opts);
        return made;
    } catch (er) {
        if (er.code === 'ENOENT') return mkdirpManualSync(path, opts);
        else throw er;
    }
};
module.exports = {
    mkdirpNative,
    mkdirpNativeSync
};
}}),
"[project]/node_modules/mkdirp/lib/use-native.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
const fs = (()=>{
    const e = new Error("Cannot find module 'fs'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
const version = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.__TESTING_MKDIRP_NODE_VERSION__ || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].version;
const versArr = version.replace(/^v/, '').split('.');
const hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
const useNative = !hasNative ? ()=>false : (opts)=>opts.mkdir === fs.mkdir;
const useNativeSync = !hasNative ? ()=>false : (opts)=>opts.mkdirSync === fs.mkdirSync;
module.exports = {
    useNative,
    useNativeSync
};
}}),
"[project]/node_modules/mkdirp/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const optsArg = __turbopack_context__.r("[project]/node_modules/mkdirp/lib/opts-arg.js [app-client] (ecmascript)");
const pathArg = __turbopack_context__.r("[project]/node_modules/mkdirp/lib/path-arg.js [app-client] (ecmascript)");
const { mkdirpNative, mkdirpNativeSync } = __turbopack_context__.r("[project]/node_modules/mkdirp/lib/mkdirp-native.js [app-client] (ecmascript)");
const { mkdirpManual, mkdirpManualSync } = __turbopack_context__.r("[project]/node_modules/mkdirp/lib/mkdirp-manual.js [app-client] (ecmascript)");
const { useNative, useNativeSync } = __turbopack_context__.r("[project]/node_modules/mkdirp/lib/use-native.js [app-client] (ecmascript)");
const mkdirp = (path, opts)=>{
    path = pathArg(path);
    opts = optsArg(opts);
    return useNative(opts) ? mkdirpNative(path, opts) : mkdirpManual(path, opts);
};
const mkdirpSync = (path, opts)=>{
    path = pathArg(path);
    opts = optsArg(opts);
    return useNativeSync(opts) ? mkdirpNativeSync(path, opts) : mkdirpManualSync(path, opts);
};
mkdirp.sync = mkdirpSync;
mkdirp.native = (path, opts)=>mkdirpNative(pathArg(path), optsArg(opts));
mkdirp.manual = (path, opts)=>mkdirpManual(pathArg(path), optsArg(opts));
mkdirp.nativeSync = (path, opts)=>mkdirpNativeSync(pathArg(path), optsArg(opts));
mkdirp.manualSync = (path, opts)=>mkdirpManualSync(pathArg(path), optsArg(opts));
module.exports = mkdirp;
}}),
"[project]/node_modules/chownr/chownr.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
const fs = (()=>{
    const e = new Error("Cannot find module 'fs'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
const path = __turbopack_context__.r("[project]/node_modules/path/path.js [app-client] (ecmascript)");
/* istanbul ignore next */ const LCHOWN = fs.lchown ? 'lchown' : 'chown';
/* istanbul ignore next */ const LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync';
/* istanbul ignore next */ const needEISDIRHandled = fs.lchown && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].version.match(/v1[1-9]+\./) && !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].version.match(/v10\.[6-9]/);
const lchownSync = (path, uid, gid)=>{
    try {
        return fs[LCHOWNSYNC](path, uid, gid);
    } catch (er) {
        if (er.code !== 'ENOENT') throw er;
    }
};
/* istanbul ignore next */ const chownSync = (path, uid, gid)=>{
    try {
        return fs.chownSync(path, uid, gid);
    } catch (er) {
        if (er.code !== 'ENOENT') throw er;
    }
};
/* istanbul ignore next */ const handleEISDIR = needEISDIRHandled ? (path, uid, gid, cb)=>(er)=>{
        // Node prior to v10 had a very questionable implementation of
        // fs.lchown, which would always try to call fs.open on a directory
        // Fall back to fs.chown in those cases.
        if (!er || er.code !== 'EISDIR') cb(er);
        else fs.chown(path, uid, gid, cb);
    } : (_, __, ___, cb)=>cb;
/* istanbul ignore next */ const handleEISDirSync = needEISDIRHandled ? (path, uid, gid)=>{
    try {
        return lchownSync(path, uid, gid);
    } catch (er) {
        if (er.code !== 'EISDIR') throw er;
        chownSync(path, uid, gid);
    }
} : (path, uid, gid)=>lchownSync(path, uid, gid);
// fs.readdir could only accept an options object as of node v6
const nodeVersion = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].version;
let readdir = (path, options, cb)=>fs.readdir(path, options, cb);
let readdirSync = (path, options)=>fs.readdirSync(path, options);
/* istanbul ignore next */ if (/^v4\./.test(nodeVersion)) readdir = (path, options, cb)=>fs.readdir(path, cb);
const chown = (cpath, uid, gid, cb)=>{
    fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er)=>{
        // Skip ENOENT error
        cb(er && er.code !== 'ENOENT' ? er : null);
    }));
};
const chownrKid = (p, child, uid, gid, cb)=>{
    if (typeof child === 'string') return fs.lstat(path.resolve(p, child), (er, stats)=>{
        // Skip ENOENT error
        if (er) return cb(er.code !== 'ENOENT' ? er : null);
        stats.name = child;
        chownrKid(p, stats, uid, gid, cb);
    });
    if (child.isDirectory()) {
        chownr(path.resolve(p, child.name), uid, gid, (er)=>{
            if (er) return cb(er);
            const cpath = path.resolve(p, child.name);
            chown(cpath, uid, gid, cb);
        });
    } else {
        const cpath = path.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
    }
};
const chownr = (p, uid, gid, cb)=>{
    readdir(p, {
        withFileTypes: true
    }, (er, children)=>{
        // any error other than ENOTDIR or ENOTSUP means it's not readable,
        // or doesn't exist.  give up.
        if (er) {
            if (er.code === 'ENOENT') return cb();
            else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP') return cb(er);
        }
        if (er || !children.length) return chown(p, uid, gid, cb);
        let len = children.length;
        let errState = null;
        const then = (er)=>{
            if (errState) return;
            if (er) return cb(errState = er);
            if (--len === 0) return chown(p, uid, gid, cb);
        };
        children.forEach((child)=>chownrKid(p, child, uid, gid, then));
    });
};
const chownrKidSync = (p, child, uid, gid)=>{
    if (typeof child === 'string') {
        try {
            const stats = fs.lstatSync(path.resolve(p, child));
            stats.name = child;
            child = stats;
        } catch (er) {
            if (er.code === 'ENOENT') return;
            else throw er;
        }
    }
    if (child.isDirectory()) chownrSync(path.resolve(p, child.name), uid, gid);
    handleEISDirSync(path.resolve(p, child.name), uid, gid);
};
const chownrSync = (p, uid, gid)=>{
    let children;
    try {
        children = readdirSync(p, {
            withFileTypes: true
        });
    } catch (er) {
        if (er.code === 'ENOENT') return;
        else if (er.code === 'ENOTDIR' || er.code === 'ENOTSUP') return handleEISDirSync(p, uid, gid);
        else throw er;
    }
    if (children && children.length) children.forEach((child)=>chownrKidSync(p, child, uid, gid));
    return handleEISDirSync(p, uid, gid);
};
module.exports = chownr;
chownr.sync = chownrSync;
}}),
"[project]/node_modules/ms/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Helpers.
 */ var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
        return parse(val);
    } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) {
        return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch(type){
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
        return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}
}}),
"[project]/node_modules/debug/src/common.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = __turbopack_context__.r("[project]/node_modules/ms/index.js [app-client] (ecmascript)");
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {};
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) {
                return;
            }
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== 'string') {
                // Anything else let's inspect with %O
                args.unshift('%O');
            }
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === '%%') {
                    return '%';
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === 'function') {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, 'enabled', {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) {
                    return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === 'function') {
            createDebug.init(debug);
        }
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(' ', ',').split(',').filter(Boolean);
        for (const ns of split){
            if (ns[0] === '-') {
                createDebug.skips.push(ns.slice(1));
            } else {
                createDebug.names.push(ns);
            }
        }
    }
    /**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */ function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while(searchIndex < search.length){
            if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
                // Match character or proceed with wildcard
                if (template[templateIndex] === '*') {
                    starIndex = templateIndex;
                    matchIndex = searchIndex;
                    templateIndex++; // Skip the '*'
                } else {
                    searchIndex++;
                    templateIndex++;
                }
            } else if (starIndex !== -1) {
                // Backtrack to the last '*' and try to match more characters
                templateIndex = starIndex + 1;
                matchIndex++;
                searchIndex = matchIndex;
            } else {
                return false; // No match
            }
        }
        // Handle trailing '*' in template
        while(templateIndex < template.length && template[templateIndex] === '*'){
            templateIndex++;
        }
        return templateIndex === template.length;
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names,
            ...createDebug.skips.map((namespace)=>'-' + namespace)
        ].join(',');
        createDebug.enable('');
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        for (const skip of createDebug.skips){
            if (matchesTemplate(name, skip)) {
                return false;
            }
        }
        for (const ns of createDebug.names){
            if (matchesTemplate(name, ns)) {
                return true;
            }
        }
        return false;
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) {
            return val.stack || val.message;
        }
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;
}}),
"[project]/node_modules/debug/src/browser.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33'
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
        return true;
    }
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
    }
    let m;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    // eslint-disable-next-line no-return-assign
    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
    if (!this.useColors) {
        return;
    }
    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === '%%') {
            return;
        }
        index++;
        if (match === '%c') {
            // We only are interested in the *last* %c
            // (the user may have provided their own)
            lastC = index;
        }
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) {
            exports.storage.setItem('debug', namespaces);
        } else {
            exports.storage.removeItem('debug');
        }
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem('debug');
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && 'env' in __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]) {
        r = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.DEBUG;
    }
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/common.js [app-client] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
    }
};
}}),
"[project]/node_modules/agent-base/dist/src/promisify.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function promisify(fn) {
    return function(req, opts) {
        return new Promise((resolve, reject)=>{
            fn.call(this, req, opts, (err, rtn)=>{
                if (err) {
                    reject(err);
                } else {
                    resolve(rtn);
                }
            });
        });
    };
}
exports.default = promisify; //# sourceMappingURL=promisify.js.map
}}),
"[project]/node_modules/agent-base/dist/src/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
const events_1 = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/events/events.js [app-client] (ecmascript)");
const debug_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/debug/src/browser.js [app-client] (ecmascript)"));
const promisify_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/agent-base/dist/src/promisify.js [app-client] (ecmascript)"));
const debug = debug_1.default('agent-base');
function isAgent(v) {
    return Boolean(v) && typeof v.addRequest === 'function';
}
function isSecureEndpoint() {
    const { stack } = new Error();
    if (typeof stack !== 'string') return false;
    return stack.split('\n').some((l)=>l.indexOf('(https.js:') !== -1 || l.indexOf('node:https:') !== -1);
}
function createAgent(callback, opts) {
    return new createAgent.Agent(callback, opts);
}
(function(createAgent) {
    /**
     * Base `http.Agent` implementation.
     * No pooling/keep-alive is implemented by default.
     *
     * @param {Function} callback
     * @api public
     */ class Agent extends events_1.EventEmitter {
        constructor(callback, _opts){
            super();
            let opts = _opts;
            if (typeof callback === 'function') {
                this.callback = callback;
            } else if (callback) {
                opts = callback;
            }
            // Timeout for the socket to be returned from the callback
            this.timeout = null;
            if (opts && typeof opts.timeout === 'number') {
                this.timeout = opts.timeout;
            }
            // These aren't actually used by `agent-base`, but are required
            // for the TypeScript definition files in `@types/node` :/
            this.maxFreeSockets = 1;
            this.maxSockets = 1;
            this.maxTotalSockets = Infinity;
            this.sockets = {};
            this.freeSockets = {};
            this.requests = {};
            this.options = {};
        }
        get defaultPort() {
            if (typeof this.explicitDefaultPort === 'number') {
                return this.explicitDefaultPort;
            }
            return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
            this.explicitDefaultPort = v;
        }
        get protocol() {
            if (typeof this.explicitProtocol === 'string') {
                return this.explicitProtocol;
            }
            return isSecureEndpoint() ? 'https:' : 'http:';
        }
        set protocol(v) {
            this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
            throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        /**
         * Called by node-core's "_http_client.js" module when creating
         * a new HTTP request with this Agent instance.
         *
         * @api public
         */ addRequest(req, _opts) {
            const opts = Object.assign({}, _opts);
            if (typeof opts.secureEndpoint !== 'boolean') {
                opts.secureEndpoint = isSecureEndpoint();
            }
            if (opts.host == null) {
                opts.host = 'localhost';
            }
            if (opts.port == null) {
                opts.port = opts.secureEndpoint ? 443 : 80;
            }
            if (opts.protocol == null) {
                opts.protocol = opts.secureEndpoint ? 'https:' : 'http:';
            }
            if (opts.host && opts.path) {
                // If both a `host` and `path` are specified then it's most
                // likely the result of a `url.parse()` call... we need to
                // remove the `path` portion so that `net.connect()` doesn't
                // attempt to open that as a unix socket file.
                delete opts.path;
            }
            delete opts.agent;
            delete opts.hostname;
            delete opts._defaultAgent;
            delete opts.defaultPort;
            delete opts.createConnection;
            // Hint to use "Connection: close"
            // XXX: non-documented `http` module API :(
            req._last = true;
            req.shouldKeepAlive = false;
            let timedOut = false;
            let timeoutId = null;
            const timeoutMs = opts.timeout || this.timeout;
            const onerror = (err)=>{
                if (req._hadError) return;
                req.emit('error', err);
                // For Safety. Some additional errors might fire later on
                // and we need to make sure we don't double-fire the error event.
                req._hadError = true;
            };
            const ontimeout = ()=>{
                timeoutId = null;
                timedOut = true;
                const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
                err.code = 'ETIMEOUT';
                onerror(err);
            };
            const callbackError = (err)=>{
                if (timedOut) return;
                if (timeoutId !== null) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
                onerror(err);
            };
            const onsocket = (socket)=>{
                if (timedOut) return;
                if (timeoutId != null) {
                    clearTimeout(timeoutId);
                    timeoutId = null;
                }
                if (isAgent(socket)) {
                    // `socket` is actually an `http.Agent` instance, so
                    // relinquish responsibility for this `req` to the Agent
                    // from here on
                    debug('Callback returned another Agent instance %o', socket.constructor.name);
                    socket.addRequest(req, opts);
                    return;
                }
                if (socket) {
                    socket.once('free', ()=>{
                        this.freeSocket(socket, opts);
                    });
                    req.onSocket(socket);
                    return;
                }
                const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
                onerror(err);
            };
            if (typeof this.callback !== 'function') {
                onerror(new Error('`callback` is not defined'));
                return;
            }
            if (!this.promisifiedCallback) {
                if (this.callback.length >= 3) {
                    debug('Converting legacy callback function to promise');
                    this.promisifiedCallback = promisify_1.default(this.callback);
                } else {
                    this.promisifiedCallback = this.callback;
                }
            }
            if (typeof timeoutMs === 'number' && timeoutMs > 0) {
                timeoutId = setTimeout(ontimeout, timeoutMs);
            }
            if ('port' in opts && typeof opts.port !== 'number') {
                opts.port = Number(opts.port);
            }
            try {
                debug('Resolving socket for %o request: %o', opts.protocol, `${req.method} ${req.path}`);
                Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
            } catch (err) {
                Promise.reject(err).catch(callbackError);
            }
        }
        freeSocket(socket, opts) {
            debug('Freeing socket %o %o', socket.constructor.name, opts);
            socket.destroy();
        }
        destroy() {
            debug('Destroying agent %o', this.constructor.name);
        }
    }
    createAgent.Agent = Agent;
    // So that `instanceof` works correctly
    createAgent.prototype = createAgent.Agent.prototype;
})(createAgent || (createAgent = {}));
module.exports = createAgent; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/https-proxy-agent/dist/parse-proxy-response.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const debug_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/debug/src/browser.js [app-client] (ecmascript)"));
const debug = debug_1.default('https-proxy-agent:parse-proxy-response');
function parseProxyResponse(socket) {
    return new Promise((resolve, reject)=>{
        // we need to buffer any HTTP traffic that happens with the proxy before we get
        // the CONNECT response, so that if the response is anything other than an "200"
        // response code, then we can re-play the "data" events on the socket once the
        // HTTP parser is hooked up...
        let buffersLength = 0;
        const buffers = [];
        function read() {
            const b = socket.read();
            if (b) ondata(b);
            else socket.once('readable', read);
        }
        function cleanup() {
            socket.removeListener('end', onend);
            socket.removeListener('error', onerror);
            socket.removeListener('close', onclose);
            socket.removeListener('readable', read);
        }
        function onclose(err) {
            debug('onclose had error %o', err);
        }
        function onend() {
            debug('onend');
        }
        function onerror(err) {
            cleanup();
            debug('onerror %o', err);
            reject(err);
        }
        function ondata(b) {
            buffers.push(b);
            buffersLength += b.length;
            const buffered = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat(buffers, buffersLength);
            const endOfHeaders = buffered.indexOf('\r\n\r\n');
            if (endOfHeaders === -1) {
                // keep buffering
                debug('have not received end of HTTP headers yet...');
                read();
                return;
            }
            const firstLine = buffered.toString('ascii', 0, buffered.indexOf('\r\n'));
            const statusCode = +firstLine.split(' ')[1];
            debug('got proxy server response: %o', firstLine);
            resolve({
                statusCode,
                buffered
            });
        }
        socket.on('error', onerror);
        socket.on('close', onclose);
        socket.on('end', onend);
        read();
    });
}
exports.default = parseProxyResponse; //# sourceMappingURL=parse-proxy-response.js.map
}}),
"[project]/node_modules/https-proxy-agent/dist/agent.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
"use strict";
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const net_1 = __importDefault((()=>{
    const e = new Error("Cannot find module 'net'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})());
const tls_1 = __importDefault((()=>{
    const e = new Error("Cannot find module 'tls'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})());
const url_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/native-url/index.js [app-client] (ecmascript)"));
const assert_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/assert/assert.js [app-client] (ecmascript)"));
const debug_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/debug/src/browser.js [app-client] (ecmascript)"));
const agent_base_1 = __turbopack_context__.r("[project]/node_modules/agent-base/dist/src/index.js [app-client] (ecmascript)");
const parse_proxy_response_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/https-proxy-agent/dist/parse-proxy-response.js [app-client] (ecmascript)"));
const debug = debug_1.default('https-proxy-agent:agent');
/**
 * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to
 * the specified "HTTP(s) proxy server" in order to proxy HTTPS requests.
 *
 * Outgoing HTTP requests are first tunneled through the proxy server using the
 * `CONNECT` HTTP request method to establish a connection to the proxy server,
 * and then the proxy server connects to the destination target and issues the
 * HTTP request from the proxy server.
 *
 * `https:` requests have their socket connection upgraded to TLS once
 * the connection to the proxy server has been established.
 *
 * @api public
 */ class HttpsProxyAgent extends agent_base_1.Agent {
    constructor(_opts){
        let opts;
        if (typeof _opts === 'string') {
            opts = url_1.default.parse(_opts);
        } else {
            opts = _opts;
        }
        if (!opts) {
            throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');
        }
        debug('creating new HttpsProxyAgent instance: %o', opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        // If `true`, then connect to the proxy server over TLS.
        // Defaults to `false`.
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        // Prefer `hostname` over `host`, and set the `port` if needed.
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === 'string') {
            proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
            proxy.port = this.secureProxy ? 443 : 80;
        }
        // ALPN is supported by Node.js >= v5.
        // attempt to negotiate http/1.1 for proxy servers that support http/2
        if (this.secureProxy && !('ALPNProtocols' in proxy)) {
            proxy.ALPNProtocols = [
                'http 1.1'
            ];
        }
        if (proxy.host && proxy.path) {
            // If both a `host` and `path` are specified then it's most likely
            // the result of a `url.parse()` call... we need to remove the
            // `path` portion so that `net.connect()` doesn't attempt to open
            // that as a Unix socket file.
            delete proxy.path;
            delete proxy.pathname;
        }
        this.proxy = proxy;
    }
    /**
     * Called when the node-core HTTP client library is creating a
     * new HTTP request.
     *
     * @api protected
     */ callback(req, opts) {
        return __awaiter(this, void 0, void 0, function*() {
            const { proxy, secureProxy } = this;
            // Create a socket connection to the proxy server.
            let socket;
            if (secureProxy) {
                debug('Creating `tls.Socket`: %o', proxy);
                socket = tls_1.default.connect(proxy);
            } else {
                debug('Creating `net.Socket`: %o', proxy);
                socket = net_1.default.connect(proxy);
            }
            const headers = Object.assign({}, proxy.headers);
            const hostname = `${opts.host}:${opts.port}`;
            let payload = `CONNECT ${hostname} HTTP/1.1\r\n`;
            // Inject the `Proxy-Authorization` header if necessary.
            if (proxy.auth) {
                headers['Proxy-Authorization'] = `Basic ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(proxy.auth).toString('base64')}`;
            }
            // The `Host` header should only include the port
            // number when it is not the default port.
            let { host, port, secureEndpoint } = opts;
            if (!isDefaultPort(port, secureEndpoint)) {
                host += `:${port}`;
            }
            headers.Host = host;
            headers.Connection = 'close';
            for (const name of Object.keys(headers)){
                payload += `${name}: ${headers[name]}\r\n`;
            }
            const proxyResponsePromise = parse_proxy_response_1.default(socket);
            socket.write(`${payload}\r\n`);
            const { statusCode, buffered } = yield proxyResponsePromise;
            if (statusCode === 200) {
                req.once('socket', resume);
                if (opts.secureEndpoint) {
                    // The proxy is connecting to a TLS server, so upgrade
                    // this socket connection to a TLS connection.
                    debug('Upgrading socket connection to TLS');
                    const servername = opts.servername || opts.host;
                    return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, 'host', 'hostname', 'path', 'port')), {
                        socket,
                        servername
                    }));
                }
                return socket;
            }
            // Some other status code that's not 200... need to re-play the HTTP
            // header "data" events onto the socket once the HTTP machinery is
            // attached so that the node core `http` can parse and handle the
            // error status code.
            // Close the original socket, and a new "fake" socket is returned
            // instead, so that the proxy doesn't get the HTTP request
            // written to it (which may contain `Authorization` headers or other
            // sensitive data).
            //
            // See: https://hackerone.com/reports/541502
            socket.destroy();
            const fakeSocket = new net_1.default.Socket({
                writable: false
            });
            fakeSocket.readable = true;
            // Need to wait for the "socket" event to re-play the "data" events.
            req.once('socket', (s)=>{
                debug('replaying proxy buffer for failed request');
                assert_1.default(s.listenerCount('data') > 0);
                // Replay the "buffered" Buffer onto the fake `socket`, since at
                // this point the HTTP module machinery has been hooked up for
                // the user.
                s.push(buffered);
                s.push(null);
            });
            return fakeSocket;
        });
    }
}
exports.default = HttpsProxyAgent;
function resume(socket) {
    socket.resume();
}
function isDefaultPort(port, secure) {
    return Boolean(!secure && port === 80 || secure && port === 443);
}
function isHTTPS(protocol) {
    return typeof protocol === 'string' ? /^https:?$/i.test(protocol) : false;
}
function omit(obj, ...keys) {
    const ret = {};
    let key;
    for(key in obj){
        if (!keys.includes(key)) {
            ret[key] = obj[key];
        }
    }
    return ret;
} //# sourceMappingURL=agent.js.map
}}),
"[project]/node_modules/https-proxy-agent/dist/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
const agent_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/https-proxy-agent/dist/agent.js [app-client] (ecmascript)"));
function createHttpsProxyAgent(opts) {
    return new agent_1.default(opts);
}
(function(createHttpsProxyAgent) {
    createHttpsProxyAgent.HttpsProxyAgent = agent_1.default;
    createHttpsProxyAgent.prototype = agent_1.default.prototype;
})(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
module.exports = createHttpsProxyAgent; //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/abbrev/abbrev.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = exports = abbrev.abbrev = abbrev;
abbrev.monkeyPatch = monkeyPatch;
function monkeyPatch() {
    Object.defineProperty(Array.prototype, 'abbrev', {
        value: function() {
            return abbrev(this);
        },
        enumerable: false,
        configurable: true,
        writable: true
    });
    Object.defineProperty(Object.prototype, 'abbrev', {
        value: function() {
            return abbrev(Object.keys(this));
        },
        enumerable: false,
        configurable: true,
        writable: true
    });
}
function abbrev(list) {
    if (arguments.length !== 1 || !Array.isArray(list)) {
        list = Array.prototype.slice.call(arguments, 0);
    }
    for(var i = 0, l = list.length, args = []; i < l; i++){
        args[i] = typeof list[i] === "string" ? list[i] : String(list[i]);
    }
    // sort them lexicographically, so that they're next to their nearest kin
    args = args.sort(lexSort);
    // walk through each, seeing how much it has in common with the next and previous
    var abbrevs = {}, prev = "";
    for(var i = 0, l = args.length; i < l; i++){
        var current = args[i], next = args[i + 1] || "", nextMatches = true, prevMatches = true;
        if (current === next) continue;
        for(var j = 0, cl = current.length; j < cl; j++){
            var curChar = current.charAt(j);
            nextMatches = nextMatches && curChar === next.charAt(j);
            prevMatches = prevMatches && curChar === prev.charAt(j);
            if (!nextMatches && !prevMatches) {
                j++;
                break;
            }
        }
        prev = current;
        if (j === cl) {
            abbrevs[current] = current;
            continue;
        }
        for(var a = current.substr(0, j); j <= cl; j++){
            abbrevs[a] = current;
            a += current.charAt(j);
        }
    }
    return abbrevs;
}
function lexSort(a, b) {
    return a === b ? 0 : a > b ? 1 : -1;
}
}}),
"[project]/node_modules/nopt/lib/nopt.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// info about each config option.
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var debug = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.DEBUG_NOPT || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.NOPT_DEBUG ? function() {
    console.error.apply(console, arguments);
} : function() {};
var url = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/native-url/index.js [app-client] (ecmascript)"), path = __turbopack_context__.r("[project]/node_modules/path/path.js [app-client] (ecmascript)"), Stream = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/stream-browserify/index.js [app-client] (ecmascript)").Stream, abbrev = __turbopack_context__.r("[project]/node_modules/abbrev/abbrev.js [app-client] (ecmascript)"), os = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/os-browserify/browser.js [app-client] (ecmascript)");
module.exports = exports = nopt;
exports.clean = clean;
exports.typeDefs = {
    String: {
        type: String,
        validate: validateString
    },
    Boolean: {
        type: Boolean,
        validate: validateBoolean
    },
    url: {
        type: url,
        validate: validateUrl
    },
    Number: {
        type: Number,
        validate: validateNumber
    },
    path: {
        type: path,
        validate: validatePath
    },
    Stream: {
        type: Stream,
        validate: validateStream
    },
    Date: {
        type: Date,
        validate: validateDate
    }
};
function nopt(types, shorthands, args, slice) {
    args = args || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].argv;
    types = types || {};
    shorthands = shorthands || {};
    if (typeof slice !== "number") slice = 2;
    debug(types, shorthands, args, slice);
    args = args.slice(slice);
    var data = {}, key, argv = {
        remain: [],
        cooked: args,
        original: args.slice(0)
    };
    parse(args, data, argv.remain, types, shorthands);
    // now data is full
    clean(data, types, exports.typeDefs);
    data.argv = argv;
    Object.defineProperty(data.argv, 'toString', {
        value: function() {
            return this.original.map(JSON.stringify).join(" ");
        },
        enumerable: false
    });
    return data;
}
function clean(data, types, typeDefs) {
    typeDefs = typeDefs || exports.typeDefs;
    var remove = {}, typeDefault = [
        false,
        true,
        null,
        String,
        Array
    ];
    Object.keys(data).forEach(function(k) {
        if (k === "argv") return;
        var val = data[k], isArray = Array.isArray(val), type = types[k];
        if (!isArray) val = [
            val
        ];
        if (!type) type = typeDefault;
        if (type === Array) type = typeDefault.concat(Array);
        if (!Array.isArray(type)) type = [
            type
        ];
        debug("val=%j", val);
        debug("types=", type);
        val = val.map(function(val) {
            // if it's an unknown value, then parse false/true/null/numbers/dates
            if (typeof val === "string") {
                debug("string %j", val);
                val = val.trim();
                if (val === "null" && ~type.indexOf(null) || val === "true" && (~type.indexOf(true) || ~type.indexOf(Boolean)) || val === "false" && (~type.indexOf(false) || ~type.indexOf(Boolean))) {
                    val = JSON.parse(val);
                    debug("jsonable %j", val);
                } else if (~type.indexOf(Number) && !isNaN(val)) {
                    debug("convert to number", val);
                    val = +val;
                } else if (~type.indexOf(Date) && !isNaN(Date.parse(val))) {
                    debug("convert to date", val);
                    val = new Date(val);
                }
            }
            if (!types.hasOwnProperty(k)) {
                return val;
            }
            // allow `--no-blah` to set 'blah' to null if null is allowed
            if (val === false && ~type.indexOf(null) && !(~type.indexOf(false) || ~type.indexOf(Boolean))) {
                val = null;
            }
            var d = {};
            d[k] = val;
            debug("prevalidated val", d, val, types[k]);
            if (!validate(d, k, val, types[k], typeDefs)) {
                if (exports.invalidHandler) {
                    exports.invalidHandler(k, val, types[k], data);
                } else if (exports.invalidHandler !== false) {
                    debug("invalid: " + k + "=" + val, types[k]);
                }
                return remove;
            }
            debug("validated val", d, val, types[k]);
            return d[k];
        }).filter(function(val) {
            return val !== remove;
        });
        // if we allow Array specifically, then an empty array is how we
        // express 'no value here', not null.  Allow it.
        if (!val.length && type.indexOf(Array) === -1) {
            debug('VAL HAS NO LENGTH, DELETE IT', val, k, type.indexOf(Array));
            delete data[k];
        } else if (isArray) {
            debug(isArray, data[k], val);
            data[k] = val;
        } else data[k] = val[0];
        debug("k=%s val=%j", k, val, data[k]);
    });
}
function validateString(data, k, val) {
    data[k] = String(val);
}
function validatePath(data, k, val) {
    if (val === true) return false;
    if (val === null) return true;
    val = String(val);
    var isWin = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform === 'win32', homePattern = ("TURBOPACK compile-time falsy", 0) ? ("TURBOPACK unreachable", undefined) : /^~\//, home = os.homedir();
    if (home && val.match(homePattern)) {
        data[k] = path.resolve(home, val.substr(2));
    } else {
        data[k] = path.resolve(val);
    }
    return true;
}
function validateNumber(data, k, val) {
    debug("validate Number %j %j %j", k, val, isNaN(val));
    if (isNaN(val)) return false;
    data[k] = +val;
}
function validateDate(data, k, val) {
    var s = Date.parse(val);
    debug("validate Date %j %j %j", k, val, s);
    if (isNaN(s)) return false;
    data[k] = new Date(val);
}
function validateBoolean(data, k, val) {
    if (val instanceof Boolean) val = val.valueOf();
    else if (typeof val === "string") {
        if (!isNaN(val)) val = !!+val;
        else if (val === "null" || val === "false") val = false;
        else val = true;
    } else val = !!val;
    data[k] = val;
}
function validateUrl(data, k, val) {
    val = url.parse(String(val));
    if (!val.host) return false;
    data[k] = val.href;
}
function validateStream(data, k, val) {
    if (!(val instanceof Stream)) return false;
    data[k] = val;
}
function validate(data, k, val, type, typeDefs) {
    // arrays are lists of types.
    if (Array.isArray(type)) {
        for(var i = 0, l = type.length; i < l; i++){
            if (type[i] === Array) continue;
            if (validate(data, k, val, type[i], typeDefs)) return true;
        }
        delete data[k];
        return false;
    }
    // an array of anything?
    if (type === Array) return true;
    // NaN is poisonous.  Means that something is not allowed.
    if (type !== type) {
        debug("Poison NaN", k, val, type);
        delete data[k];
        return false;
    }
    // explicit list of values
    if (val === type) {
        debug("Explicitly allowed %j", val);
        // if (isArray) (data[k] = data[k] || []).push(val)
        // else data[k] = val
        data[k] = val;
        return true;
    }
    // now go through the list of typeDefs, validate against each one.
    var ok = false, types = Object.keys(typeDefs);
    for(var i = 0, l = types.length; i < l; i++){
        debug("test type %j %j %j", k, val, types[i]);
        var t = typeDefs[types[i]];
        if (t && (type && type.name && t.type && t.type.name ? type.name === t.type.name : type === t.type)) {
            var d = {};
            ok = false !== t.validate(d, k, val);
            val = d[k];
            if (ok) {
                // if (isArray) (data[k] = data[k] || []).push(val)
                // else data[k] = val
                data[k] = val;
                break;
            }
        }
    }
    debug("OK? %j (%j %j %j)", ok, k, val, types[i]);
    if (!ok) delete data[k];
    return ok;
}
function parse(args, data, remain, types, shorthands) {
    debug("parse", args, data, remain);
    var key = null, abbrevs = abbrev(Object.keys(types)), shortAbbr = abbrev(Object.keys(shorthands));
    for(var i = 0; i < args.length; i++){
        var arg = args[i];
        debug("arg", arg);
        if (arg.match(/^-{2,}$/)) {
            // done with keys.
            // the rest are args.
            remain.push.apply(remain, args.slice(i + 1));
            args[i] = "--";
            break;
        }
        var hadEq = false;
        if (arg.charAt(0) === "-" && arg.length > 1) {
            var at = arg.indexOf('=');
            if (at > -1) {
                hadEq = true;
                var v = arg.substr(at + 1);
                arg = arg.substr(0, at);
                args.splice(i, 1, arg, v);
            }
            // see if it's a shorthand
            // if so, splice and back up to re-parse it.
            var shRes = resolveShort(arg, shorthands, shortAbbr, abbrevs);
            debug("arg=%j shRes=%j", arg, shRes);
            if (shRes) {
                debug(arg, shRes);
                args.splice.apply(args, [
                    i,
                    1
                ].concat(shRes));
                if (arg !== shRes[0]) {
                    i--;
                    continue;
                }
            }
            arg = arg.replace(/^-+/, "");
            var no = null;
            while(arg.toLowerCase().indexOf("no-") === 0){
                no = !no;
                arg = arg.substr(3);
            }
            if (abbrevs[arg]) arg = abbrevs[arg];
            var argType = types[arg];
            var isTypeArray = Array.isArray(argType);
            if (isTypeArray && argType.length === 1) {
                isTypeArray = false;
                argType = argType[0];
            }
            var isArray = argType === Array || isTypeArray && argType.indexOf(Array) !== -1;
            // allow unknown things to be arrays if specified multiple times.
            if (!types.hasOwnProperty(arg) && data.hasOwnProperty(arg)) {
                if (!Array.isArray(data[arg])) data[arg] = [
                    data[arg]
                ];
                isArray = true;
            }
            var val, la = args[i + 1];
            var isBool = typeof no === 'boolean' || argType === Boolean || isTypeArray && argType.indexOf(Boolean) !== -1 || typeof argType === 'undefined' && !hadEq || la === "false" && (argType === null || isTypeArray && ~argType.indexOf(null));
            if (isBool) {
                // just set and move along
                val = !no;
                // however, also support --bool true or --bool false
                if (la === "true" || la === "false") {
                    val = JSON.parse(la);
                    la = null;
                    if (no) val = !val;
                    i++;
                }
                // also support "foo":[Boolean, "bar"] and "--foo bar"
                if (isTypeArray && la) {
                    if (~argType.indexOf(la)) {
                        // an explicit type
                        val = la;
                        i++;
                    } else if (la === "null" && ~argType.indexOf(null)) {
                        // null allowed
                        val = null;
                        i++;
                    } else if (!la.match(/^-{2,}[^-]/) && !isNaN(la) && ~argType.indexOf(Number)) {
                        // number
                        val = +la;
                        i++;
                    } else if (!la.match(/^-[^-]/) && ~argType.indexOf(String)) {
                        // string
                        val = la;
                        i++;
                    }
                }
                if (isArray) (data[arg] = data[arg] || []).push(val);
                else data[arg] = val;
                continue;
            }
            if (argType === String) {
                if (la === undefined) {
                    la = "";
                } else if (la.match(/^-{1,2}[^-]+/)) {
                    la = "";
                    i--;
                }
            }
            if (la && la.match(/^-{2,}$/)) {
                la = undefined;
                i--;
            }
            val = la === undefined ? true : la;
            if (isArray) (data[arg] = data[arg] || []).push(val);
            else data[arg] = val;
            i++;
            continue;
        }
        remain.push(arg);
    }
}
function resolveShort(arg, shorthands, shortAbbr, abbrevs) {
    // handle single-char shorthands glommed together, like
    // npm ls -glp, but only if there is one dash, and only if
    // all of the chars are single-char shorthands, and it's
    // not a match to some other abbrev.
    arg = arg.replace(/^-+/, '');
    // if it's an exact known option, then don't go any further
    if (abbrevs[arg] === arg) return null;
    // if it's an exact known shortopt, same deal
    if (shorthands[arg]) {
        // make it an array, if it's a list of words
        if (shorthands[arg] && !Array.isArray(shorthands[arg])) shorthands[arg] = shorthands[arg].split(/\s+/);
        return shorthands[arg];
    }
    // first check to see if this arg is a set of single-char shorthands
    var singles = shorthands.___singles;
    if (!singles) {
        singles = Object.keys(shorthands).filter(function(s) {
            return s.length === 1;
        }).reduce(function(l, r) {
            l[r] = true;
            return l;
        }, {});
        shorthands.___singles = singles;
        debug('shorthand singles', singles);
    }
    var chrs = arg.split("").filter(function(c) {
        return singles[c];
    });
    if (chrs.join("") === arg) return chrs.map(function(c) {
        return shorthands[c];
    }).reduce(function(l, r) {
        return l.concat(r);
    }, []);
    // if it's an arg abbrev, and not a literal shorthand, then prefer the arg
    if (abbrevs[arg] && !shorthands[arg]) return null;
    // if it's an abbr for a shorthand, then use that
    if (shortAbbr[arg]) arg = shortAbbr[arg];
    // make it an array, if it's a list of words
    if (shorthands[arg] && !Array.isArray(shorthands[arg])) shorthands[arg] = shorthands[arg].split(/\s+/);
    return shorthands[arg];
}
}}),
"[project]/node_modules/bcrypt/promises.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var Promise = global.Promise;
/// encapsulate a method with a node-style callback in a Promise
/// @param {object} 'this' of the encapsulated function
/// @param {function} function to be encapsulated
/// @param {Array-like} args to be passed to the called function
/// @return {Promise} a Promise encapsulating the function
module.exports.promise = function(fn, context, args) {
    if (!Array.isArray(args)) {
        args = Array.prototype.slice.call(args);
    }
    if (typeof fn !== 'function') {
        return Promise.reject(new Error('fn must be a function'));
    }
    return new Promise(function(resolve, reject) {
        args.push(function(err, data) {
            if (err) {
                reject(err);
            } else {
                resolve(data);
            }
        });
        fn.apply(context, args);
    });
};
/// @param {err} the error to be thrown
module.exports.reject = function(err) {
    return Promise.reject(err);
};
/// changes the promise implementation that bcrypt uses
/// @param {Promise} the implementation to use
module.exports.use = function(promise) {
    Promise = promise;
};
}}),
"[project]/node_modules/bcrypt/bcrypt.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
'use strict';
var nodePreGyp = __turbopack_context__.r("[project]/node_modules/@mapbox/node-pre-gyp/lib/node-pre-gyp.js [app-client] (ecmascript)");
var path = __turbopack_context__.r("[project]/node_modules/path/path.js [app-client] (ecmascript)");
var binding_path = nodePreGyp.find(path.resolve(path.join(__dirname, './package.json')));
var bindings = (()=>{
    const e = new Error("Cannot find module 'unknown'");
    e.code = 'MODULE_NOT_FOUND';
    throw e;
})();
var crypto = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/crypto-browserify/index.js [app-client] (ecmascript)");
var promises = __turbopack_context__.r("[project]/node_modules/bcrypt/promises.js [app-client] (ecmascript)");
/// generate a salt (sync)
/// @param {Number} [rounds] number of rounds (default 10)
/// @return {String} salt
module.exports.genSaltSync = function genSaltSync(rounds, minor) {
    // default 10 rounds
    if (!rounds) {
        rounds = 10;
    } else if (typeof rounds !== 'number') {
        throw new Error('rounds must be a number');
    }
    if (!minor) {
        minor = 'b';
    } else if (minor !== 'b' && minor !== 'a') {
        throw new Error('minor must be either "a" or "b"');
    }
    return bindings.gen_salt_sync(minor, rounds, crypto.randomBytes(16));
};
/// generate a salt
/// @param {Number} [rounds] number of rounds (default 10)
/// @param {Function} cb callback(err, salt)
module.exports.genSalt = function genSalt(rounds, minor, cb) {
    var error;
    // if callback is first argument, then use defaults for others
    if (typeof arguments[0] === 'function') {
        // have to set callback first otherwise arguments are overriden
        cb = arguments[0];
        rounds = 10;
        minor = 'b';
    // callback is second argument
    } else if (typeof arguments[1] === 'function') {
        // have to set callback first otherwise arguments are overriden
        cb = arguments[1];
        minor = 'b';
    }
    if (!cb) {
        return promises.promise(genSalt, this, [
            rounds,
            minor
        ]);
    }
    // default 10 rounds
    if (!rounds) {
        rounds = 10;
    } else if (typeof rounds !== 'number') {
        // callback error asynchronously
        error = new Error('rounds must be a number');
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(function() {
            cb(error);
        });
    }
    if (!minor) {
        minor = 'b';
    } else if (minor !== 'b' && minor !== 'a') {
        error = new Error('minor must be either "a" or "b"');
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(function() {
            cb(error);
        });
    }
    crypto.randomBytes(16, function(error, randomBytes) {
        if (error) {
            cb(error);
            return;
        }
        bindings.gen_salt(minor, rounds, randomBytes, cb);
    });
};
/// hash data using a salt
/// @param {String|Buffer} data the data to encrypt
/// @param {String} salt the salt to use when hashing
/// @return {String} hash
module.exports.hashSync = function hashSync(data, salt) {
    if (data == null || salt == null) {
        throw new Error('data and salt arguments required');
    }
    if (!(typeof data === 'string' || data instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"]) || typeof salt !== 'string' && typeof salt !== 'number') {
        throw new Error('data must be a string or Buffer and salt must either be a salt string or a number of rounds');
    }
    if (typeof salt === 'number') {
        salt = module.exports.genSaltSync(salt);
    }
    return bindings.encrypt_sync(data, salt);
};
/// hash data using a salt
/// @param {String|Buffer} data the data to encrypt
/// @param {String} salt the salt to use when hashing
/// @param {Function} cb callback(err, hash)
module.exports.hash = function hash(data, salt, cb) {
    var error;
    if (typeof data === 'function') {
        error = new Error('data must be a string or Buffer and salt must either be a salt string or a number of rounds');
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(function() {
            data(error);
        });
    }
    if (typeof salt === 'function') {
        error = new Error('data must be a string or Buffer and salt must either be a salt string or a number of rounds');
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(function() {
            salt(error);
        });
    }
    // cb exists but is not a function
    // return a rejecting promise
    if (cb && typeof cb !== 'function') {
        return promises.reject(new Error('cb must be a function or null to return a Promise'));
    }
    if (!cb) {
        return promises.promise(hash, this, [
            data,
            salt
        ]);
    }
    if (data == null || salt == null) {
        error = new Error('data and salt arguments required');
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(function() {
            cb(error);
        });
    }
    if (!(typeof data === 'string' || data instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"]) || typeof salt !== 'string' && typeof salt !== 'number') {
        error = new Error('data must be a string or Buffer and salt must either be a salt string or a number of rounds');
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(function() {
            cb(error);
        });
    }
    if (typeof salt === 'number') {
        return module.exports.genSalt(salt, function(err, salt) {
            return bindings.encrypt(data, salt, cb);
        });
    }
    return bindings.encrypt(data, salt, cb);
};
/// compare raw data to hash
/// @param {String|Buffer} data the data to hash and compare
/// @param {String} hash expected hash
/// @return {bool} true if hashed data matches hash
module.exports.compareSync = function compareSync(data, hash) {
    if (data == null || hash == null) {
        throw new Error('data and hash arguments required');
    }
    if (!(typeof data === 'string' || data instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"]) || typeof hash !== 'string') {
        throw new Error('data must be a string or Buffer and hash must be a string');
    }
    return bindings.compare_sync(data, hash);
};
/// compare raw data to hash
/// @param {String|Buffer} data the data to hash and compare
/// @param {String} hash expected hash
/// @param {Function} cb callback(err, matched) - matched is true if hashed data matches hash
module.exports.compare = function compare(data, hash, cb) {
    var error;
    if (typeof data === 'function') {
        error = new Error('data and hash arguments required');
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(function() {
            data(error);
        });
    }
    if (typeof hash === 'function') {
        error = new Error('data and hash arguments required');
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(function() {
            hash(error);
        });
    }
    // cb exists but is not a function
    // return a rejecting promise
    if (cb && typeof cb !== 'function') {
        return promises.reject(new Error('cb must be a function or null to return a Promise'));
    }
    if (!cb) {
        return promises.promise(compare, this, [
            data,
            hash
        ]);
    }
    if (data == null || hash == null) {
        error = new Error('data and hash arguments required');
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(function() {
            cb(error);
        });
    }
    if (!(typeof data === 'string' || data instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"]) || typeof hash !== 'string') {
        error = new Error('data and hash must be strings');
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(function() {
            cb(error);
        });
    }
    return bindings.compare(data, hash, cb);
};
/// @param {String} hash extract rounds from this hash
/// @return {Number} the number of rounds used to encrypt a given hash
module.exports.getRounds = function getRounds(hash) {
    if (hash == null) {
        throw new Error('hash argument required');
    }
    if (typeof hash !== 'string') {
        throw new Error('hash must be a string');
    }
    return bindings.get_rounds(hash);
};
}}),
}]);

//# sourceMappingURL=node_modules_ed5dfa69._.js.map